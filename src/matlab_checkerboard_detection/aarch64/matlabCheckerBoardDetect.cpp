//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: matlabCheckerBoardDetect.cpp
//
// MATLAB Coder version            : 5.6
// C/C++ source code generated on  : 04-May-2023 18:30:42
//

// Include Files
#include "matlabCheckerBoardDetect.h"
#include "matlabCheckerBoardDetect_internal_types.h"
#include "rt_nonfinite.h"
#include "coder_array.h"
#include "omp.h"
#include "rt_defines.h"
#include <algorithm>
#include <cfloat>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <stdexcept>
#include <string>

// Type Definitions
struct rtBoundsCheckInfo
{
  int iFirst;
  int iLast;
  int lineNo;
  int colNo;
  const char *aName;
  const char *fName;
  const char *pName;
  int checkKind;
};

struct rtEqualityCheckInfo
{
  int nDims;
  int lineNo;
  int colNo;
  const char *fName;
  const char *pName;
};

struct rtDoubleCheckInfo
{
  int lineNo;
  int colNo;
  const char *fName;
  const char *pName;
  int checkKind;
};

struct struct_T
{
  coder::array<bool, 2U> bw;
};

struct b_struct_T
{
  float pixel;
};

namespace coder
{
  namespace vision
  {
    namespace internal
    {
      namespace calibration
      {
        namespace checkerboard
        {
          class Checkerboard
          {
           public:
            void initialize(double seedIdx, const ::coder::array<float, 2U>
                            &points, const float v1[2], const float v2[2]);
            double findNeighbor(const ::coder::array<float, 2U> &pointVectors,
                                const ::coder::array<float, 1U> &euclideanDists,
                                const ::coder::array<float, 2U> &v) const;
            bool expandBoardOnce();
            void findClosestIndices(const ::coder::array<double, 2U>
              &predictedPoints, ::coder::array<double, 2U> &indices) const;
            bool b_expandBoardOnce();
            static void arrayFind(const ::coder::array<bool, 2U> &arr, ::coder::
                                  array<double, 2U> &matchedIdx);
           private:
            double findNeighbor(const ::coder::array<float, 2U> &pointVectors,
                                const ::coder::array<float, 1U> &euclideanDists,
                                const float v[2]) const;
            float computeInitialEnergy() const;
            void fitPolynomialIndices(::coder::array<double, 2U> &newIndices)
              const;
            void findIndependentVar(double coordsToUse[2]) const;
            void findClosestOnCurve(const double predictedPoint[2], double
              radius, const double curve_data[], const int curve_size[2], const
              double coordsToUse[2], const ::coder::array<double, 2U>
              &removedIdx, ::coder::array<double, 2U> &idx) const;
            void expandBoardUp(const ::coder::array<double, 2U> &indices, ::
                               coder::array<double, 2U> &newBoard, ::coder::
                               array<double, 3U> &newBoardCoords) const;
            float computeNewEnergyVertical(float oldEnergy) const;
            void fitPolynomialIndices(const ::coder::array<double, 2U> &idx, ::
              coder::array<double, 2U> &newIndices) const;
            void findIndependentVar(const ::coder::array<double, 2U> &idx,
              double coordsToUse[2]) const;
            void expandBoardDown(const ::coder::array<double, 2U> &indices, ::
                                 coder::array<double, 2U> &newBoard, ::coder::
                                 array<double, 3U> &newBoardCoords) const;
            float computeNewEnergyVertical(const ::coder::array<double, 2U> &idx,
              float oldEnergy) const;
            void b_fitPolynomialIndices(::coder::array<double, 2U> &newIndices)
              const;
            void b_findIndependentVar(double coordsToUse[2]) const;
            void expandBoardLeft(const ::coder::array<double, 2U> &indices, ::
                                 coder::array<double, 2U> &newBoard, ::coder::
                                 array<double, 3U> &newBoardCoords) const;
            float computeNewEnergyHorizontal(float oldEnergy) const;
            void b_findIndependentVar(const ::coder::array<double, 2U> &idx,
              double coordsToUse[2]) const;
            void expandBoardRight(const ::coder::array<double, 2U> &indices, ::
                                  coder::array<double, 2U> &newBoard, ::coder::
                                  array<double, 3U> &newBoardCoords) const;
            float computeNewEnergyHorizontal(const ::coder::array<double, 2U>
              &idx, float oldEnergy) const;
            void undoLastExpansion();
            void c_fitPolynomialIndices(::coder::array<double, 2U> &newIndices)
              const;
            void b_findClosestIndices(const ::coder::array<double, 2U>
              &predictedPoints, ::coder::array<double, 2U> &indices) const;
            void b_fitPolynomialIndices(const ::coder::array<double, 2U> &idx, ::
              coder::array<double, 2U> &newIndices) const;
            void d_fitPolynomialIndices(::coder::array<double, 2U> &newIndices)
              const;
            double findSearchParams(const ::coder::array<double, 2U> &idx, const
              ::coder::array<double, 2U> &validIdx, double currIdx, const double
              coordsToUse[2], double &moveMultiplier, double &firstValidIdx)
              const;
            double findSearchParams(const ::coder::array<double, 2U> &idx, const
              ::coder::array<double, 1U> &validIdx, double currIdx, const double
              coordsToUse[2], double &moveMultiplier, double &firstValidIdx)
              const;
           public:
            bool isValid;
            float Energy;
            array<double, 3U> BoardCoords;
            array<double, 2U> BoardIdx;
            array<float, 2U> Points;
            bool IsDirectionBad[4];
            bool IsDistortionHigh;
           private:
            double LastExpandDirection;
            float PreviousEnergy;
          };
        }
      }
    }
  }

  namespace images
  {
    namespace internal
    {
      namespace coder
      {
        class NeighborhoodProcessor
        {
         public:
          static void computeParameters(const int imSize[2], const bool nhConn[9],
            double rounding, int loffsets[9], int linds[9], int soffsets[18],
            int interiorStart[2], int interiorEnd[2]);
          void process2D(const ::coder::array<float, 2U> &in, ::coder::array<
                         bool, 2U> &out, const struct_T &fparams) const;
          bool Neighborhood[9];
          int ImageSize[2];
          int InteriorStart[2];
          int InteriorEnd[2];
          int ImageNeighborLinearOffsets[9];
          double Padding;
          double PadValue;
          bool ProcessBorder;
          double NeighborhoodCenter;
          int NeighborLinearIndices[9];
          int NeighborSubscriptOffsets[18];
        };
      }
    }
  }
}

// Variable Definitions
static double X[150];
omp_nest_lock_t matlabCheckerBoardDetect_nestLockGlobal;
static rtBoundsCheckInfo emlrtBCI{ -1, // iFirst
  -1,                                  // iLast
  122,                                 // lineNo
  67,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo b_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  89,                                  // lineNo
  25,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo c_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  89,                                  // lineNo
  23,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo d_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  20,                                  // lineNo
  15,                                  // colNo
  "",                                  // aName
  "detectCheckerboard",                // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo e_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  86,                                  // lineNo
  30,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo f_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  87,                                  // lineNo
  19,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo g_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  38,                                  // lineNo
  20,                                  // colNo
  "",                                  // aName
  "detectCheckerboard",                // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo h_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  122,                                 // lineNo
  75,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo i_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  129,                                 // lineNo
  41,                                  // colNo
  "",                                  // aName
  "growCheckerboard",                  // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo emlrtECI{ 1,// nDims
  30,                                  // lineNo
  12,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo b_emlrtECI{ 2,// nDims
  30,                                  // lineNo
  12,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo c_emlrtECI{ 1,// nDims
  31,                                  // lineNo
  13,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo d_emlrtECI{ 2,// nDims
  31,                                  // lineNo
  13,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo e_emlrtECI{ 1,// nDims
  37,                                  // lineNo
  15,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo f_emlrtECI{ 2,// nDims
  37,                                  // lineNo
  15,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo g_emlrtECI{ 1,// nDims
  40,                                  // lineNo
  47,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo h_emlrtECI{ 2,// nDims
  40,                                  // lineNo
  47,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo i_emlrtECI{ 1,// nDims
  40,                                  // lineNo
  11,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo j_emlrtECI{ 2,// nDims
  40,                                  // lineNo
  11,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo k_emlrtECI{ 1,// nDims
  42,                                  // lineNo
  51,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo l_emlrtECI{ 2,// nDims
  42,                                  // lineNo
  51,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo m_emlrtECI{ 1,// nDims
  42,                                  // lineNo
  11,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtEqualityCheckInfo n_emlrtECI{ 2,// nDims
  42,                                  // lineNo
  11,                                  // colNo
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m"// pName
};

static rtBoundsCheckInfo j_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  41,                                  // lineNo
  9,                                   // colNo
  "",                                  // aName
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo k_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  43,                                  // lineNo
  9,                                   // colNo
  "",                                  // aName
  "secondDerivCornerMetric",           // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/secondDerivCornerMetric.m",// pName
  0                                    // checkKind
};

static rtRunTimeErrorInfo emlrtRTEI{ 14,// lineNo
  37,                                  // colNo
  "validatenonnan",                    // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/+valattr/validatenonnan.m"// pName
};

static rtBoundsCheckInfo l_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  1105,                                // lineNo
  12,                                  // colNo
  "",                                  // aName
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo o_emlrtECI{ -1,// nDims
  1105,                                // lineNo
  5,                                   // colNo
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m"// pName
};

static rtBoundsCheckInfo m_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  1107,                                // lineNo
  42,                                  // colNo
  "",                                  // aName
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo p_emlrtECI{ 1,// nDims
  1107,                                // lineNo
  21,                                  // colNo
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m"// pName
};

static rtEqualityCheckInfo q_emlrtECI{ -1,// nDims
  1107,                                // lineNo
  9,                                   // colNo
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m"// pName
};

static rtBoundsCheckInfo n_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  1116,                                // lineNo
  16,                                  // colNo
  "",                                  // aName
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo o_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  1116,                                // lineNo
  19,                                  // colNo
  "",                                  // aName
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo p_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  1118,                                // lineNo
  49,                                  // colNo
  "",                                  // aName
  "conv2_separable_valid",             // fName
  "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
  0                                    // checkKind
};

static rtRunTimeErrorInfo b_emlrtRTEI{ 392,// lineNo
  1,                                   // colNo
  "find_first_indices",                // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elmat/find.m"// pName
};

static rtRunTimeErrorInfo c_emlrtRTEI{ 134,// lineNo
  27,                                  // colNo
  "unaryMinOrMax",                     // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/unaryMinOrMax.m"// pName
};

static rtRunTimeErrorInfo e_emlrtRTEI{ 122,// lineNo
  5,                                   // colNo
  "errOrWarnIf",                       // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/indexShapeCheck.m"// pName
};

static rtRunTimeErrorInfo f_emlrtRTEI{ 13,// lineNo
  9,                                   // colNo
  "sqrt",                              // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elfun/sqrt.m"// pName
};

static rtRunTimeErrorInfo g_emlrtRTEI{ 14,// lineNo
  15,                                  // colNo
  "scalexpCheck",                      // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/scalexpCheck.m"// pName
};

static rtRunTimeErrorInfo h_emlrtRTEI{ 13,// lineNo
  27,                                  // colNo
  "assertCompatibleDims",              // fName
  "/usr/local/MATLAB/R2023a/toolbox/shared/coder/coder/lib/+coder/+internal/assertCompatibleDims.m"// pName
};

static rtRunTimeErrorInfo i_emlrtRTEI{ 133,// lineNo
  23,                                  // colNo
  "dynamic_size_checks",               // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static rtRunTimeErrorInfo j_emlrtRTEI{ 138,// lineNo
  23,                                  // colNo
  "dynamic_size_checks",               // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/ops/eml_mtimes_helper.m"// pName
};

static rtEqualityCheckInfo r_emlrtECI{ 1,// nDims
  240,                                 // lineNo
  21,                                  // colNo
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtEqualityCheckInfo s_emlrtECI{ 1,// nDims
  240,                                 // lineNo
  38,                                  // colNo
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo q_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  243,                                 // lineNo
  19,                                  // colNo
  "",                                  // aName
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo emlrtDCI{ 243,// lineNo
  19,                                  // colNo
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo r_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  243,                                 // lineNo
  33,                                  // colNo
  "",                                  // aName
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo s_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  246,                                 // lineNo
  19,                                  // colNo
  "",                                  // aName
  "Checkerboard/findNeighbor",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo t_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  394,                                 // lineNo
  43,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo u_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  395,                                 // lineNo
  43,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo t_emlrtECI{ 1,// nDims
  396,                                 // lineNo
  25,                                  // colNo
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtEqualityCheckInfo u_emlrtECI{ 2,// nDims
  396,                                 // lineNo
  25,                                  // colNo
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo v_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  408,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo w_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  409,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo v_emlrtECI{ 1,// nDims
  410,                                 // lineNo
  25,                                  // colNo
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtEqualityCheckInfo w_emlrtECI{ 2,// nDims
  410,                                 // lineNo
  25,                                  // colNo
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo x_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  408,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo b_emlrtDCI{ 408,// lineNo
  46,                                  // colNo
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo y_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  409,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo c_emlrtDCI{ 409,// lineNo
  46,                                  // colNo
  "Checkerboard/predictPointsHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo ab_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  450,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo bb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  450,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo x_emlrtECI{ -1,// nDims
  487,                                 // lineNo
  25,                                  // colNo
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo cb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  394,                                 // lineNo
  47,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo d_emlrtDCI{ 394,// lineNo
  43,                                  // colNo
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo db_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  395,                                 // lineNo
  47,                                  // colNo
  "",                                  // aName
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo e_emlrtDCI{ 395,// lineNo
  43,                                  // colNo
  "Checkerboard/predictPointsVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo eb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  585,                                 // lineNo
  55,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo fb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  585,                                 // lineNo
  74,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo gb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  586,                                 // lineNo
  38,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo hb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  586,                                 // lineNo
  57,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ib_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  585,                                 // lineNo
  64,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo jb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  586,                                 // lineNo
  47,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo kb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  471,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo lb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  471,                                 // lineNo
  56,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo mb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  471,                                 // lineNo
  70,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo nb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  487,                                 // lineNo
  36,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ob_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  448,                                 // lineNo
  56,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo pb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  448,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo qb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  536,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo rb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  536,                                 // lineNo
  42,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo sb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  535,                                 // lineNo
  62,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo tb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  535,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ub_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  582,                                 // lineNo
  65,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo vb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  583,                                 // lineNo
  48,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo wb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  583,                                 // lineNo
  57,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo xb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  582,                                 // lineNo
  55,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo yb_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  583,                                 // lineNo
  38,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolyCurve",         // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ac_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  469,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo bc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  469,                                 // lineNo
  68,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo cc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  510,                                 // lineNo
  44,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo dc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  510,                                 // lineNo
  74,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo y_emlrtECI{ 2,// nDims
  510,                                 // lineNo
  30,                                  // colNo
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo ec_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo fc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo gc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  98,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo hc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  116,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ic_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  512,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo jc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  512,                                 // lineNo
  116,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo kc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  65,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo lc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  511,                                 // lineNo
  105,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo mc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  512,                                 // lineNo
  65,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo nc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  512,                                 // lineNo
  105,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtRunTimeErrorInfo l_emlrtRTEI{ 26,// lineNo
  23,                                  // colNo
  "polyfit",                           // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/polyfun/polyfit.m"// pName
};

static rtRunTimeErrorInfo m_emlrtRTEI{ 53,// lineNo
  15,                                  // colNo
  "bsxfun",                            // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elmat/bsxfun.m"// pName
};

static rtRunTimeErrorInfo n_emlrtRTEI{ 444,// lineNo
  5,                                   // colNo
  "do_vectors",                        // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/ops/private/eml_setop.m"// pName
};

static rtRunTimeErrorInfo o_emlrtRTEI{ 406,// lineNo
  5,                                   // colNo
  "do_vectors",                        // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/ops/private/eml_setop.m"// pName
};

static rtRunTimeErrorInfo p_emlrtRTEI{ 74,// lineNo
  13,                                  // colNo
  "reshapeSizeChecks",                 // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/reshapeSizeChecks.m"// pName
};

static rtRunTimeErrorInfo q_emlrtRTEI{ 81,// lineNo
  23,                                  // colNo
  "reshapeSizeChecks",                 // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/reshapeSizeChecks.m"// pName
};

static rtBoundsCheckInfo oc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  608,                                 // lineNo
  53,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo pc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  608,                                 // lineNo
  40,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo qc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  606,                                 // lineNo
  37,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo rc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  604,                                 // lineNo
  62,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo sc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  606,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo tc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  607,                                 // lineNo
  52,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtDoubleCheckInfo f_emlrtDCI{ 607,// lineNo
  52,                                  // colNo
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  1                                    // checkKind
};

static rtBoundsCheckInfo uc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  609,                                 // lineNo
  52,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo vc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  610,                                 // lineNo
  23,                                  // colNo
  "",                                  // aName
  "Checkerboard/findClosestIndices",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo wc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  745,                                 // lineNo
  38,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo xc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  745,                                 // lineNo
  68,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo ab_emlrtECI{ 2,// nDims
  745,                                 // lineNo
  24,                                  // colNo
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo yc_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  746,                                 // lineNo
  31,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ad_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  751,                                 // lineNo
  48,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo bd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  751,                                 // lineNo
  86,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo bb_emlrtECI{ 3,// nDims
  751,                                 // lineNo
  31,                                  // colNo
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo cd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  752,                                 // lineNo
  42,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo cb_emlrtECI{ 2,// nDims
  751,                                 // lineNo
  31,                                  // colNo
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo dd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  756,                                 // lineNo
  74,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ed_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  756,                                 // lineNo
  87,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo fd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  759,                                 // lineNo
  39,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo gd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  759,                                 // lineNo
  47,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo hd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  759,                                 // lineNo
  66,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo id_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  759,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo jd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  770,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo kd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  771,                                 // lineNo
  44,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ld_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  771,                                 // lineNo
  52,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo md_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  771,                                 // lineNo
  91,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo db_emlrtECI{ 3,// nDims
  771,                                 // lineNo
  27,                                  // colNo
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo nd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  772,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo od_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  773,                                 // lineNo
  54,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo pd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  773,                                 // lineNo
  92,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtRunTimeErrorInfo r_emlrtRTEI{ 13,// lineNo
  13,                                  // colNo
  "toLogicalCheck",                    // fName
  "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/toLogicalCheck.m"// pName
};

static rtBoundsCheckInfo qd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  751,                                 // lineNo
  55,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo rd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  751,                                 // lineNo
  93,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo sd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  752,                                 // lineNo
  49,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo td_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  753,                                 // lineNo
  57,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ud_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  753,                                 // lineNo
  95,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyVertical",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo vd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  539,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo wd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  539,                                 // lineNo
  42,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo xd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  538,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo yd_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  538,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ae_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  514,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo be_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  514,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo eb_emlrtECI{ -1,// nDims
  514,                                 // lineNo
  30,                                  // colNo
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo ce_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  69,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo de_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ee_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  109,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo fe_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  116,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ge_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  516,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo he_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  516,                                 // lineNo
  116,                                 // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ie_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo je_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  515,                                 // lineNo
  98,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ke_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  516,                                 // lineNo
  58,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo le_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  516,                                 // lineNo
  98,                                  // colNo
  "",                                  // aName
  "Checkerboard/findIndependentVar",   // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo me_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  790,                                 // lineNo
  40,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ne_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  790,                                 // lineNo
  70,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo fb_emlrtECI{ -1,// nDims
  790,                                 // lineNo
  24,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo oe_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  791,                                 // lineNo
  33,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo gb_emlrtECI{ 1,// nDims
  790,                                 // lineNo
  24,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo pe_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  796,                                 // lineNo
  57,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo qe_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  796,                                 // lineNo
  95,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo hb_emlrtECI{ 3,// nDims
  796,                                 // lineNo
  31,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo re_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  797,                                 // lineNo
  51,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo ib_emlrtECI{ 1,// nDims
  796,                                 // lineNo
  31,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtEqualityCheckInfo jb_emlrtECI{ 3,// nDims
  798,                                 // lineNo
  33,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo se_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  801,                                 // lineNo
  74,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo te_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  801,                                 // lineNo
  87,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ue_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  804,                                 // lineNo
  39,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ve_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  804,                                 // lineNo
  47,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo we_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  804,                                 // lineNo
  66,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo xe_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  804,                                 // lineNo
  76,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ye_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  815,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo af_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  816,                                 // lineNo
  44,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo bf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  816,                                 // lineNo
  53,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo cf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  816,                                 // lineNo
  83,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtEqualityCheckInfo kb_emlrtECI{ 3,// nDims
  816,                                 // lineNo
  27,                                  // colNo
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
};

static rtBoundsCheckInfo df_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  817,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ef_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  818,                                 // lineNo
  46,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo ff_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  818,                                 // lineNo
  85,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo gf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  796,                                 // lineNo
  48,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo hf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  796,                                 // lineNo
  86,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo if_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  797,                                 // lineNo
  42,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo jf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  798,                                 // lineNo
  50,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo kf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  798,                                 // lineNo
  88,                                  // colNo
  "",                                  // aName
  "Checkerboard/computeNewEnergyHorizontal",// fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo lf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  498,                                 // lineNo
  28,                                  // colNo
  "",                                  // aName
  "Checkerboard/fitPolynomialIndices", // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo mf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  546,                                 // lineNo
  65,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo nf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  546,                                 // lineNo
  51,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo of_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  541,                                 // lineNo
  43,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static rtBoundsCheckInfo pf_emlrtBCI{ -1,// iFirst
  -1,                                  // iLast
  533,                                 // lineNo
  20,                                  // colNo
  "",                                  // aName
  "Checkerboard/findSearchParams",     // fName
  "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
  0                                    // checkKind
};

static bool isInitialized_matlabCheckerBoardDetect{ false };

// Function Declarations
static void ab_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void b_and(coder::array<bool, 2U> &in1, const coder::array<bool, 2U> &in2);
static void b_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5);
static void b_binary_expand_op(coder::array<double, 3U> &in1, const coder::
  vision::internal::calibration::checkerboard::Checkerboard *in2, const coder::
  array<double, 2U> &in3, int in4);
static void b_binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  float, 2U> &in2);
static void b_minus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                    &in2);
static void b_or(coder::array<bool, 1U> &in1, const coder::array<bool, 1U> &in2,
                 const coder::array<bool, 1U> &in3);
static void b_plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                   &in2);
static void b_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void b_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum);
static void bb_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 2U> &in3);
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, const coder::array<double, 2U> &in4, int in5);
static double binary_expand_op(const coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, const coder::array<double, 2U> &in4);
static void binary_expand_op(coder::vision::internal::calibration::checkerboard::
  Checkerboard *in1, const coder::array<float, 2U> &in2, const coder::array<
  float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::array<float,
  2U> &in5);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<int,
  1U> &in3, const coder::array<double, 3U> &in4);
static void binary_expand_op(coder::array<double, 1U> &in1, const coder::array<
  double, 2U> &in2, int in3);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 3U> &in2, const coder::array<double, 3U> &in3, const coder::array<
  double, 3U> &in4);
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, int in4);
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  float, 2U> &in2);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<int,
  1U> &in3, const coder::array<double, 2U> &in4, const coder::array<double, 3U>
  &in5);
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const double in3_data[], int in4);
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, double in3);
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  double, 2U> &in3, const coder::array<float, 2U> &in4);
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, int in4, const coder::array<double, 2U> &in5);
static void binary_expand_op(coder::array<float, 1U> &in1, const coder::array<
  float, 1U> &in2);
static void c_and(coder::array<bool, 1U> &in1, const coder::array<bool, 1U> &in2);
static void c_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5);
static void c_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum);
static void c_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
namespace coder
{
  static bool all(const ::coder::array<double, 2U> &x);
  static bool any(const ::coder::array<bool, 1U> &x);
  static bool b_any(const ::coder::array<bool, 2U> &x);
  static void b_conv2_separable_valid(const double hCol[29], const double hRow
    [29], const ::coder::array<double, 2U> &inImg, const double finalSize[2], ::
    coder::array<double, 2U> &outImg);
  static void b_eml_find(const ::coder::array<bool, 1U> &x, double kin, ::coder::
    array<int, 1U> &i);
  static void b_hypot(const ::coder::array<double, 1U> &x, const ::coder::array<
                      double, 1U> &y, ::coder::array<double, 1U> &r);
  static void b_hypot(const ::coder::array<float, 1U> &x, const ::coder::array<
                      float, 1U> &y, ::coder::array<float, 1U> &r);
  static bool b_isequal(const double varargin_1_data[], const int
                        varargin_1_size[2], double varargin_2);
  static double b_norm(const ::coder::array<double, 1U> &x);
  static void b_rot90(const ::coder::array<double, 2U> &A, ::coder::array<double,
                      2U> &B);
  static void b_squeeze(const ::coder::array<double, 3U> &a, ::coder::array<
                        double, 2U> &b);
  static int bsearchni(int k, const ::coder::array<double, 2U> &x, const ::coder::
                       array<double, 1U> &s);
  static int bsearchni(int k, const ::coder::array<double, 2U> &x, const ::coder::
                       array<double, 2U> &s);
  static void bsxfun(const ::coder::array<float, 2U> &a, const ::coder::array<
                     double, 2U> &b, ::coder::array<float, 2U> &c);
  static void bwlookup(const ::coder::array<bool, 2U> &bwin, ::coder::array<bool,
                       2U> &B);
  static void bwmorph(::coder::array<bool, 2U> &bwin);
  static void c_eml_find(const ::coder::array<bool, 1U> &x, ::coder::array<int,
    1U> &i);
  static void cat(const ::coder::array<double, 2U> &varargin_1, const ::coder::
                  array<double, 2U> &varargin_2, ::coder::array<double, 3U> &y);
  static void check_forloop_overflow_error();
  static void conv2_separable_valid(const double hCol[15], const double hRow[15],
    const ::coder::array<double, 2U> &inImg, const double finalSize[2], ::coder::
    array<double, 2U> &outImg);
  static int do_vectors(const ::coder::array<double, 2U> &a, const ::coder::
                        array<double, 1U> &b, ::coder::array<double, 2U> &c, ::
                        coder::array<int, 1U> &ia);
  static int do_vectors(const ::coder::array<double, 2U> &a, const ::coder::
                        array<double, 2U> &b, ::coder::array<double, 2U> &c, ::
                        coder::array<int, 1U> &ia);
  static void eml_find(const ::coder::array<double, 2U> &x, ::coder::array<int,
                       2U> &i);
  static void eml_find(const ::coder::array<double, 1U> &x, ::coder::array<int,
                       1U> &i);
  static void flip(::coder::array<double, 2U> &x, double dim);
  static void imfilter(::coder::array<float, 2U> &varargin_1);
  namespace internal
  {
    static bool allinrange(const ::coder::array<float, 1U> &x, int hi);
    static void b_conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c);
    static void b_indexShapeCheck(const int matrixSize[2], const int indexSize[2]);
    static void b_indexShapeCheck(const int matrixSize[2], int indexSize);
    static void b_indexShapeCheck(const int matrixSize[2]);
    namespace blas
    {
      static double xnrm2(int n, const ::coder::array<double, 2U> &x, int ix0);
    }

    static void c_conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c);
    static void conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c);
    static bool ifWhileCond(const ::coder::array<bool, 2U> &x);
    static void indexShapeCheck(const int matrixSize[2]);
    static void indexShapeCheck(int matrixSize, const int indexSize[2]);
    static void indexShapeCheck(const int matrixSize[2], const int indexSize[2]);
    static void indexShapeCheck(const int matrixSize[2], int indexSize);
    static double maximum(const ::coder::array<double, 1U> &x);
    static float maximum(const float x[3]);
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<float, 1U> &x,
                      int offset, int np, int nq, ::coder::array<int, 1U> &iwork,
                      ::coder::array<float, 1U> &xwork);
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<double, 1U>
                      &x, int offset, int np, int nq, ::coder::array<int, 1U>
                      &iwork, ::coder::array<double, 1U> &xwork);
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<int, 1U> &x,
                      int offset, int np, int nq, ::coder::array<int, 1U> &iwork,
                      ::coder::array<int, 1U> &xwork);
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<float,
      1U> &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U>
      &iwork, ::coder::array<float, 1U> &xwork);
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<double,
      1U> &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U>
      &iwork, ::coder::array<double, 1U> &xwork);
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<int, 1U>
      &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U> &iwork, ::
      coder::array<int, 1U> &xwork);
    static float minimum(const ::coder::array<float, 1U> &x, int &idx);
    static float minimum(const ::coder::array<float, 1U> &x);
    static double minimum(const ::coder::array<double, 1U> &x, int &idx);
    static int qrsolve(const ::coder::array<double, 2U> &A, const ::coder::array<
                       double, 1U> &B, double Y_data[], int &rankA);
    namespace reflapack
    {
      static void xzlarf(int m, int n, int iv0, double tau, ::coder::array<
                         double, 2U> &C, int ic0, int ldc, double work_data[]);
    }

    static void sort(::coder::array<double, 1U> &x, ::coder::array<int, 1U> &idx);
    static void sort(::coder::array<int, 1U> &x, ::coder::array<int, 1U> &idx);
    static void sort(::coder::array<float, 1U> &x, ::coder::array<int, 1U> &idx);
    static void sort(double x[4]);
    static void sortIdx(::coder::array<float, 1U> &x, ::coder::array<int, 1U>
                        &idx);
    static void sortIdx(const ::coder::array<double, 2U> &x, ::coder::array<int,
                        2U> &idx);
    static void sub2ind(const int siz[2], const ::coder::array<float, 1U>
                        &varargin_1, const ::coder::array<float, 1U> &varargin_2,
                        ::coder::array<int, 1U> &idx);
  }

  static void isMember(const ::coder::array<double, 2U> &a, const ::coder::array<
                       double, 2U> &s, ::coder::array<bool, 2U> &tf);
  static bool isequal(const ::coder::array<bool, 2U> &varargin_1, const ::coder::
                      array<bool, 2U> &varargin_2);
  static double mean(const ::coder::array<double, 1U> &x);
  static float mean(const ::coder::array<float, 1U> &x);
  static double mean(const ::coder::array<double, 2U> &x);
  static void padImage_outSize(const ::coder::array<float, 2U> &a_tmp, const
    double pad[2], ::coder::array<float, 2U> &a);
  static void polyfit(const ::coder::array<double, 2U> &x, const ::coder::array<
                      double, 2U> &y, double n, double p_data[], int p_size[2]);
  static void polyfit(const ::coder::array<double, 1U> &x, const ::coder::array<
                      double, 1U> &y, double n, double p_data[], int p_size[2]);
  static void rot90(const ::coder::array<double, 2U> &A, ::coder::array<double,
                    2U> &B);
  static void squeeze(const ::coder::array<double, 3U> &a, ::coder::array<double,
                      2U> &b);
  namespace vision
  {
    namespace internal
    {
      namespace calibration
      {
        namespace checkerboard
        {
          static void b_secondDerivCornerMetric(const ::coder::array<float, 2U>
            &b_I, ::coder::array<float, 2U> &cxy, ::coder::array<float, 2U> &c45,
            ::coder::array<float, 2U> &Ix, ::coder::array<float, 2U> &Iy, ::
            coder::array<float, 2U> &Ixy, ::coder::array<float, 2U> &I_45_45);
          static void computeJacobianEntries(const ::coder::array<float, 2U> &Ix,
            const ::coder::array<float, 2U> &Iy, ::coder::array<float, 2U> &Ix2,
            ::coder::array<float, 2U> &Iy2, ::coder::array<float, 2U> &Ixy);
          static void cornerOrientations(const ::coder::array<float, 2U> &Ix2,
            const ::coder::array<float, 2U> &Iy2, const ::coder::array<float, 2U>
            &Ixy, const float p[2], float v1[2], float v2[2]);
          static void detectCheckerboard(const ::coder::array<float, 2U> &b_I, ::
            coder::array<double, 2U> &points, double boardSize[2]);
          static void find_peaks(const ::coder::array<float, 2U> &metric, ::
            coder::array<float, 2U> &loc);
          static bool isUpperLeftBlack(const Checkerboard *b_this, const ::coder::
            array<float, 2U> &b_I);
          static Checkerboard *orient(Checkerboard *board, const ::coder::array<
            float, 2U> &b_I);
          static void poly2RectMask(double b_X[4], double Y[4], double height,
            double width, ::coder::array<bool, 2U> &mask);
          static void secondDerivCornerMetric(const ::coder::array<float, 2U>
            &b_I, ::coder::array<float, 2U> &cxy, ::coder::array<float, 2U> &c45,
            ::coder::array<float, 2U> &Ix, ::coder::array<float, 2U> &Iy, ::
            coder::array<float, 2U> &Ixy, ::coder::array<float, 2U> &I_45_45);
          static void subPixelLocation(const ::coder::array<float, 2U> &metric, ::
            coder::array<double, 2U> &loc);
          static void toPoints(const Checkerboard *b_this, ::coder::array<double,
                               2U> &points, double boardSize[2]);
        }
      }
    }
  }
}

static void d_and(coder::array<bool, 2U> &in1, const coder::array<bool, 2U> &in2);
static void d_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5);
static void d_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void d_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum);
static int div_s32(int numerator, int denominator);
static void e_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum);
static void e_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void emlrtDimSizeImpxCheckR2021b(const int aDim1, const int aDim2, const
  rtEqualityCheckInfo &aInfo);
static void f_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void g_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void h_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void i_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void j_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void k_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void l_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void m_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void minus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                  &in2);
static void n_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void o_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void p_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void plus(coder::array<float, 1U> &in1, const coder::array<float, 1U>
                 &in2);
static void plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                 &in2);
static void plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                 &in2, const coder::array<float, 2U> &in3);
static void q_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void r_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void rdivide(coder::array<float, 1U> &in1, const coder::array<float, 1U>
                    &in2);
static void rtDivisionByZeroError(const rtRunTimeErrorInfo &aInfo);
static void rtDivisionByZeroErrorN();
static void rtDynamicBoundsError(int aIndexValue, int aLoBound, int aHiBound,
  const rtBoundsCheckInfo &aInfo);
static void rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum);
static void rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static std::string rtGenSizeString(const int aNDims, const int *aDims);
static void rtIntegerError(const double aInteger, const rtDoubleCheckInfo &aInfo);
static bool rtIsNullOrEmptyString(const char *aString);
static void rtNonNegativeError(const double aPositive, const rtDoubleCheckInfo &
  aInfo);
static void rtSizeEq1DError(const int aDim1, const int aDim2, const
  rtEqualityCheckInfo &aInfo);
static void rtSizeEqNDCheck(const int *aDims1, const int *aDims2, const
  rtEqualityCheckInfo &aInfo);
static void rtSubAssignSizeCheck(const int *aDims1, const int aNDims1, const int
  *aDims2, const int aNDims2, const rtEqualityCheckInfo &aInfo);
static float rt_atan2f_snf(float u0, float u1);
static double rt_hypotd_snf(double u0, double u1);
static float rt_hypotf_snf(float u0, float u1);
static double rt_remd_snf(double u0, double u1);
static void s_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void subPixelLocationImpl_init();
static void t_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void times(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                  &in2, const coder::array<float, 2U> &in3);
static void u_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void v_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void w_rtErrorWithMessageID(const char *aFcnName, int aLineNum);
static void y_rtErrorWithMessageID(const char *aFcnName, int aLineNum);

// Function Definitions
//
// Arguments    : const int imSize[2]
//                const bool nhConn[9]
//                double rounding
//                int loffsets[9]
//                int linds[9]
//                int soffsets[18]
//                int interiorStart[2]
//                int interiorEnd[2]
// Return Type  : void
//
namespace coder
{
  namespace images
  {
    namespace internal
    {
      namespace coder
      {
        void NeighborhoodProcessor::computeParameters(const int imSize[2], const
          bool nhConn[9], double rounding, int loffsets[9], int linds[9], int
          soffsets[18], int interiorStart[2], int interiorEnd[2])
        {
          static rtBoundsCheckInfo qf_emlrtBCI{ 1,// iFirst
            9,                         // iLast
            797,                       // lineNo
            34,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/computeParameters",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            3                          // checkKind
          };

          static rtDoubleCheckInfo g_emlrtDCI{ 754,// lineNo
            13,                        // colNo
            "NeighborhoodProcessor/computeParameters",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            1                          // checkKind
          };

          int k;
          int nz;
          int pixelsPerImPage1_idx_1;
          pixelsPerImPage1_idx_1 = imSize[0];
          if (rounding != static_cast<int>(std::floor(rounding))) {
            rtIntegerError(rounding, g_emlrtDCI);
          }

          interiorStart[0] = 2;
          interiorEnd[0] = imSize[0] - 1;
          interiorStart[1] = 2;
          interiorEnd[1] = imSize[1] - 1;
          nz = nhConn[0];
          for (k = 0; k < 8; k++) {
            nz += nhConn[k + 1];
          }

          if (nz != 0) {
            nz = 0;
            for (int pind{0}; pind < 9; pind++) {
              if (nhConn[pind]) {
                int subs_idx_1_tmp;
                k = static_cast<int>(rt_remd_snf((static_cast<double>(pind) +
                  1.0) - 1.0, 3.0));
                subs_idx_1_tmp = static_cast<int>((static_cast<double>((pind - k)
                  - 1) + 1.0) / 3.0);
                if (nz + 1 > 9) {
                  rtDynamicBoundsError(10, 1, 9, qf_emlrtBCI);
                }

                soffsets[nz] = k + 1;
                soffsets[nz + 9] = subs_idx_1_tmp + 1;
                linds[nz] = (k + subs_idx_1_tmp * 3) + 1;
                loffsets[nz] = (k + subs_idx_1_tmp * pixelsPerImPage1_idx_1) + 1;
                nz++;
              }
            }

            for (nz = 0; nz < 9; nz++) {
              loffsets[nz] = (loffsets[nz] - imSize[0]) - 2;
            }

            for (nz = 0; nz < 18; nz++) {
              soffsets[nz] -= 2;
            }
          }
        }

        //
        // Arguments    : const ::coder::array<float, 2U> &in
        //                ::coder::array<bool, 2U> &out
        //                const struct_T &fparams
        // Return Type  : void
        //
        void NeighborhoodProcessor::process2D(const ::coder::array<float, 2U>
          &in, ::coder::array<bool, 2U> &out, const struct_T &fparams) const
        {
          static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            450,                       // lineNo
            40,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            460,                       // lineNo
            24,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            525,                       // lineNo
            40,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2DExteriorOnly",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            531,                       // lineNo
            30,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2DExteriorOnly",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            536,                       // lineNo
            28,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2DExteriorOnly",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            539,                       // lineNo
            25,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2DExteriorOnly",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            90,                        // lineNo
            50,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo hg_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            527,                       // lineNo
            40,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2DExteriorOnly",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            448,                       // lineNo
            40,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            455,                       // lineNo
            28,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            80,                        // lineNo
            24,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            458,                       // lineNo
            26,                        // colNo
            "",                        // aName
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            81,                        // lineNo
            16,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            84,                        // lineNo
            17,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            89,                        // lineNo
            18,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo xf_emlrtBCI{ 1,// iFirst
            9,                         // iLast
            90,                        // lineNo
            50,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
            -1,                        // iLast
            90,                        // lineNo
            32,                        // colNo
            "",                        // aName
            "nhRegionalMaxAlgo",       // fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imregionalmax.m",// pName
            0                          // checkKind
          };

          static rtDoubleCheckInfo g_emlrtDCI{ 280,// lineNo
            20,                        // colNo
            "NeighborhoodProcessor/getNeighborIndices",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m",// pName
            1                          // checkKind
          };

          static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
            460,                       // lineNo
            17,                        // colNo
            "NeighborhoodProcessor/process2D",// fName
            "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/+coder/NeighborhoodProcessor.m"// pName
          };

          static rtRunTimeErrorInfo s_emlrtRTEI{ 248,// lineNo
            5,                         // colNo
            "eml_scalar_uint_rdivide", // fName
            "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/div.m"// pName
          };

          array<bool, 1U> out_;
          b_struct_T fparamsAugmented;
          float imnh_data[81];
          float f;
          int imageNeighborLinearOffsets[9];
          int imnhInds[9];
          int imnhInds_data[9];
          int firstIndRange[2];
          int iv[2];
          int pixelSub[2];
          int a;
          int b;
          int b_firstInd;
          int b_i;
          int c_i;
          int exitg1;
          int i;
          int i2;
          int lb_loop;
          int pind;
          int ub_loop;
          int z;
          signed char imnh_size[2];
          bool out__tmp;
          pixelSub[0] = InteriorStart[1];
          pixelSub[1] = InteriorEnd[1];
          firstIndRange[0] = InteriorStart[0];
          firstIndRange[1] = InteriorEnd[0];
          for (i = 0; i < 9; i++) {
            imageNeighborLinearOffsets[i] = ImageNeighborLinearOffsets[i];
          }

          i = ImageSize[0];
          lb_loop = pixelSub[0];
          ub_loop = pixelSub[1];
          if ((pixelSub[0] <= pixelSub[1]) && (pixelSub[1] > 2147483646)) {
            check_forloop_overflow_error();
          }

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(out_,fparamsAugmented,imnh_data,imnh_size,imnhInds,pind,a,b,b_firstInd,b_i,c_i,iv,i2,out__tmp,exitg1,f)

          for (int secondInd = lb_loop; secondInd <= ub_loop; secondInd++) {
            out_.set_size(out.size(0));
            a = firstIndRange[0];
            b = firstIndRange[1];
            if ((firstIndRange[0] <= firstIndRange[1]) && (firstIndRange[1] >
                 2147483646)) {
              check_forloop_overflow_error();
            }

            for (b_firstInd = a; b_firstInd <= b; b_firstInd++) {
              //  Process pixels with full neighborhood
              pind = (secondInd - 1) * i + b_firstInd;
              for (c_i = 0; c_i < 9; c_i++) {
                imnhInds[c_i] = imageNeighborLinearOffsets[c_i] + pind;
              }

              if (in.size(0) == 1) {
                iv[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)->size())
                  [0];
                iv[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)->size())
                  [1];
                ::coder::internal::indexShapeCheck(iv);
                imnh_size[0] = 1;
                imnh_size[1] = 9;
                c_i = in.size(1);
                for (b_i = 0; b_i < 9; b_i++) {
                  i2 = imnhInds[b_i];
                  if ((i2 < 1) || (i2 > c_i)) {
                    rtDynamicBoundsError(i2, 1, c_i, qf_emlrtBCI);
                  }

                  imnh_data[b_i] = in[i2 - 1];
                }
              } else {
                iv[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)->size())
                  [0];
                iv[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)->size())
                  [1];
                ::coder::internal::b_indexShapeCheck(iv);
                imnh_size[0] = 9;
                imnh_size[1] = 1;
                c_i = in.size(0) * in.size(1);
                for (b_i = 0; b_i < 9; b_i++) {
                  i2 = imnhInds[b_i];
                  if ((i2 < 1) || (i2 > c_i)) {
                    rtDynamicBoundsError(i2, 1, c_i, ag_emlrtBCI);
                  }

                  imnh_data[b_i] = in[i2 - 1];
                }
              }

              b_i = in.size(0) * in.size(1);
              if ((pind < 1) || (pind > b_i)) {
                rtDynamicBoundsError(pind, 1, b_i, rf_emlrtBCI);
              }

              fparamsAugmented.pixel = in[pind - 1];
              b_i = fparams.bw.size(0) * fparams.bw.size(1);
              if (pind > b_i) {
                rtDynamicBoundsError(pind, 1, b_i, sf_emlrtBCI);
              }

              if ((b_firstInd < 1) || (b_firstInd > out_.size(0))) {
                rtDynamicBoundsError(b_firstInd, 1, out_.size(0), tf_emlrtBCI);
              }

              out__tmp = fparams.bw[pind - 1];
              out_[b_firstInd - 1] = out__tmp;
              if (pind > b_i) {
                rtDynamicBoundsError(pind, 1, b_i, uf_emlrtBCI);
              }

              if (out__tmp) {
                //  Pixel has not already been set as non-max
                c_i = 1;
                do {
                  exitg1 = 0;
                  i2 = imnh_size[0] * imnh_size[1];
                  if (c_i - 1 <= i2 - 1) {
                    if (c_i > i2) {
                      rtDynamicBoundsError(c_i, 1, i2, vf_emlrtBCI);
                    }

                    f = imnh_data[c_i - 1];
                    if (f > fparamsAugmented.pixel) {
                      //  Set pixel to zero if any neighbor is greater
                      if (b_firstInd > out_.size(0)) {
                        rtDynamicBoundsError(b_firstInd, 1, out_.size(0),
                                             tf_emlrtBCI);
                      }

                      out_[b_firstInd - 1] = false;
                      exitg1 = 1;
                    } else {
                      if (c_i > i2) {
                        rtDynamicBoundsError(c_i, 1, i2, wf_emlrtBCI);
                      }

                      if (f == fparamsAugmented.pixel) {
                        if (c_i > 9) {
                          rtDynamicBoundsError(c_i, 1, 9, xf_emlrtBCI);
                        }

                        i2 = imnhInds[c_i - 1];
                        if ((i2 < 1) || (i2 > b_i)) {
                          rtDynamicBoundsError(i2, 1, b_i, yf_emlrtBCI);
                        }

                        if (!fparams.bw[i2 - 1]) {
                          //  Set pixel to zero if any equal neighbor is already set to zero
                          if (b_firstInd > out_.size(0)) {
                            rtDynamicBoundsError(b_firstInd, 1, out_.size(0),
                                                 tf_emlrtBCI);
                          }

                          out_[b_firstInd - 1] = false;
                          exitg1 = 1;
                        } else {
                          c_i++;
                        }
                      } else {
                        c_i++;
                      }
                    }
                  } else {
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }
            }

            b_i = out.size(1);
            if ((secondInd < 1) || (secondInd > b_i)) {
              rtDynamicBoundsError(secondInd, 1, b_i, bg_emlrtBCI);
            }

            rtSubAssignSizeCheck(out.size(), 1, out_.size(), 1, lb_emlrtECI);
            c_i = out_.size(0);
            for (b_i = 0; b_i < c_i; b_i++) {
              out[b_i + out.size(0) * (secondInd - 1)] = out_[b_i];
            }
          }

          if (ProcessBorder) {
            float b_imnh_data[81];
            float f1;
            float fparamsAugmented_pixel;
            float padValue_tmp;
            int imnhSubs[18];
            int iv1[2];
            int b_pind;
            int i1;
            int secondDimExtents_idx_0;
            int secondDimExtents_idx_1;
            int trueCount;
            int u1;
            int y;
            bool isInside[9];
            bool b_b;
            bool exitg2;
            secondDimExtents_idx_1 = InteriorStart[1] - 1;
            padValue_tmp = static_cast<float>(PadValue);
            i = ImageSize[0];
            u1 = ImageSize[0];
            if (i <= u1) {
              u1 = i;
            }

            i = ImageSize[1];
            if (secondDimExtents_idx_1 > i) {
              secondDimExtents_idx_1 = i;
            }

            if (secondDimExtents_idx_1 > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int b_secondInd{0}; b_secondInd < secondDimExtents_idx_1;
                 b_secondInd++) {
              if (u1 > 2147483646) {
                check_forloop_overflow_error();
              }

              for (int firstInd{0}; firstInd < u1; firstInd++) {
                //  Process pixels with partial neighborhood
                b_pind = (b_secondInd * ImageSize[0] + firstInd) + 1;
                for (i = 0; i < 9; i++) {
                  imageNeighborLinearOffsets[i] = ImageNeighborLinearOffsets[i]
                    + b_pind;
                }

                i1 = ImageSize[0];
                if (i1 == 0) {
                  i = 1;
                } else {
                  i = b_pind - i1 * div_s32(b_pind - 1, i1);
                }

                lb_loop = b_pind - i;
                if (i1 == 0) {
                  if (lb_loop == 0) {
                    z = 0;
                  } else if (lb_loop < 0) {
                    z = MIN_int32_T;
                  } else {
                    z = MAX_int32_T;
                  }
                } else if (i1 == 1) {
                  z = lb_loop;
                } else if (i1 == -1) {
                  z = -lb_loop;
                } else {
                  if (lb_loop >= 0) {
                    ub_loop = lb_loop;
                  } else if (lb_loop == MIN_int32_T) {
                    ub_loop = MAX_int32_T;
                  } else {
                    ub_loop = -lb_loop;
                  }

                  if (i1 >= 0) {
                    y = i1;
                  } else if (i1 == MIN_int32_T) {
                    y = MAX_int32_T;
                  } else {
                    y = -i1;
                  }

                  if (static_cast<unsigned int>(y) == 0U) {
                    rtDivisionByZeroError(s_emlrtRTEI);
                  } else {
                    z = static_cast<int>(static_cast<unsigned int>(ub_loop) /
                                         static_cast<unsigned int>(y));
                  }

                  ub_loop -= z * y;
                  if ((ub_loop > 0) && (ub_loop >= (y >> 1) + (y & 1))) {
                    z++;
                  }

                  if ((lb_loop < 0) != (i1 < 0)) {
                    z = -z;
                  }
                }

                pixelSub[1] = z + 1;
                pixelSub[0] = i;
                for (lb_loop = 0; lb_loop < 2; lb_loop++) {
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = ub_loop + 9 * lb_loop;
                    imnhSubs[i] = NeighborSubscriptOffsets[i] + pixelSub[lb_loop];
                  }
                }

                for (i = 0; i < 9; i++) {
                  isInside[i] = true;
                }

                if (Padding != static_cast<int>(std::floor(Padding))) {
                  rtIntegerError(Padding, g_emlrtDCI);
                }

                switch (static_cast<int>(Padding)) {
                 case 1:
                  trueCount = 0;
                  i = 0;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }

                    if (isInside[ub_loop]) {
                      trueCount++;
                      imnhInds_data[i] = imageNeighborLinearOffsets[ub_loop];
                      i++;
                    }
                  }
                  break;

                 case 2:
                  trueCount = 9;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    imnhInds_data[ub_loop] = imageNeighborLinearOffsets[ub_loop];
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        imnhInds_data[ub_loop] = 1;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }
                  }
                  break;

                 case 3:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[0] = 1;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      pixelSub[0] = i1;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[1] = 1;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      pixelSub[1] = z;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 case 4:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[0] << 1;
                      pixelSub[0] = i;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      i = ((i1 << 1) - i) + 1;
                      pixelSub[0] = i;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[1] << 1;
                      pixelSub[1] = i;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      i = ((z << 1) - i) + 1;
                      pixelSub[1] = i;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 default:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }
                  break;
                }

                if (in.size(0) == 1) {
                  i = in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, cg_emlrtBCI);
                    }
                  }

                  firstIndRange[0] = 1;
                  firstIndRange[1] = trueCount;
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, firstIndRange);
                  ub_loop = 1;
                  y = trueCount;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                } else {
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, trueCount);
                  i = in.size(0) * in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, hg_emlrtBCI);
                    }
                  }

                  ub_loop = trueCount;
                  y = 1;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                }

                if (Padding == 2.0) {
                  for (i = 0; i < 9; i++) {
                    if (!isInside[i]) {
                      i1 = ub_loop * y - 1;
                      if (i > i1) {
                        rtDynamicBoundsError(i, 0, i1, dg_emlrtBCI);
                      }

                      b_imnh_data[i] = padValue_tmp;
                    }
                  }
                }

                i1 = in.size(0) * in.size(1);
                if ((b_pind < 1) || (b_pind > i1)) {
                  rtDynamicBoundsError(b_pind, 1, i1, eg_emlrtBCI);
                }

                fparamsAugmented_pixel = in[b_pind - 1];
                i = out.size(0) * out.size(1);
                i1 = fparams.bw.size(0) * fparams.bw.size(1);
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, sf_emlrtBCI);
                }

                if (b_pind > i) {
                  rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                }

                b_b = fparams.bw[b_pind - 1];
                out[b_pind - 1] = b_b;
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, uf_emlrtBCI);
                }

                if (b_b) {
                  //  Pixel has not already been set as non-max
                  lb_loop = 1;
                  do {
                    exitg1 = 0;
                    z = ub_loop * y;
                    if (lb_loop - 1 <= z - 1) {
                      if (lb_loop > z) {
                        rtDynamicBoundsError(lb_loop, 1, z, vf_emlrtBCI);
                      }

                      f1 = b_imnh_data[lb_loop - 1];
                      if (f1 > fparamsAugmented_pixel) {
                        //  Set pixel to zero if any neighbor is greater
                        if (b_pind > i) {
                          rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                        }

                        out[b_pind - 1] = false;
                        exitg1 = 1;
                      } else {
                        if (lb_loop > z) {
                          rtDynamicBoundsError(lb_loop, 1, z, wf_emlrtBCI);
                        }

                        if (f1 == fparamsAugmented_pixel) {
                          if (lb_loop > trueCount) {
                            rtDynamicBoundsError(lb_loop, 1, trueCount,
                                                 gg_emlrtBCI);
                          }

                          z = imnhInds_data[lb_loop - 1];
                          if ((z < 1) || (z > i1)) {
                            rtDynamicBoundsError(z, 1, i1, yf_emlrtBCI);
                          }

                          if (!fparams.bw[z - 1]) {
                            //  Set pixel to zero if any equal neighbor is already set to zero
                            if (b_pind > i) {
                              rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                            }

                            out[b_pind - 1] = false;
                            exitg1 = 1;
                          } else {
                            lb_loop++;
                          }
                        } else {
                          lb_loop++;
                        }
                      }
                    } else {
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }
              }
            }

            secondDimExtents_idx_0 = InteriorEnd[1] + 1;
            secondDimExtents_idx_1 = ImageSize[1];
            if (secondDimExtents_idx_0 < 1) {
              secondDimExtents_idx_0 = 1;
            }

            i = ImageSize[1];
            if (secondDimExtents_idx_1 > i) {
              secondDimExtents_idx_1 = i;
            }

            if ((secondDimExtents_idx_0 <= secondDimExtents_idx_1) &&
                (secondDimExtents_idx_1 > 2147483646)) {
              check_forloop_overflow_error();
            }

            for (int b_secondInd{secondDimExtents_idx_0}; b_secondInd <=
                 secondDimExtents_idx_1; b_secondInd++) {
              if (u1 > 2147483646) {
                check_forloop_overflow_error();
              }

              for (int firstInd{0}; firstInd < u1; firstInd++) {
                //  Process pixels with partial neighborhood
                b_pind = ((b_secondInd - 1) * ImageSize[0] + firstInd) + 1;
                for (i = 0; i < 9; i++) {
                  imageNeighborLinearOffsets[i] = ImageNeighborLinearOffsets[i]
                    + b_pind;
                }

                i1 = ImageSize[0];
                if (i1 == 0) {
                  i = 1;
                } else {
                  i = b_pind - i1 * div_s32(b_pind - 1, i1);
                }

                lb_loop = b_pind - i;
                if (i1 == 0) {
                  if (lb_loop == 0) {
                    z = 0;
                  } else if (lb_loop < 0) {
                    z = MIN_int32_T;
                  } else {
                    z = MAX_int32_T;
                  }
                } else if (i1 == 1) {
                  z = lb_loop;
                } else if (i1 == -1) {
                  z = -lb_loop;
                } else {
                  if (lb_loop >= 0) {
                    ub_loop = lb_loop;
                  } else if (lb_loop == MIN_int32_T) {
                    ub_loop = MAX_int32_T;
                  } else {
                    ub_loop = -lb_loop;
                  }

                  if (i1 >= 0) {
                    y = i1;
                  } else if (i1 == MIN_int32_T) {
                    y = MAX_int32_T;
                  } else {
                    y = -i1;
                  }

                  if (static_cast<unsigned int>(y) == 0U) {
                    rtDivisionByZeroError(s_emlrtRTEI);
                  } else {
                    z = static_cast<int>(static_cast<unsigned int>(ub_loop) /
                                         static_cast<unsigned int>(y));
                  }

                  ub_loop -= z * y;
                  if ((ub_loop > 0) && (ub_loop >= (y >> 1) + (y & 1))) {
                    z++;
                  }

                  if ((lb_loop < 0) != (i1 < 0)) {
                    z = -z;
                  }
                }

                pixelSub[1] = z + 1;
                pixelSub[0] = i;
                for (lb_loop = 0; lb_loop < 2; lb_loop++) {
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = ub_loop + 9 * lb_loop;
                    imnhSubs[i] = NeighborSubscriptOffsets[i] + pixelSub[lb_loop];
                  }
                }

                for (i = 0; i < 9; i++) {
                  isInside[i] = true;
                }

                if (Padding != static_cast<int>(std::floor(Padding))) {
                  rtIntegerError(Padding, g_emlrtDCI);
                }

                switch (static_cast<int>(Padding)) {
                 case 1:
                  trueCount = 0;
                  i = 0;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }

                    if (isInside[ub_loop]) {
                      trueCount++;
                      imnhInds_data[i] = imageNeighborLinearOffsets[ub_loop];
                      i++;
                    }
                  }
                  break;

                 case 2:
                  trueCount = 9;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    imnhInds_data[ub_loop] = imageNeighborLinearOffsets[ub_loop];
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        imnhInds_data[ub_loop] = 1;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }
                  }
                  break;

                 case 3:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[0] = 1;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      pixelSub[0] = i1;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[1] = 1;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      pixelSub[1] = z;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 case 4:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[0] << 1;
                      pixelSub[0] = i;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      i = ((i1 << 1) - i) + 1;
                      pixelSub[0] = i;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[1] << 1;
                      pixelSub[1] = i;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      i = ((z << 1) - i) + 1;
                      pixelSub[1] = i;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 default:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }
                  break;
                }

                if (in.size(0) == 1) {
                  i = in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, cg_emlrtBCI);
                    }
                  }

                  firstIndRange[0] = 1;
                  firstIndRange[1] = trueCount;
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, firstIndRange);
                  ub_loop = 1;
                  y = trueCount;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                } else {
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, trueCount);
                  i = in.size(0) * in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, hg_emlrtBCI);
                    }
                  }

                  ub_loop = trueCount;
                  y = 1;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                }

                if (Padding == 2.0) {
                  for (i = 0; i < 9; i++) {
                    if (!isInside[i]) {
                      i1 = ub_loop * y - 1;
                      if (i > i1) {
                        rtDynamicBoundsError(i, 0, i1, dg_emlrtBCI);
                      }

                      b_imnh_data[i] = padValue_tmp;
                    }
                  }
                }

                i1 = in.size(0) * in.size(1);
                if ((b_pind < 1) || (b_pind > i1)) {
                  rtDynamicBoundsError(b_pind, 1, i1, eg_emlrtBCI);
                }

                fparamsAugmented_pixel = in[b_pind - 1];
                i = out.size(0) * out.size(1);
                i1 = fparams.bw.size(0) * fparams.bw.size(1);
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, sf_emlrtBCI);
                }

                if (b_pind > i) {
                  rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                }

                b_b = fparams.bw[b_pind - 1];
                out[b_pind - 1] = b_b;
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, uf_emlrtBCI);
                }

                if (b_b) {
                  //  Pixel has not already been set as non-max
                  lb_loop = 1;
                  do {
                    exitg1 = 0;
                    z = ub_loop * y;
                    if (lb_loop - 1 <= z - 1) {
                      if (lb_loop > z) {
                        rtDynamicBoundsError(lb_loop, 1, z, vf_emlrtBCI);
                      }

                      f1 = b_imnh_data[lb_loop - 1];
                      if (f1 > fparamsAugmented_pixel) {
                        //  Set pixel to zero if any neighbor is greater
                        if (b_pind > i) {
                          rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                        }

                        out[b_pind - 1] = false;
                        exitg1 = 1;
                      } else {
                        if (lb_loop > z) {
                          rtDynamicBoundsError(lb_loop, 1, z, wf_emlrtBCI);
                        }

                        if (f1 == fparamsAugmented_pixel) {
                          if (lb_loop > trueCount) {
                            rtDynamicBoundsError(lb_loop, 1, trueCount,
                                                 gg_emlrtBCI);
                          }

                          z = imnhInds_data[lb_loop - 1];
                          if ((z < 1) || (z > i1)) {
                            rtDynamicBoundsError(z, 1, i1, yf_emlrtBCI);
                          }

                          if (!fparams.bw[z - 1]) {
                            //  Set pixel to zero if any equal neighbor is already set to zero
                            if (b_pind > i) {
                              rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                            }

                            out[b_pind - 1] = false;
                            exitg1 = 1;
                          } else {
                            lb_loop++;
                          }
                        } else {
                          lb_loop++;
                        }
                      }
                    } else {
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }
              }
            }

            secondDimExtents_idx_1 = InteriorStart[0] - 1;
            u1 = ImageSize[0];
            if (secondDimExtents_idx_1 > u1) {
              secondDimExtents_idx_1 = u1;
            }

            i = ImageSize[1];
            u1 = ImageSize[1];
            if (i <= u1) {
              u1 = i;
            }

            if (u1 > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int b_secondInd{1}; b_secondInd <= u1; b_secondInd++) {
              if (secondDimExtents_idx_1 > 2147483646) {
                check_forloop_overflow_error();
              }

              for (int firstInd{0}; firstInd < secondDimExtents_idx_1; firstInd
                   ++) {
                //  Process pixels with partial neighborhood
                b_pind = ((b_secondInd - 1) * ImageSize[0] + firstInd) + 1;
                for (i = 0; i < 9; i++) {
                  imageNeighborLinearOffsets[i] = ImageNeighborLinearOffsets[i]
                    + b_pind;
                }

                i1 = ImageSize[0];
                if (i1 == 0) {
                  i = 1;
                } else {
                  i = b_pind - i1 * div_s32(b_pind - 1, i1);
                }

                lb_loop = b_pind - i;
                if (i1 == 0) {
                  if (lb_loop == 0) {
                    z = 0;
                  } else if (lb_loop < 0) {
                    z = MIN_int32_T;
                  } else {
                    z = MAX_int32_T;
                  }
                } else if (i1 == 1) {
                  z = lb_loop;
                } else if (i1 == -1) {
                  z = -lb_loop;
                } else {
                  if (lb_loop >= 0) {
                    ub_loop = lb_loop;
                  } else if (lb_loop == MIN_int32_T) {
                    ub_loop = MAX_int32_T;
                  } else {
                    ub_loop = -lb_loop;
                  }

                  if (i1 >= 0) {
                    y = i1;
                  } else if (i1 == MIN_int32_T) {
                    y = MAX_int32_T;
                  } else {
                    y = -i1;
                  }

                  if (static_cast<unsigned int>(y) == 0U) {
                    rtDivisionByZeroError(s_emlrtRTEI);
                  } else {
                    z = static_cast<int>(static_cast<unsigned int>(ub_loop) /
                                         static_cast<unsigned int>(y));
                  }

                  ub_loop -= z * y;
                  if ((ub_loop > 0) && (ub_loop >= (y >> 1) + (y & 1))) {
                    z++;
                  }

                  if ((lb_loop < 0) != (i1 < 0)) {
                    z = -z;
                  }
                }

                pixelSub[1] = z + 1;
                pixelSub[0] = i;
                for (lb_loop = 0; lb_loop < 2; lb_loop++) {
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = ub_loop + 9 * lb_loop;
                    imnhSubs[i] = NeighborSubscriptOffsets[i] + pixelSub[lb_loop];
                  }
                }

                for (i = 0; i < 9; i++) {
                  isInside[i] = true;
                }

                if (Padding != static_cast<int>(std::floor(Padding))) {
                  rtIntegerError(Padding, g_emlrtDCI);
                }

                switch (static_cast<int>(Padding)) {
                 case 1:
                  trueCount = 0;
                  i = 0;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }

                    if (isInside[ub_loop]) {
                      trueCount++;
                      imnhInds_data[i] = imageNeighborLinearOffsets[ub_loop];
                      i++;
                    }
                  }
                  break;

                 case 2:
                  trueCount = 9;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    imnhInds_data[ub_loop] = imageNeighborLinearOffsets[ub_loop];
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        imnhInds_data[ub_loop] = 1;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }
                  }
                  break;

                 case 3:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[0] = 1;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      pixelSub[0] = i1;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[1] = 1;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      pixelSub[1] = z;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 case 4:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[0] << 1;
                      pixelSub[0] = i;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      i = ((i1 << 1) - i) + 1;
                      pixelSub[0] = i;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[1] << 1;
                      pixelSub[1] = i;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      i = ((z << 1) - i) + 1;
                      pixelSub[1] = i;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 default:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }
                  break;
                }

                if (in.size(0) == 1) {
                  i = in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, cg_emlrtBCI);
                    }
                  }

                  firstIndRange[0] = 1;
                  firstIndRange[1] = trueCount;
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, firstIndRange);
                  ub_loop = 1;
                  y = trueCount;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                } else {
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, trueCount);
                  i = in.size(0) * in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, hg_emlrtBCI);
                    }
                  }

                  ub_loop = trueCount;
                  y = 1;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                }

                if (Padding == 2.0) {
                  for (i = 0; i < 9; i++) {
                    if (!isInside[i]) {
                      i1 = ub_loop * y - 1;
                      if (i > i1) {
                        rtDynamicBoundsError(i, 0, i1, dg_emlrtBCI);
                      }

                      b_imnh_data[i] = padValue_tmp;
                    }
                  }
                }

                i1 = in.size(0) * in.size(1);
                if ((b_pind < 1) || (b_pind > i1)) {
                  rtDynamicBoundsError(b_pind, 1, i1, eg_emlrtBCI);
                }

                fparamsAugmented_pixel = in[b_pind - 1];
                i = out.size(0) * out.size(1);
                i1 = fparams.bw.size(0) * fparams.bw.size(1);
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, sf_emlrtBCI);
                }

                if (b_pind > i) {
                  rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                }

                b_b = fparams.bw[b_pind - 1];
                out[b_pind - 1] = b_b;
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, uf_emlrtBCI);
                }

                if (b_b) {
                  //  Pixel has not already been set as non-max
                  lb_loop = 1;
                  do {
                    exitg1 = 0;
                    z = ub_loop * y;
                    if (lb_loop - 1 <= z - 1) {
                      if (lb_loop > z) {
                        rtDynamicBoundsError(lb_loop, 1, z, vf_emlrtBCI);
                      }

                      f1 = b_imnh_data[lb_loop - 1];
                      if (f1 > fparamsAugmented_pixel) {
                        //  Set pixel to zero if any neighbor is greater
                        if (b_pind > i) {
                          rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                        }

                        out[b_pind - 1] = false;
                        exitg1 = 1;
                      } else {
                        if (lb_loop > z) {
                          rtDynamicBoundsError(lb_loop, 1, z, wf_emlrtBCI);
                        }

                        if (f1 == fparamsAugmented_pixel) {
                          if (lb_loop > trueCount) {
                            rtDynamicBoundsError(lb_loop, 1, trueCount,
                                                 gg_emlrtBCI);
                          }

                          z = imnhInds_data[lb_loop - 1];
                          if ((z < 1) || (z > i1)) {
                            rtDynamicBoundsError(z, 1, i1, yf_emlrtBCI);
                          }

                          if (!fparams.bw[z - 1]) {
                            //  Set pixel to zero if any equal neighbor is already set to zero
                            if (b_pind > i) {
                              rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                            }

                            out[b_pind - 1] = false;
                            exitg1 = 1;
                          } else {
                            lb_loop++;
                          }
                        } else {
                          lb_loop++;
                        }
                      }
                    } else {
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }
              }
            }

            secondDimExtents_idx_0 = InteriorEnd[0] + 1;
            secondDimExtents_idx_1 = ImageSize[0];
            if (secondDimExtents_idx_0 < 1) {
              secondDimExtents_idx_0 = 1;
            }

            i = ImageSize[0];
            if (secondDimExtents_idx_1 > i) {
              secondDimExtents_idx_1 = i;
            }

            for (int b_secondInd{0}; b_secondInd < u1; b_secondInd++) {
              if ((secondDimExtents_idx_0 <= secondDimExtents_idx_1) &&
                  (secondDimExtents_idx_1 > 2147483646)) {
                check_forloop_overflow_error();
              }

              for (int firstInd{secondDimExtents_idx_0}; firstInd <=
                   secondDimExtents_idx_1; firstInd++) {
                //  Process pixels with partial neighborhood
                b_pind = b_secondInd * ImageSize[0] + firstInd;
                for (i = 0; i < 9; i++) {
                  imageNeighborLinearOffsets[i] = ImageNeighborLinearOffsets[i]
                    + b_pind;
                }

                i1 = ImageSize[0];
                if (i1 == 0) {
                  i = 1;
                } else {
                  i = b_pind - i1 * div_s32(b_pind - 1, i1);
                }

                lb_loop = b_pind - i;
                if (i1 == 0) {
                  if (lb_loop == 0) {
                    z = 0;
                  } else if (lb_loop < 0) {
                    z = MIN_int32_T;
                  } else {
                    z = MAX_int32_T;
                  }
                } else if (i1 == 1) {
                  z = lb_loop;
                } else if (i1 == -1) {
                  z = -lb_loop;
                } else {
                  if (lb_loop >= 0) {
                    ub_loop = lb_loop;
                  } else if (lb_loop == MIN_int32_T) {
                    ub_loop = MAX_int32_T;
                  } else {
                    ub_loop = -lb_loop;
                  }

                  if (i1 >= 0) {
                    y = i1;
                  } else if (i1 == MIN_int32_T) {
                    y = MAX_int32_T;
                  } else {
                    y = -i1;
                  }

                  if (static_cast<unsigned int>(y) == 0U) {
                    rtDivisionByZeroError(s_emlrtRTEI);
                  } else {
                    z = static_cast<int>(static_cast<unsigned int>(ub_loop) /
                                         static_cast<unsigned int>(y));
                  }

                  ub_loop -= z * y;
                  if ((ub_loop > 0) && (ub_loop >= (y >> 1) + (y & 1))) {
                    z++;
                  }

                  if ((lb_loop < 0) != (i1 < 0)) {
                    z = -z;
                  }
                }

                pixelSub[1] = z + 1;
                pixelSub[0] = i;
                for (lb_loop = 0; lb_loop < 2; lb_loop++) {
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = ub_loop + 9 * lb_loop;
                    imnhSubs[i] = NeighborSubscriptOffsets[i] + pixelSub[lb_loop];
                  }
                }

                for (i = 0; i < 9; i++) {
                  isInside[i] = true;
                }

                if (Padding != static_cast<int>(std::floor(Padding))) {
                  rtIntegerError(Padding, g_emlrtDCI);
                }

                switch (static_cast<int>(Padding)) {
                 case 1:
                  trueCount = 0;
                  i = 0;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }

                    if (isInside[ub_loop]) {
                      trueCount++;
                      imnhInds_data[i] = imageNeighborLinearOffsets[ub_loop];
                      i++;
                    }
                  }
                  break;

                 case 2:
                  trueCount = 9;
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    imnhInds_data[ub_loop] = imageNeighborLinearOffsets[ub_loop];
                    lb_loop = 0;
                    exitg2 = false;
                    while ((!exitg2) && (lb_loop < 2)) {
                      i1 = imnhSubs[ub_loop + 9 * lb_loop];
                      if ((i1 < 1) || (i1 > ImageSize[lb_loop])) {
                        isInside[ub_loop] = false;
                        imnhInds_data[ub_loop] = 1;
                        exitg2 = true;
                      } else {
                        lb_loop++;
                      }
                    }
                  }
                  break;

                 case 3:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[0] = 1;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      pixelSub[0] = i1;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i = 1;
                      pixelSub[1] = 1;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      pixelSub[1] = z;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 case 4:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }

                  i1 = ImageSize[0];
                  z = ImageSize[1];
                  for (ub_loop = 0; ub_loop < 9; ub_loop++) {
                    i = imnhSubs[ub_loop];
                    pixelSub[0] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[0] << 1;
                      pixelSub[0] = i;
                    }

                    if (i > i1) {
                      isInside[ub_loop] = false;
                      i = ((i1 << 1) - i) + 1;
                      pixelSub[0] = i;
                    }

                    i = imnhSubs[ub_loop + 9];
                    pixelSub[1] = i;
                    if (i < 1) {
                      isInside[ub_loop] = false;
                      i += ImageSize[1] << 1;
                      pixelSub[1] = i;
                    }

                    if (i > z) {
                      isInside[ub_loop] = false;
                      i = ((z << 1) - i) + 1;
                      pixelSub[1] = i;
                    }

                    if (!isInside[ub_loop]) {
                      imnhInds_data[ub_loop] = pixelSub[0] + (pixelSub[1] - 1) *
                        i1;
                    }
                  }
                  break;

                 default:
                  trueCount = 9;
                  for (i1 = 0; i1 < 9; i1++) {
                    imnhInds_data[i1] = imageNeighborLinearOffsets[i1];
                  }
                  break;
                }

                if (in.size(0) == 1) {
                  i = in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, cg_emlrtBCI);
                    }
                  }

                  firstIndRange[0] = 1;
                  firstIndRange[1] = trueCount;
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, firstIndRange);
                  ub_loop = 1;
                  y = trueCount;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                } else {
                  iv1[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[0];
                  iv1[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&in)
                            ->size())[1];
                  ::coder::internal::indexShapeCheck(iv1, trueCount);
                  i = in.size(0) * in.size(1);
                  for (i1 = 0; i1 < trueCount; i1++) {
                    z = imnhInds_data[i1];
                    if ((z < 1) || (z > i)) {
                      rtDynamicBoundsError(z, 1, i, hg_emlrtBCI);
                    }
                  }

                  ub_loop = trueCount;
                  y = 1;
                  for (i1 = 0; i1 < trueCount; i1++) {
                    b_imnh_data[i1] = in[imnhInds_data[i1] - 1];
                  }
                }

                if (Padding == 2.0) {
                  for (i = 0; i < 9; i++) {
                    if (!isInside[i]) {
                      i1 = ub_loop * y - 1;
                      if (i > i1) {
                        rtDynamicBoundsError(i, 0, i1, dg_emlrtBCI);
                      }

                      b_imnh_data[i] = padValue_tmp;
                    }
                  }
                }

                i1 = in.size(0) * in.size(1);
                if ((b_pind < 1) || (b_pind > i1)) {
                  rtDynamicBoundsError(b_pind, 1, i1, eg_emlrtBCI);
                }

                fparamsAugmented_pixel = in[b_pind - 1];
                i = out.size(0) * out.size(1);
                i1 = fparams.bw.size(0) * fparams.bw.size(1);
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, sf_emlrtBCI);
                }

                if (b_pind > i) {
                  rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                }

                b_b = fparams.bw[b_pind - 1];
                out[b_pind - 1] = b_b;
                if (b_pind > i1) {
                  rtDynamicBoundsError(b_pind, 1, i1, uf_emlrtBCI);
                }

                if (b_b) {
                  //  Pixel has not already been set as non-max
                  lb_loop = 1;
                  do {
                    exitg1 = 0;
                    z = ub_loop * y;
                    if (lb_loop - 1 <= z - 1) {
                      if (lb_loop > z) {
                        rtDynamicBoundsError(lb_loop, 1, z, vf_emlrtBCI);
                      }

                      f1 = b_imnh_data[lb_loop - 1];
                      if (f1 > fparamsAugmented_pixel) {
                        //  Set pixel to zero if any neighbor is greater
                        if (b_pind > i) {
                          rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                        }

                        out[b_pind - 1] = false;
                        exitg1 = 1;
                      } else {
                        if (lb_loop > z) {
                          rtDynamicBoundsError(lb_loop, 1, z, wf_emlrtBCI);
                        }

                        if (f1 == fparamsAugmented_pixel) {
                          if (lb_loop > trueCount) {
                            rtDynamicBoundsError(lb_loop, 1, trueCount,
                                                 gg_emlrtBCI);
                          }

                          z = imnhInds_data[lb_loop - 1];
                          if ((z < 1) || (z > i1)) {
                            rtDynamicBoundsError(z, 1, i1, yf_emlrtBCI);
                          }

                          if (!fparams.bw[z - 1]) {
                            //  Set pixel to zero if any equal neighbor is already set to zero
                            if (b_pind > i) {
                              rtDynamicBoundsError(b_pind, 1, i, fg_emlrtBCI);
                            }

                            out[b_pind - 1] = false;
                            exitg1 = 1;
                          } else {
                            lb_loop++;
                          }
                        } else {
                          lb_loop++;
                        }
                      }
                    } else {
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }
              }
            }
          }
        }

        //
        // Arguments    : const ::coder::array<bool, 2U> &arr
        //                ::coder::array<double, 2U> &matchedIdx
        // Return Type  : void
        //
      }
    }
  }

  namespace vision
  {
    namespace internal
    {
      namespace calibration
      {
        namespace checkerboard
        {
          void Checkerboard::arrayFind(const ::coder::array<bool, 2U> &arr, ::
            coder::array<double, 2U> &matchedIdx)
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              842,                     // lineNo
              26,                      // colNo
              "",                      // aName
              "Checkerboard/arrayFind",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              842,                     // lineNo
              45,                      // colNo
              "",                      // aName
              "Checkerboard/arrayFind",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              842,                     // lineNo
              41,                      // colNo
              "",                      // aName
              "Checkerboard/arrayFind",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 840,// lineNo
              33,                      // colNo
              "Checkerboard/arrayFind",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              4                        // checkKind
            };

            array<int, 2U> b_ii;
            array<signed char, 2U> matchArr;
            array<bool, 2U> x;
            int idx;
            int ii;
            int nx;
            bool exitg1;
            matchArr.set_size(1, matchArr.size(1));
            if (arr.size(1) - 2 < 0) {
              rtNonNegativeError(static_cast<double>(arr.size(1) - 2),
                                 g_emlrtDCI);
            }

            matchArr.set_size(matchArr.size(0), arr.size(1) - 2);
            ii = arr.size(1);
            for (idx = 0; idx <= ii - 3; idx++) {
              bool b_x[3];
              bool y;
              if (idx + 1 > arr.size(1)) {
                rtDynamicBoundsError(idx + 1, 1, arr.size(1), sf_emlrtBCI);
              }

              if (idx + 3 > arr.size(1)) {
                rtDynamicBoundsError(idx + 3, 1, arr.size(1), rf_emlrtBCI);
              }

              for (nx = 0; nx < 3; nx++) {
                b_x[nx] = arr[idx + nx];
              }

              y = true;
              nx = 0;
              exitg1 = false;
              while ((!exitg1) && (nx < 3)) {
                if (!b_x[nx]) {
                  y = false;
                  exitg1 = true;
                } else {
                  nx++;
                }
              }

              if (idx + 1 > matchArr.size(1)) {
                rtDynamicBoundsError(idx + 1, 1, matchArr.size(1), qf_emlrtBCI);
              }

              matchArr[idx] = static_cast<signed char>(y);
            }

            x.set_size(1, matchArr.size(1));
            nx = matchArr.size(1);
            for (ii = 0; ii < nx; ii++) {
              x[ii] = (matchArr[ii] == 1);
            }

            nx = x.size(1);
            idx = 0;
            b_ii.set_size(1, x.size(1));
            ii = 0;
            exitg1 = false;
            while ((!exitg1) && (ii <= nx - 1)) {
              if (x[ii]) {
                idx++;
                b_ii[idx - 1] = ii + 1;
                if (idx >= nx) {
                  exitg1 = true;
                } else {
                  ii++;
                }
              } else {
                ii++;
              }
            }

            if (idx > x.size(1)) {
              c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
            }

            if (x.size(1) == 1) {
              if (idx == 0) {
                b_ii.set_size(1, 0);
              }
            } else {
              if (idx < 1) {
                idx = 0;
              }

              b_ii.set_size(b_ii.size(0), idx);
            }

            matchedIdx.set_size(1, b_ii.size(1));
            nx = b_ii.size(1);
            for (ii = 0; ii < nx; ii++) {
              matchedIdx[ii] = b_ii[ii];
            }
          }

          //
          // Arguments    : void
          // Return Type  : bool
          //
          bool Checkerboard::b_expandBoardOnce()
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              416,                     // lineNo
              17,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              415,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              415,                     // lineNo
              36,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              402,                     // lineNo
              17,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              401,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              401,                     // lineNo
              36,                      // colNo
              "",                      // aName
              "Checkerboard/predictPointsVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ 1,// nDims
              415,                     // lineNo
              30,                      // colNo
              "Checkerboard/predictPointsHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ 1,// nDims
              401,                     // lineNo
              30,                      // colNo
              "Checkerboard/predictPointsVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 3U> b_this;
            array<double, 3U> c_this;
            array<double, 3U> r;
            array<double, 2U> d_this;
            array<double, 2U> e_this;
            array<double, 2U> idx;
            array<double, 2U> newIndices;
            array<double, 2U> p1;
            array<double, 2U> p2;
            array<double, 2U> predictedPoints;
            array<double, 2U> removedIdx;
            array<double, 2U> validIdx;
            array<int, 2U> ii;
            array<int, 1U> r10;
            array<int, 1U> r5;
            array<int, 1U> r6;
            array<int, 1U> r9;
            array<bool, 1U> r1;
            array<bool, 1U> r2;
            array<bool, 1U> r3;
            array<bool, 1U> r4;
            array<bool, 1U> r7;
            array<bool, 1U> r8;
            double currCurve_data[5];
            double currCoord;
            double moveDistMultiplier;
            int i;
            bool success;
            PreviousEnergy = Energy;
            i = 0;
            int exitg1;
            do {
              exitg1 = 0;
              if (i < 4) {
                if (!IsDirectionBad[i]) {
                  float oldEnergy;
                  LastExpandDirection = static_cast<double>(i) + 1.0;
                  oldEnergy = (Energy + static_cast<float>(BoardIdx.size(0) *
                    BoardIdx.size(1))) / static_cast<float>(BoardIdx.size(0) *
                    BoardIdx.size(1));
                  switch (i + 1) {
                   case 1:
                    {
                      int b_i;
                      int loop_ub;
                      if (IsDistortionHigh) {
                        c_fitPolynomialIndices(newIndices);
                        all(newIndices);
                      } else {
                        int b_loop_ub;
                        int numCols;
                        b_i = BoardCoords.size(0);
                        if (b_i < 2) {
                          rtDynamicBoundsError(2, 1, b_i, t_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [(BoardCoords.size(0) * i1 + BoardCoords.size(0) *
                                BoardCoords.size(1) * b_i) + 1];
                          }
                        }

                        squeeze(b_this, p1);
                        b_i = BoardCoords.size(0);
                        if (b_i < 1) {
                          rtDynamicBoundsError(1, 1, b_i, u_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] =
                              BoardCoords[BoardCoords.size(0) * i1 +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        squeeze(b_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            t_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            u_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          predictedPoints.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            predictedPoints[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }
                        } else {
                          binary_expand_op(predictedPoints, p2, p1);
                        }

                        if (p1.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p1.size(1), vf_emlrtBCI);
                        }

                        r1.set_size(p1.size(0));
                        loop_ub = p1.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r1[b_i] = (p1[b_i] == 0.0);
                        }

                        if (p2.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p2.size(1), uf_emlrtBCI);
                        }

                        r2.set_size(p2.size(0));
                        loop_ub = p2.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r2[b_i] = (p2[b_i] == 0.0);
                        }

                        if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) &&
                             (r2.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0),
                            mb_emlrtECI);
                        }

                        if (r1.size(0) == r2.size(0)) {
                          r3.set_size(r1.size(0));
                          loop_ub = r1.size(0);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            r3[b_i] = (r1[b_i] || r2[b_i]);
                          }
                        } else {
                          b_or(r3, r1, r2);
                        }

                        b_loop_ub = r3.size(0) - 1;
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r3[c_i]) {
                            numCols++;
                          }
                        }

                        r5.set_size(numCols);
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r3[c_i]) {
                            r5[numCols] = c_i;
                            numCols++;
                          }
                        }

                        loop_ub = predictedPoints.size(1);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = r5.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            if ((r5[i1] < 0) || (r5[i1] > predictedPoints.size(0)
                                                 - 1)) {
                              rtDynamicBoundsError(r5[i1], 0,
                                                   predictedPoints.size(0) - 1,
                                                   tf_emlrtBCI);
                            }

                            predictedPoints[r5[i1] + predictedPoints.size(0) *
                              b_i] = rtNaN;
                          }
                        }

                        b_findClosestIndices(predictedPoints, newIndices);
                      }

                      expandBoardUp(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      oldEnergy = computeNewEnergyVertical(oldEnergy);
                    }
                    break;

                   case 2:
                    {
                      int b_i;
                      int loop_ub;
                      int numCols;
                      numCols = BoardCoords.size(0);
                      if (numCols < numCols - 2) {
                        idx.set_size(1, 0);
                      } else {
                        idx.set_size(1, 3);
                        for (b_i = 0; b_i < 3; b_i++) {
                          idx[b_i] = numCols - b_i;
                        }
                      }

                      if (IsDistortionHigh) {
                        b_fitPolynomialIndices(idx, newIndices);
                        all(newIndices);
                      } else {
                        int b_loop_ub;
                        if (idx.size(1) < 2) {
                          rtDynamicBoundsError(2, 1, idx.size(1), cb_emlrtBCI);
                        }

                        if (idx[1] != idx[1]) {
                          rtIntegerError(idx[1], d_emlrtDCI);
                        }

                        b_i = BoardCoords.size(0);
                        numCols = static_cast<int>(idx[1]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, t_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [((numCols + BoardCoords.size(0) * i1) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i)
                              - 1];
                          }
                        }

                        squeeze(b_this, p1);
                        if (idx.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, idx.size(1), db_emlrtBCI);
                        }

                        if (idx[0] != idx[0]) {
                          rtIntegerError(idx[0], e_emlrtDCI);
                        }

                        b_i = BoardCoords.size(0);
                        numCols = static_cast<int>(idx[0]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, u_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [((numCols + BoardCoords.size(0) * i1) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i)
                              - 1];
                          }
                        }

                        squeeze(b_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            t_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            u_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          predictedPoints.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            predictedPoints[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }
                        } else {
                          binary_expand_op(predictedPoints, p2, p1);
                        }

                        if (p1.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p1.size(1), vf_emlrtBCI);
                        }

                        r1.set_size(p1.size(0));
                        loop_ub = p1.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r1[b_i] = (p1[b_i] == 0.0);
                        }

                        if (p2.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p2.size(1), uf_emlrtBCI);
                        }

                        r2.set_size(p2.size(0));
                        loop_ub = p2.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r2[b_i] = (p2[b_i] == 0.0);
                        }

                        if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) &&
                             (r2.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0),
                            mb_emlrtECI);
                        }

                        if (r1.size(0) == r2.size(0)) {
                          r8.set_size(r1.size(0));
                          loop_ub = r1.size(0);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            r8[b_i] = (r1[b_i] || r2[b_i]);
                          }
                        } else {
                          b_or(r8, r1, r2);
                        }

                        b_loop_ub = r8.size(0) - 1;
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r8[c_i]) {
                            numCols++;
                          }
                        }

                        r10.set_size(numCols);
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r8[c_i]) {
                            r10[numCols] = c_i;
                            numCols++;
                          }
                        }

                        loop_ub = predictedPoints.size(1);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = r10.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            if ((r10[i1] < 0) || (r10[i1] > predictedPoints.size
                                                  (0) - 1)) {
                              rtDynamicBoundsError(r10[i1], 0,
                                                   predictedPoints.size(0) - 1,
                                                   tf_emlrtBCI);
                            }

                            predictedPoints[r10[i1] + predictedPoints.size(0) *
                              b_i] = rtNaN;
                          }
                        }

                        b_findClosestIndices(predictedPoints, newIndices);
                      }

                      expandBoardDown(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      idx.set_size(1, idx.size(1));
                      loop_ub = idx.size(1) - 1;
                      for (b_i = 0; b_i <= loop_ub; b_i++) {
                        idx[b_i] = idx[b_i] + 1.0;
                      }

                      oldEnergy = computeNewEnergyVertical(idx, oldEnergy);
                    }
                    break;

                   case 3:
                    {
                      int b_i;
                      int loop_ub;
                      if (IsDistortionHigh) {
                        d_fitPolynomialIndices(newIndices);
                        all(newIndices);
                      } else {
                        int b_loop_ub;
                        int numCols;
                        b_i = BoardCoords.size(1);
                        if (b_i < 2) {
                          rtDynamicBoundsError(2, 1, b_i, v_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0)) + BoardCoords.size(0) *
                              BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p1);
                        b_i = BoardCoords.size(1);
                        if (b_i < 1) {
                          rtDynamicBoundsError(1, 1, b_i, w_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[i1 +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            v_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            w_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          predictedPoints.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            predictedPoints[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }
                        } else {
                          binary_expand_op(predictedPoints, p2, p1);
                        }

                        if (p1.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p1.size(1), sf_emlrtBCI);
                        }

                        r1.set_size(p1.size(0));
                        loop_ub = p1.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r1[b_i] = (p1[b_i] == 0.0);
                        }

                        if (p2.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p2.size(1), rf_emlrtBCI);
                        }

                        r2.set_size(p2.size(0));
                        loop_ub = p2.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r2[b_i] = (p2[b_i] == 0.0);
                        }

                        if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) &&
                             (r2.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0),
                            lb_emlrtECI);
                        }

                        if (r1.size(0) == r2.size(0)) {
                          r4.set_size(r1.size(0));
                          loop_ub = r1.size(0);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            r4[b_i] = (r1[b_i] || r2[b_i]);
                          }
                        } else {
                          b_or(r4, r1, r2);
                        }

                        b_loop_ub = r4.size(0) - 1;
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r4[c_i]) {
                            numCols++;
                          }
                        }

                        r6.set_size(numCols);
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r4[c_i]) {
                            r6[numCols] = c_i;
                            numCols++;
                          }
                        }

                        loop_ub = predictedPoints.size(1);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = r6.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            if ((r6[i1] < 0) || (r6[i1] > predictedPoints.size(0)
                                                 - 1)) {
                              rtDynamicBoundsError(r6[i1], 0,
                                                   predictedPoints.size(0) - 1,
                                                   qf_emlrtBCI);
                            }

                            predictedPoints[r6[i1] + predictedPoints.size(0) *
                              b_i] = rtNaN;
                          }
                        }

                        b_findClosestIndices(predictedPoints, newIndices);
                      }

                      expandBoardLeft(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      oldEnergy = computeNewEnergyHorizontal(oldEnergy);
                    }
                    break;

                   default:
                    {
                      int b_i;
                      int loop_ub;
                      int numCols;
                      numCols = BoardCoords.size(1);
                      if (numCols < numCols - 2) {
                        idx.set_size(1, 0);
                      } else {
                        idx.set_size(1, 3);
                        for (b_i = 0; b_i < 3; b_i++) {
                          idx[b_i] = numCols - b_i;
                        }
                      }

                      if (IsDistortionHigh) {
                        double coordsToUse[2];
                        int c_i;
                        b_findIndependentVar(idx, coordsToUse);
                        newIndices.set_size(1, BoardCoords.size(0));
                        loop_ub = BoardCoords.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          newIndices[b_i] = 0.0;
                        }

                        removedIdx.set_size(1, 0);
                        b_i = BoardCoords.size(0);
                        for (int j{0}; j < b_i; j++) {
                          double refCoordValue;
                          int i1;
                          i1 = BoardCoords.size(0);
                          if (j + 1 > i1) {
                            rtDynamicBoundsError(j + 1, 1, i1, ab_emlrtBCI);
                          }

                          i1 = BoardCoords.size(2);
                          refCoordValue = coordsToUse[0];
                          if ((static_cast<int>(coordsToUse[0]) < 1) || (
                               static_cast<int>(coordsToUse[0]) > i1)) {
                            rtDynamicBoundsError(static_cast<int>(coordsToUse[0]),
                                                 1, i1, bb_emlrtBCI);
                          }

                          d_this.set_size(1, BoardCoords.size(1));
                          loop_ub = BoardCoords.size(1);
                          for (i1 = 0; i1 < loop_ub; i1++) {
                            d_this[i1] = BoardCoords[(j + BoardCoords.size(0) *
                              i1) + BoardCoords.size(0) * BoardCoords.size(1) *
                              (static_cast<int>(refCoordValue) - 1)];
                          }

                          eml_find(d_this, ii);
                          validIdx.set_size(1, ii.size(1));
                          loop_ub = ii.size(1);
                          for (i1 = 0; i1 < loop_ub; i1++) {
                            validIdx[i1] = ii[i1];
                          }

                          if (validIdx.size(1) >= 2) {
                            double coordDist;
                            double currRad;
                            int currCurve_size[2];
                            int b_loop_ub;
                            int i2;
                            bool exitg2;
                            coordDist = findSearchParams(idx, validIdx,
                              static_cast<double>(j) + 1.0, coordsToUse,
                              moveDistMultiplier, currCoord);
                            c_i = 0;
                            i1 = validIdx.size(1);
                            for (numCols = 0; numCols < i1; numCols++) {
                              if (static_cast<int>(validIdx[numCols]) != 0) {
                                c_i++;
                              }
                            }

                            numCols = BoardCoords.size(1);
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, eb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            if ((static_cast<int>(coordsToUse[0]) < 1) || (
                                 static_cast<int>(coordsToUse[0]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [0]), 1, i1, fb_emlrtBCI);
                            }

                            b_loop_ub = BoardCoords.size(1);
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, gb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            refCoordValue = coordsToUse[1];
                            if ((static_cast<int>(coordsToUse[1]) < 1) || (
                                 static_cast<int>(coordsToUse[1]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [1]), 1, i1, hb_emlrtBCI);
                            }

                            d_this.set_size(1, validIdx.size(1));
                            loop_ub = validIdx.size(1);
                            for (i1 = 0; i1 < loop_ub; i1++) {
                              i2 = static_cast<int>(validIdx[i1]);
                              if ((i2 < 1) || (i2 > numCols)) {
                                rtDynamicBoundsError(i2, 1, numCols, ib_emlrtBCI);
                              }

                              d_this[i1] = BoardCoords[(j + BoardCoords.size(0) *
                                (i2 - 1)) + BoardCoords.size(0) *
                                BoardCoords.size(1) * (static_cast<int>
                                (coordsToUse[0]) - 1)];
                            }

                            e_this.set_size(1, validIdx.size(1));
                            loop_ub = validIdx.size(1);
                            for (i1 = 0; i1 < loop_ub; i1++) {
                              i2 = static_cast<int>(validIdx[i1]);
                              if ((i2 < 1) || (i2 > b_loop_ub)) {
                                rtDynamicBoundsError(i2, 1, b_loop_ub,
                                                     jb_emlrtBCI);
                              }

                              e_this[i1] = BoardCoords[(j + BoardCoords.size(0) *
                                (i2 - 1)) + BoardCoords.size(0) *
                                BoardCoords.size(1) * (static_cast<int>
                                (refCoordValue) - 1)];
                            }

                            if (c_i > 5) {
                              i1 = 4;
                            } else {
                              i1 = 2;
                            }

                            polyfit(d_this, e_this, static_cast<double>(i1),
                                    currCurve_data, currCurve_size);
                            currRad = coordDist / 4.0;
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, kb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(1);
                            if ((static_cast<int>(currCoord) < 1) || (
                                 static_cast<int>(currCoord) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(currCoord),
                                                   1, i1, lb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            if ((static_cast<int>(coordsToUse[0]) < 1) || (
                                 static_cast<int>(coordsToUse[0]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [0]), 1, i1, mb_emlrtBCI);
                            }

                            refCoordValue = BoardCoords[(j + BoardCoords.size(0)
                              * (static_cast<int>(currCoord) - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * (
                              static_cast<int>(coordsToUse[0]) - 1)];
                            currCoord = currRad + refCoordValue;
                            exitg2 = false;
                            while ((!exitg2) && (std::abs(currCoord -
                                     refCoordValue) < moveDistMultiplier * 1.5 *
                                                 std::abs(coordDist))) {
                              double currPt[2];
                              bool exitg3;
                              bool p;
                              p = true;
                              numCols = 0;
                              exitg3 = false;
                              while ((!exitg3) && (numCols < 2)) {
                                if (!(coordsToUse[numCols] == static_cast<double>
                                      (numCols) + 1.0)) {
                                  p = false;
                                  exitg3 = true;
                                } else {
                                  numCols++;
                                }
                              }

                              if (p) {
                                double y;
                                y = currCurve_data[0];
                                i1 = currCurve_size[1];
                                for (numCols = 0; numCols <= i1 - 2; numCols++)
                                {
                                  y = currCoord * y + currCurve_data[numCols + 1];
                                }

                                currPt[0] = currCoord;
                                currPt[1] = y;
                              } else {
                                double y;
                                y = currCurve_data[0];
                                i1 = currCurve_size[1];
                                for (numCols = 0; numCols <= i1 - 2; numCols++)
                                {
                                  y = currCoord * y + currCurve_data[numCols + 1];
                                }

                                currPt[0] = y;
                                currPt[1] = currCoord;
                              }

                              findClosestOnCurve(currPt, std::abs(currRad),
                                                 currCurve_data, currCurve_size,
                                                 coordsToUse, removedIdx,
                                                 validIdx);
                              if (validIdx.size(1) != 0) {
                                if (validIdx.size(1) != 1) {
                                  rtSizeEq1DError(1, validIdx.size(1),
                                                  x_emlrtECI);
                                }

                                if (j + 1 > newIndices.size(1)) {
                                  rtDynamicBoundsError(j + 1, 1, newIndices.size
                                                       (1), nb_emlrtBCI);
                                }

                                newIndices[j] = validIdx[0];
                                i1 = removedIdx.size(1);
                                loop_ub = validIdx.size(1);
                                removedIdx.set_size(removedIdx.size(0),
                                                    removedIdx.size(1) +
                                                    validIdx.size(1));
                                for (i2 = 0; i2 < loop_ub; i2++) {
                                  removedIdx[i1 + i2] = validIdx[i2];
                                }

                                exitg2 = true;
                              } else {
                                currCoord += currRad;
                              }
                            }
                          }
                        }

                        c_i = 0;
                        b_i = newIndices.size(1);
                        for (numCols = 0; numCols < b_i; numCols++) {
                          if (newIndices[numCols] != 0.0) {
                            c_i++;
                          }
                        }

                        if (c_i < 4) {
                          numCols = newIndices.size(1) - 1;
                          for (c_i = 0; c_i <= numCols; c_i++) {
                            if (newIndices[c_i] > 0.0) {
                              if (c_i > numCols) {
                                rtDynamicBoundsError(c_i, 0, numCols,
                                                     lf_emlrtBCI);
                              }

                              newIndices[c_i] = 0.0;
                            }
                          }
                        }

                        all(newIndices);
                      } else {
                        int b_loop_ub;
                        if (idx.size(1) < 2) {
                          rtDynamicBoundsError(2, 1, idx.size(1), x_emlrtBCI);
                        }

                        if (idx[1] != idx[1]) {
                          rtIntegerError(idx[1], b_emlrtDCI);
                        }

                        b_i = BoardCoords.size(1);
                        numCols = static_cast<int>(idx[1]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, v_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0) * (numCols - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p1);
                        if (idx.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, idx.size(1), y_emlrtBCI);
                        }

                        if (idx[0] != idx[0]) {
                          rtIntegerError(idx[0], c_emlrtDCI);
                        }

                        b_i = BoardCoords.size(1);
                        numCols = static_cast<int>(idx[0]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, w_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0) * (numCols - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            v_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            w_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          predictedPoints.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            predictedPoints[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }
                        } else {
                          binary_expand_op(predictedPoints, p2, p1);
                        }

                        if (p1.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p1.size(1), sf_emlrtBCI);
                        }

                        r1.set_size(p1.size(0));
                        loop_ub = p1.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r1[b_i] = (p1[b_i] == 0.0);
                        }

                        if (p2.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, p2.size(1), rf_emlrtBCI);
                        }

                        r2.set_size(p2.size(0));
                        loop_ub = p2.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          r2[b_i] = (p2[b_i] == 0.0);
                        }

                        if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) &&
                             (r2.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0),
                            lb_emlrtECI);
                        }

                        if (r1.size(0) == r2.size(0)) {
                          r7.set_size(r1.size(0));
                          loop_ub = r1.size(0);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            r7[b_i] = (r1[b_i] || r2[b_i]);
                          }
                        } else {
                          b_or(r7, r1, r2);
                        }

                        b_loop_ub = r7.size(0) - 1;
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r7[c_i]) {
                            numCols++;
                          }
                        }

                        r9.set_size(numCols);
                        numCols = 0;
                        for (int c_i{0}; c_i <= b_loop_ub; c_i++) {
                          if (r7[c_i]) {
                            r9[numCols] = c_i;
                            numCols++;
                          }
                        }

                        loop_ub = predictedPoints.size(1);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = r9.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            if ((r9[i1] < 0) || (r9[i1] > predictedPoints.size(0)
                                                 - 1)) {
                              rtDynamicBoundsError(r9[i1], 0,
                                                   predictedPoints.size(0) - 1,
                                                   qf_emlrtBCI);
                            }

                            predictedPoints[r9[i1] + predictedPoints.size(0) *
                              b_i] = rtNaN;
                          }
                        }

                        b_findClosestIndices(predictedPoints, newIndices);
                      }

                      expandBoardRight(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      idx.set_size(1, idx.size(1));
                      loop_ub = idx.size(1) - 1;
                      for (b_i = 0; b_i <= loop_ub; b_i++) {
                        idx[b_i] = idx[b_i] + 1.0;
                      }

                      oldEnergy = computeNewEnergyHorizontal(idx, oldEnergy);
                    }
                    break;
                  }

                  Energy = oldEnergy;
                  if (Energy < PreviousEnergy) {
                    success = true;
                    exitg1 = 1;
                  } else {
                    undoLastExpansion();
                    IsDirectionBad[i] = true;
                    i++;
                  }
                } else {
                  i++;
                }
              } else {
                success = false;
                exitg1 = 1;
              }
            } while (exitg1 == 0);

            return success;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &predictedPoints
          //                ::coder::array<double, 2U> &indices
          // Return Type  : void
          //
          void Checkerboard::b_findClosestIndices(const ::coder::array<double,
            2U> &predictedPoints, ::coder::array<double, 2U> &indices) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              633,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              625,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              625,                     // lineNo
              63,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              619,                     // lineNo
              57,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              619,                     // lineNo
              44,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              618,                     // lineNo
              56,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 618,// lineNo
              56,                      // colNo
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 15,// lineNo
              58,                      // colNo
              "nonzeros",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/sparfun/nonzeros.m",// pName
              4                        // checkKind
            };

            static rtRunTimeErrorInfo s_emlrtRTEI{ 20,// lineNo
              9,                       // colNo
              "nonzeros",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/sparfun/nonzeros.m"// pName
            };

            static rtRunTimeErrorInfo t_emlrtRTEI{ 14,// lineNo
              1,                       // colNo
              "nonzeros",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/sparfun/nonzeros.m"// pName
            };

            array<double, 2U> b_indices;
            array<double, 2U> p;
            array<double, 2U> remIdx;
            array<double, 1U> b_this;
            array<double, 1U> validBoardIdx;
            array<float, 2U> diffs;
            array<float, 2U> e_this;
            array<float, 1U> b_diffs;
            array<float, 1U> c_diffs;
            array<float, 1U> dists;
            array<int, 2U> r1;
            array<int, 1U> ii;
            array<bool, 2U> distIdx;
            array<bool, 1U> r;
            int b;
            int b_loop_ub;
            int c_loop_ub;
            int c_this;
            int d_loop_ub;
            int d_this;
            int i;
            int iindx;
            int loop_ub;
            int n;
            int this_tmp;
            bool overflow;
            indices.set_size(1, predictedPoints.size(0));
            loop_ub = predictedPoints.size(0);
            for (i = 0; i < loop_ub; i++) {
              indices[i] = 0.0;
            }

            b = Points.size(0);
            if (b < 1) {
              p.set_size(1, 0);
            } else {
              p.set_size(1, b);
              loop_ub = b - 1;
              for (i = 0; i <= loop_ub; i++) {
                p[i] = static_cast<double>(i) + 1.0;
              }
            }

            this_tmp = BoardIdx.size(0) * BoardIdx.size(1);
            b_this = BoardIdx.reshape(this_tmp);
            do_vectors(p, b_this, remIdx, ii);
            if (remIdx.size(1) != 0) {
              int end_tmp;
              if (predictedPoints.size(1) < 1) {
                rtDynamicBoundsError(1, 1, predictedPoints.size(1), rc_emlrtBCI);
              }

              r.set_size(predictedPoints.size(0));
              loop_ub = predictedPoints.size(0);
              for (i = 0; i < loop_ub; i++) {
                r[i] = !std::isnan(predictedPoints[i]);
              }

              c_eml_find(r, ii);
              i = ii.size(0);
              if (ii.size(0) - 1 >= 0) {
                b_loop_ub = predictedPoints.size(1);
                c_this = Points.size(0);
                c_loop_ub = Points.size(1);
                n = this_tmp;
                overflow = (this_tmp > 2147483646);
                d_this = Points.size(0);
                d_loop_ub = Points.size(1);
              }

              for (int b_i{0}; b_i < i; b_i++) {
                float minDist;
                float x;
                int c_i;
                int i1;
                bool b_b;
                if (b_i + 1 > ii.size(0)) {
                  rtDynamicBoundsError(b_i + 1, 1, ii.size(0), sc_emlrtBCI);
                }

                i1 = ii[b_i];
                b_b = ((i1 < 1) || (i1 > predictedPoints.size(0)));
                if (b_b) {
                  rtDynamicBoundsError(i1, 1, predictedPoints.size(0),
                                       qc_emlrtBCI);
                }

                p.set_size(1, predictedPoints.size(1));
                for (c_i = 0; c_i < b_loop_ub; c_i++) {
                  p[c_i] = predictedPoints[(ii[b_i] + predictedPoints.size(0) *
                    c_i) - 1];
                }

                e_this.set_size(remIdx.size(1), Points.size(1));
                for (c_i = 0; c_i < c_loop_ub; c_i++) {
                  loop_ub = remIdx.size(1);
                  for (end_tmp = 0; end_tmp < loop_ub; end_tmp++) {
                    if (remIdx[end_tmp] != static_cast<int>(std::floor
                         (remIdx[end_tmp]))) {
                      rtIntegerError(remIdx[end_tmp], f_emlrtDCI);
                    }

                    b = static_cast<int>(remIdx[end_tmp]);
                    if ((b < 1) || (b > c_this)) {
                      rtDynamicBoundsError(b, 1, c_this, tc_emlrtBCI);
                    }

                    e_this[end_tmp + e_this.size(0) * c_i] = Points[(b +
                      Points.size(0) * c_i) - 1];
                  }
                }

                bsxfun(e_this, p, diffs);
                if (diffs.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, diffs.size(1), pc_emlrtBCI);
                }

                if (diffs.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, diffs.size(1), oc_emlrtBCI);
                }

                b_diffs.set_size(diffs.size(0));
                loop_ub = diffs.size(0);
                c_diffs.set_size(diffs.size(0));
                for (c_i = 0; c_i < loop_ub; c_i++) {
                  b_diffs[c_i] = diffs[c_i];
                  c_diffs[c_i] = diffs[c_i + diffs.size(0)];
                }

                b_hypot(b_diffs, c_diffs, dists);
                end_tmp = indices.size(1) - 1;
                b = 0;
                for (c_i = 0; c_i <= end_tmp; c_i++) {
                  if (indices[c_i] > 0.0) {
                    b++;
                  }
                }

                r1.set_size(1, b);
                b = 0;
                for (c_i = 0; c_i <= end_tmp; c_i++) {
                  if (indices[c_i] > 0.0) {
                    r1[b] = c_i;
                    b++;
                  }
                }

                loop_ub = r1.size(1);
                for (c_i = 0; c_i < loop_ub; c_i++) {
                  if ((r1[c_i] < 0) || (r1[c_i] > end_tmp)) {
                    rtDynamicBoundsError(r1[c_i], 0, end_tmp, uc_emlrtBCI);
                  }
                }

                loop_ub = r1.size(1);
                b_indices.set_size(1, r1.size(1));
                for (c_i = 0; c_i < loop_ub; c_i++) {
                  b_indices[c_i] = indices[r1[c_i]];
                }

                isMember(remIdx, b_indices, distIdx);
                b = distIdx.size(1) - 1;
                for (c_i = 0; c_i <= b; c_i++) {
                  if (distIdx[c_i]) {
                    if (c_i > dists.size(0) - 1) {
                      rtDynamicBoundsError(c_i, 0, dists.size(0) - 1,
                                           vc_emlrtBCI);
                    }

                    dists[c_i] = rtInfF;
                  }
                }

                minDist = ::coder::internal::minimum(dists, iindx);
                b = 0;
                for (loop_ub = 0; loop_ub < n; loop_ub++) {
                  if (BoardIdx[loop_ub] != 0.0) {
                    b++;
                  }
                }

                if (b > this_tmp) {
                  c_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
                }

                if (b < 0) {
                  rtNonNegativeError(static_cast<double>(b), h_emlrtDCI);
                }

                validBoardIdx.set_size(b);
                c_i = 0;
                if (overflow) {
                  check_forloop_overflow_error();
                }

                for (loop_ub = 0; loop_ub < n; loop_ub++) {
                  if (BoardIdx[loop_ub] != 0.0) {
                    c_i++;
                    if (c_i > b) {
                      c_rtErrorWithMessageID(s_emlrtRTEI.fName,
                        s_emlrtRTEI.lineNo);
                    }

                    validBoardIdx[c_i - 1] = BoardIdx[loop_ub];
                  }
                }

                e_this.set_size(validBoardIdx.size(0), Points.size(1));
                for (c_i = 0; c_i < d_loop_ub; c_i++) {
                  loop_ub = validBoardIdx.size(0);
                  for (end_tmp = 0; end_tmp < loop_ub; end_tmp++) {
                    if (validBoardIdx[end_tmp] != static_cast<int>(std::floor
                         (validBoardIdx[end_tmp]))) {
                      rtIntegerError(validBoardIdx[end_tmp], g_emlrtDCI);
                    }

                    b = static_cast<int>(validBoardIdx[end_tmp]);
                    if ((b < 1) || (b > d_this)) {
                      rtDynamicBoundsError(b, 1, d_this, vf_emlrtBCI);
                    }

                    e_this[end_tmp + e_this.size(0) * c_i] = Points[(b +
                      Points.size(0) * c_i) - 1];
                  }
                }

                bsxfun(e_this, p, diffs);
                if (diffs.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, diffs.size(1), uf_emlrtBCI);
                }

                if (diffs.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, diffs.size(1), tf_emlrtBCI);
                }

                b_diffs.set_size(diffs.size(0));
                loop_ub = diffs.size(0);
                c_diffs.set_size(diffs.size(0));
                for (c_i = 0; c_i < loop_ub; c_i++) {
                  b_diffs[c_i] = diffs[c_i];
                  c_diffs[c_i] = diffs[c_i + diffs.size(0)];
                }

                b_hypot(b_diffs, c_diffs, dists);
                x = ::coder::internal::minimum(dists);
                if (minDist < x / 2.0F) {
                  if ((iindx < 1) || (iindx > remIdx.size(1))) {
                    rtDynamicBoundsError(iindx, 1, remIdx.size(1), sf_emlrtBCI);
                  }

                  if (b_i + 1 > ii.size(0)) {
                    rtDynamicBoundsError(b_i + 1, 1, ii.size(0), rf_emlrtBCI);
                  }

                  indices[i1 - 1] = remIdx[iindx - 1];
                }
              }

              n = 0;
              i = indices.size(1);
              for (loop_ub = 0; loop_ub < i; loop_ub++) {
                if (indices[loop_ub] != 0.0) {
                  n++;
                }
              }

              if (n < 4) {
                end_tmp = indices.size(1) - 1;
                for (int b_i{0}; b_i <= end_tmp; b_i++) {
                  if (indices[b_i] > 0.0) {
                    if (b_i > end_tmp) {
                      rtDynamicBoundsError(b_i, 0, end_tmp, qf_emlrtBCI);
                    }

                    indices[b_i] = 0.0;
                  }
                }
              }
            }
          }

          //
          // Arguments    : double coordsToUse[2]
          // Return Type  : void
          //
          void Checkerboard::b_findIndependentVar(double coordsToUse[2]) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              516,                     // lineNo
              69,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              516,                     // lineNo
              109,                     // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 1U> b_this;
            array<int, 1U> r2;
            array<bool, 1U> r;
            array<bool, 1U> r1;
            double b_x;
            double x;
            int end;
            int i;
            int loop_ub;
            i = BoardIdx.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, ae_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[i] > 0.0);
            }

            i = BoardIdx.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, be_emlrtBCI);
            }

            r1.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              r1[i] = (BoardIdx[i + BoardIdx.size(0)] > 0.0);
            }

            if (r.size(0) != r1.size(0)) {
              rtSizeEq1DError(r.size(0), r1.size(0), eb_emlrtECI);
            }

            i = BoardCoords.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ce_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, de_emlrtBCI);
            }

            end = r.size(0) - 1;
            loop_ub = 0;
            for (i = 0; i <= end; i++) {
              if (r[i] && r1[i]) {
                loop_ub++;
              }
            }

            r2.set_size(loop_ub);
            loop_ub = 0;
            for (i = 0; i <= end; i++) {
              if (r[i] && r1[i]) {
                r2[loop_ub] = i;
                loop_ub++;
              }
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, ie_emlrtBCI);
              }
            }

            i = BoardCoords.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, ee_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, fe_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, je_emlrtBCI);
              }
            }

            b_this.set_size(r2.size(0));
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_this[i] = BoardCoords[r2[i] + BoardCoords.size(0)] -
                BoardCoords[r2[i]];
            }

            x = mean(b_this);
            i = BoardCoords.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ge_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, ke_emlrtBCI);
              }
            }

            i = BoardCoords.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, he_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, le_emlrtBCI);
              }
            }

            b_this.set_size(r2.size(0));
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_this[i] = BoardCoords[(r2[i] + BoardCoords.size(0)) +
                BoardCoords.size(0) * BoardCoords.size(1)] - BoardCoords[r2[i] +
                BoardCoords.size(0) * BoardCoords.size(1)];
            }

            b_x = mean(b_this);
            if (std::abs(x) > std::abs(b_x)) {
              coordsToUse[0] = 1.0;
              coordsToUse[1] = 2.0;
            } else {
              coordsToUse[0] = 2.0;
              coordsToUse[1] = 1.0;
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                double coordsToUse[2]
          // Return Type  : void
          //
          void Checkerboard::b_findIndependentVar(const ::coder::array<double,
            2U> &idx, double coordsToUse[2]) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              515,                     // lineNo
              113,                     // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              515,                     // lineNo
              73,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              514,                     // lineNo
              80,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              516,                     // lineNo
              73,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              516,                     // lineNo
              113,                     // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              514,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 515,// lineNo
              69,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 515,// lineNo
              109,                     // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 516,// lineNo
              69,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 516,// lineNo
              109,                     // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo k_emlrtDCI{ 514,// lineNo
              46,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo l_emlrtDCI{ 514,// lineNo
              76,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            array<double, 1U> b_this;
            array<int, 1U> r2;
            array<bool, 1U> r;
            array<bool, 1U> r1;
            double b_x;
            double x;
            int b_i;
            int b_idx;
            int c_idx;
            int end;
            int i;
            int i1;
            int loop_ub;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), vf_emlrtBCI);
            }

            i = static_cast<int>(std::floor(idx[0]));
            if (idx[0] != i) {
              rtIntegerError(idx[0], k_emlrtDCI);
            }

            i1 = BoardIdx.size(1);
            b_idx = static_cast<int>(idx[0]);
            if ((b_idx < 1) || (b_idx > i1)) {
              rtDynamicBoundsError(b_idx, 1, i1, ae_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i1 = 0; i1 < loop_ub; i1++) {
              r[i1] = (BoardIdx[i1 + BoardIdx.size(0) * (b_idx - 1)] > 0.0);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), sf_emlrtBCI);
            }

            i1 = static_cast<int>(std::floor(idx[1]));
            if (idx[1] != i1) {
              rtIntegerError(idx[1], l_emlrtDCI);
            }

            b_i = BoardIdx.size(1);
            c_idx = static_cast<int>(idx[1]);
            if ((c_idx < 1) || (c_idx > b_i)) {
              rtDynamicBoundsError(c_idx, 1, b_i, be_emlrtBCI);
            }

            r1.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              r1[b_i] = (BoardIdx[b_i + BoardIdx.size(0) * (c_idx - 1)] > 0.0);
            }

            if (r.size(0) != r1.size(0)) {
              rtSizeEq1DError(r.size(0), r1.size(0), eb_emlrtECI);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), rf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 1) {
              rtDynamicBoundsError(1, 1, b_i, de_emlrtBCI);
            }

            end = r.size(0) - 1;
            loop_ub = 0;
            for (b_i = 0; b_i <= end; b_i++) {
              if (r[b_i] && r1[b_i]) {
                loop_ub++;
              }
            }

            r2.set_size(loop_ub);
            loop_ub = 0;
            for (b_i = 0; b_i <= end; b_i++) {
              if (r[b_i] && r1[b_i]) {
                r2[loop_ub] = b_i;
                loop_ub++;
              }
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              if (r2[b_i] > end - 1) {
                rtDynamicBoundsError(r2[b_i], 0, end - 1, ie_emlrtBCI);
              }
            }

            if (idx[1] != i1) {
              rtIntegerError(idx[1], g_emlrtDCI);
            }

            b_i = BoardCoords.size(1);
            if (c_idx > b_i) {
              rtDynamicBoundsError(c_idx, 1, b_i, ce_emlrtBCI);
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), qf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 1) {
              rtDynamicBoundsError(1, 1, b_i, fe_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              if (r2[b_i] > end - 1) {
                rtDynamicBoundsError(r2[b_i], 0, end - 1, je_emlrtBCI);
              }
            }

            if (idx[0] != i) {
              rtIntegerError(idx[0], h_emlrtDCI);
            }

            b_i = BoardCoords.size(1);
            if (b_idx > b_i) {
              rtDynamicBoundsError(b_idx, 1, b_i, ee_emlrtBCI);
            }

            b_this.set_size(r2.size(0));
            loop_ub = r2.size(0);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              b_this[b_i] = BoardCoords[r2[b_i] + BoardCoords.size(0) * (c_idx -
                1)] - BoardCoords[r2[b_i] + BoardCoords.size(0) * (b_idx - 1)];
            }

            x = mean(b_this);
            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), tf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 2) {
              rtDynamicBoundsError(2, 1, b_i, ge_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              if (r2[b_i] > end - 1) {
                rtDynamicBoundsError(r2[b_i], 0, end - 1, ke_emlrtBCI);
              }
            }

            if (idx[1] != i1) {
              rtIntegerError(idx[1], i_emlrtDCI);
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), uf_emlrtBCI);
            }

            i1 = BoardCoords.size(2);
            if (i1 < 2) {
              rtDynamicBoundsError(2, 1, i1, he_emlrtBCI);
            }

            end = BoardCoords.size(0);
            loop_ub = r2.size(0);
            for (i1 = 0; i1 < loop_ub; i1++) {
              if (r2[i1] > end - 1) {
                rtDynamicBoundsError(r2[i1], 0, end - 1, le_emlrtBCI);
              }
            }

            if (idx[0] != i) {
              rtIntegerError(idx[0], j_emlrtDCI);
            }

            b_this.set_size(r2.size(0));
            loop_ub = r2.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_this[i] = BoardCoords[(r2[i] + BoardCoords.size(0) * (c_idx - 1))
                + BoardCoords.size(0) * BoardCoords.size(1)] - BoardCoords[(r2[i]
                + BoardCoords.size(0) * (b_idx - 1)) + BoardCoords.size(0) *
                BoardCoords.size(1)];
            }

            b_x = mean(b_this);
            if (std::abs(x) > std::abs(b_x)) {
              coordsToUse[0] = 1.0;
              coordsToUse[1] = 2.0;
            } else {
              coordsToUse[0] = 2.0;
              coordsToUse[1] = 1.0;
            }
          }

          //
          // Arguments    : ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::b_fitPolynomialIndices(::coder::array<double, 2U>
            &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> c_this;
            array<double, 2U> removedIdx;
            array<int, 2U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            int i;
            int loop_ub;
            b_findIndependentVar(coordsToUse);
            newIndices.set_size(1, BoardCoords.size(0));
            loop_ub = BoardCoords.size(0);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(0);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(0);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ab_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     bb_emlrtBCI);
              }

              b_index.set_size(1, BoardCoords.size(1));
              loop_ub = BoardCoords.size(1);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_index[i1] = BoardCoords[(j + BoardCoords.size(0) * i1) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(b_index, ii);
              if (ii.size(1) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                double refCoordValue;
                int currCurve_size[2];
                int b_this;
                int coordDist_tmp;
                int k;
                int n;
                bool exitg1;
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, yd_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                k = ii[0];
                if ((k < 1) || (k > i1)) {
                  rtDynamicBoundsError(k, 1, i1, xd_emlrtBCI);
                }

                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, wd_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                k = ii[1];
                if ((k < 1) || (k > i1)) {
                  rtDynamicBoundsError(k, 1, i1, vd_emlrtBCI);
                }

                currRad = coordsToUse[0];
                coordDist_tmp = ii[0];
                coordDist = (BoardCoords[(j + BoardCoords.size(0) * (ii[0] - 1))
                             + BoardCoords.size(0) * BoardCoords.size(1) * (
                  static_cast<int>(coordsToUse[0]) - 1)] - BoardCoords[(j +
                  BoardCoords.size(0) * (ii[1] - 1)) + BoardCoords.size(0) *
                             BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)]) / (static_cast<double>(ii[1]) -
                  static_cast<double>(coordDist_tmp));
                n = 0;
                i1 = ii.size(1);
                for (k = 0; k < i1; k++) {
                  if (ii[k] != 0) {
                    n++;
                  }
                }

                k = BoardCoords.size(1);
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, eb_emlrtBCI);
                }

                b_this = BoardCoords.size(1);
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, gb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       hb_emlrtBCI);
                }

                b_index.set_size(1, ii.size(1));
                loop_ub = ii.size(1);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > k)) {
                    rtDynamicBoundsError(ii[i1], 1, k, ib_emlrtBCI);
                  }

                  b_index[i1] = BoardCoords[(j + BoardCoords.size(0) * (ii[i1] -
                    1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                    static_cast<int>(currRad) - 1)];
                }

                c_this.set_size(1, ii.size(1));
                loop_ub = ii.size(1);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > b_this)) {
                    rtDynamicBoundsError(ii[i1], 1, b_this, jb_emlrtBCI);
                  }

                  c_this[i1] = BoardCoords[(j + BoardCoords.size(0) * (ii[i1] -
                    1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                    static_cast<int>(coordsToUse[1]) - 1)];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(b_index, c_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, kb_emlrtBCI);
                }

                refCoordValue = BoardCoords[(j + BoardCoords.size(0) * (ii[0] -
                  1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                  static_cast<int>(coordsToUse[0]) - 1)];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     static_cast<double>(coordDist_tmp) * 1.5 *
                                     std::abs(coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  bool p;
                  p = true;
                  k = 0;
                  exitg2 = false;
                  while ((!exitg2) && (k < 2)) {
                    if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      k++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (k = 0; k < loop_ub; k++) {
                      removedIdx[i1 + k] = b_index[k];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::b_fitPolynomialIndices(const ::coder::array<double,
            2U> &idx, ::coder::array<double, 2U> &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> removedIdx;
            array<double, 1U> b_this;
            array<double, 1U> d_this;
            array<double, 1U> validIdx;
            array<int, 1U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            double moveDistMultiplier;
            double refCoordValue;
            int i;
            int k;
            int loop_ub;
            int n;
            findIndependentVar(idx, coordsToUse);
            newIndices.set_size(1, BoardCoords.size(1));
            loop_ub = BoardCoords.size(1);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(1);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(1);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ob_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     pb_emlrtBCI);
              }

              b_this.set_size(BoardCoords.size(0));
              loop_ub = BoardCoords.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_this[i1] = BoardCoords[(i1 + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(b_this, ii);
              validIdx.set_size(ii.size(0));
              loop_ub = ii.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                validIdx[i1] = ii[i1];
              }

              if (validIdx.size(0) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                int currCurve_size[2];
                int c_this;
                int i2;
                bool exitg1;
                coordDist = findSearchParams(idx, validIdx, static_cast<double>
                  (j) + 1.0, coordsToUse, moveDistMultiplier, refCoordValue);
                n = 0;
                i1 = validIdx.size(0);
                for (k = 0; k < i1; k++) {
                  if (validIdx[k] != 0.0) {
                    n++;
                  }
                }

                k = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, ub_emlrtBCI);
                }

                c_this = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, vb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       wb_emlrtBCI);
                }

                b_this.set_size(validIdx.size(0));
                loop_ub = validIdx.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  i2 = static_cast<int>(validIdx[i1]);
                  if ((i2 < 1) || (i2 > k)) {
                    rtDynamicBoundsError(i2, 1, k, xb_emlrtBCI);
                  }

                  b_this[i1] = BoardCoords[((i2 + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[0]) - 1)) - 1];
                }

                d_this.set_size(validIdx.size(0));
                loop_ub = validIdx.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  i2 = static_cast<int>(validIdx[i1]);
                  if ((i2 < 1) || (i2 > c_this)) {
                    rtDynamicBoundsError(i2, 1, c_this, yb_emlrtBCI);
                  }

                  d_this[i1] = BoardCoords[((i2 + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[1]) - 1)) - 1];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(b_this, d_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(0);
                if ((static_cast<int>(refCoordValue) < 1) || (static_cast<int>
                     (refCoordValue) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(refCoordValue), 1, i1,
                                       ac_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, bc_emlrtBCI);
                }

                refCoordValue = BoardCoords[((static_cast<int>(refCoordValue) +
                  BoardCoords.size(0) * j) + BoardCoords.size(0) *
                  BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1))
                  - 1];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     moveDistMultiplier * 1.5 * std::abs
                                     (coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  bool p;
                  p = true;
                  k = 0;
                  exitg2 = false;
                  while ((!exitg2) && (k < 2)) {
                    if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      k++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (i2 = 0; i2 < loop_ub; i2++) {
                      removedIdx[i1 + i2] = b_index[i2];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }

            n = 0;
            i = newIndices.size(1);
            for (k = 0; k < i; k++) {
              if (newIndices[k] != 0.0) {
                n++;
              }
            }

            if (n < 4) {
              loop_ub = newIndices.size(1) - 1;
              for (k = 0; k <= loop_ub; k++) {
                if (newIndices[k] > 0.0) {
                  if (k > loop_ub) {
                    rtDynamicBoundsError(k, 0, loop_ub, lf_emlrtBCI);
                  }

                  newIndices[k] = 0.0;
                }
              }
            }
          }

          //
          // Arguments    : ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::c_fitPolynomialIndices(::coder::array<double, 2U>
            &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> removedIdx;
            array<double, 1U> c_this;
            array<double, 1U> d_this;
            array<int, 1U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            int b_this;
            int i;
            int k;
            int loop_ub;
            int n;
            findIndependentVar(coordsToUse);
            newIndices.set_size(1, BoardCoords.size(1));
            loop_ub = BoardCoords.size(1);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(1);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(1);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ob_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     pb_emlrtBCI);
              }

              c_this.set_size(BoardCoords.size(0));
              loop_ub = BoardCoords.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                c_this[i1] = BoardCoords[(i1 + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(c_this, ii);
              if (ii.size(0) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                double refCoordValue;
                int currCurve_size[2];
                bool exitg1;
                bool p;
                i1 = BoardCoords.size(0);
                p = ((ii[0] < 1) || (ii[0] > i1));
                if (p) {
                  rtDynamicBoundsError(ii[0], 1, i1, tb_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, sb_emlrtBCI);
                }

                i1 = BoardCoords.size(0);
                if ((ii[1] < 1) || (ii[1] > i1)) {
                  rtDynamicBoundsError(ii[1], 1, i1, rb_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, qb_emlrtBCI);
                }

                currRad = coordsToUse[0];
                coordDist = (BoardCoords[((ii[0] + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)) - 1] - BoardCoords[((ii[1] +
                  BoardCoords.size(0) * j) + BoardCoords.size(0) *
                  BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1))
                             - 1]) / (static_cast<double>(ii[1]) - static_cast<
                                      double>(ii[0]));
                n = 0;
                i1 = ii.size(0);
                for (k = 0; k < i1; k++) {
                  if (ii[k] != 0) {
                    n++;
                  }
                }

                b_this = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, ub_emlrtBCI);
                }

                k = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, vb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       wb_emlrtBCI);
                }

                c_this.set_size(ii.size(0));
                loop_ub = ii.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > b_this)) {
                    rtDynamicBoundsError(ii[i1], 1, b_this, xb_emlrtBCI);
                  }

                  c_this[i1] = BoardCoords[((ii[i1] + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (currRad) - 1)) - 1];
                }

                d_this.set_size(ii.size(0));
                loop_ub = ii.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > k)) {
                    rtDynamicBoundsError(ii[i1], 1, k, yb_emlrtBCI);
                  }

                  d_this[i1] = BoardCoords[((ii[i1] + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[1]) - 1)) - 1];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(c_this, d_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, bc_emlrtBCI);
                }

                refCoordValue = BoardCoords[((ii[0] + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)) - 1];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     static_cast<double>(ii[0]) * 1.5 * std::abs
                                     (coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  p = true;
                  k = 0;
                  exitg2 = false;
                  while ((!exitg2) && (k < 2)) {
                    if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      k++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (k = 0; k < loop_ub; k++) {
                      removedIdx[i1 + k] = b_index[k];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }

            n = 0;
            i = newIndices.size(1);
            for (k = 0; k < i; k++) {
              if (newIndices[k] != 0.0) {
                n++;
              }
            }

            if (n < 4) {
              k = newIndices.size(1) - 1;
              for (b_this = 0; b_this <= k; b_this++) {
                if (newIndices[b_this] > 0.0) {
                  if (b_this > k) {
                    rtDynamicBoundsError(b_this, 0, k, lf_emlrtBCI);
                  }

                  newIndices[b_this] = 0.0;
                }
              }
            }
          }

          //
          // Arguments    : void
          // Return Type  : float
          //
          float Checkerboard::computeInitialEnergy() const
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              164,                     // lineNo
              74,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              164,                     // lineNo
              87,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              41,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              257,                     // lineNo
              36,                      // colNo
              "",                      // aName
              "Checkerboard/getPoints",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              257,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/getPoints",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              257,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/getPoints",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              74,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              87,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              164,                     // lineNo
              41,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              164,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 257,// lineNo
              36,                      // colNo
              "Checkerboard/getPoints",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ 2,// nDims
              154,                     // lineNo
              21,                      // colNo
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ 2,// nDims
              153,                     // lineNo
              19,                      // colNo
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ 2,// nDims
              162,                     // lineNo
              19,                      // colNo
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ 2,// nDims
              163,                     // lineNo
              21,                      // colNo
              "Checkerboard/computeInitialEnergy",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<float, 2U> col1;
            array<float, 2U> num;
            array<float, 2U> row2;
            array<float, 2U> row3;
            array<bool, 1U> b_this;
            float e;
            int i;
            int this_idx_0_tmp;
            this_idx_0_tmp = BoardIdx.size(0) * BoardIdx.size(1);
            b_this.set_size(this_idx_0_tmp);
            for (i = 0; i < this_idx_0_tmp; i++) {
              b_this[i] = (BoardIdx[i] < 0.0);
            }

            if (any(b_this)) {
              e = rtInfF;
            } else {
              double d;
              float b_x[3];
              float x[3];
              float y_idx_0;
              float y_idx_1;
              float y_idx_2;
              int c_this;
              int d_this;
              int loop_ub;
              int loop_ub_tmp;
              bool b;
              i = BoardIdx.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, tf_emlrtBCI);
              }

              c_this = BoardIdx.size(1);
              d_this = Points.size(0);
              col1.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, sf_emlrtBCI);
                }

                d = BoardIdx[0];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0)];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              i = BoardIdx.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, tf_emlrtBCI);
              }

              c_this = BoardIdx.size(1);
              d_this = Points.size(0);
              row2.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, sf_emlrtBCI);
                }

                d = BoardIdx[1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) + 1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2 + 1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              i = BoardIdx.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, tf_emlrtBCI);
              }

              c_this = BoardIdx.size(1);
              d_this = Points.size(0);
              row3.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, sf_emlrtBCI);
                }

                d = BoardIdx[2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) + 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, sf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2 + 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              i = Points.size(1);
              c_this = Points.size(1);
              b = ((i != c_this) && ((i != 1) && (c_this != 1)));
              if (b) {
                emlrtDimSizeImpxCheckR2021b(i, c_this, mb_emlrtECI);
              }

              if (col1.size(1) == row3.size(1)) {
                num.set_size(3, col1.size(1));
                loop_ub = 3 * col1.size(1);
                for (i = 0; i < loop_ub; i++) {
                  num[i] = col1[i] + row3[i];
                }
              } else {
                plus(num, col1, row3);
              }

              loop_ub_tmp = 3 * row2.size(1);
              row2.set_size(3, row2.size(1));
              for (i = 0; i < loop_ub_tmp; i++) {
                row2[i] = 2.0F * row2[i];
              }

              if ((num.size(1) != row2.size(1)) && ((num.size(1) != 1) &&
                   (row2.size(1) != 1))) {
                emlrtDimSizeImpxCheckR2021b(num.size(1), row2.size(1),
                  mb_emlrtECI);
              }

              if (num.size(1) == row2.size(1)) {
                loop_ub = 3 * num.size(1);
                num.set_size(3, num.size(1));
                for (i = 0; i < loop_ub; i++) {
                  num[i] = num[i] - row2[i];
                }
              } else {
                b_minus(num, row2);
              }

              if (b) {
                emlrtDimSizeImpxCheckR2021b(Points.size(1), Points.size(1),
                  lb_emlrtECI);
              }

              if (col1.size(1) == row3.size(1)) {
                loop_ub = 3 * col1.size(1);
                col1.set_size(3, col1.size(1));
                for (i = 0; i < loop_ub; i++) {
                  col1[i] = col1[i] - row3[i];
                }
              } else {
                b_minus(col1, row3);
              }

              if (num.size(1) < 1) {
                rtDynamicBoundsError(1, 1, num.size(1), qf_emlrtBCI);
              }

              if (num.size(1) < 2) {
                rtDynamicBoundsError(2, 1, num.size(1), uf_emlrtBCI);
              }

              if (col1.size(1) < 1) {
                rtDynamicBoundsError(1, 1, col1.size(1), vf_emlrtBCI);
              }

              if (col1.size(1) < 2) {
                rtDynamicBoundsError(2, 1, col1.size(1), wf_emlrtBCI);
              }

              x[0] = rt_hypotf_snf(num[0], num[3]);
              y_idx_0 = rt_hypotf_snf(col1[0], col1[3]);
              x[1] = rt_hypotf_snf(num[1], num[4]);
              y_idx_1 = rt_hypotf_snf(col1[1], col1[4]);
              x[2] = rt_hypotf_snf(num[2], num[5]);
              y_idx_2 = rt_hypotf_snf(col1[2], col1[5]);
              i = BoardIdx.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, sf_emlrtBCI);
              }

              c_this = BoardIdx.size(0);
              d_this = Points.size(0);
              col1.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, tf_emlrtBCI);
                }

                d = BoardIdx[0];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, tf_emlrtBCI);
                }

                d = BoardIdx[1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, tf_emlrtBCI);
                }

                d = BoardIdx[2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                col1[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              i = BoardIdx.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, sf_emlrtBCI);
              }

              c_this = BoardIdx.size(0);
              d_this = Points.size(0);
              row2.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0)];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) + 1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) + 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row2[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              i = BoardIdx.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, sf_emlrtBCI);
              }

              c_this = BoardIdx.size(0);
              d_this = Points.size(0);
              row3.set_size(3, Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                if (c_this < 1) {
                  rtDynamicBoundsError(1, 1, c_this, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i] = Points[(static_cast<int>(d) + Points.size(0) * i)
                  - 1];
                if (c_this < 2) {
                  rtDynamicBoundsError(2, 1, 1, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2 + 1];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i + 1] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
                if (c_this < 3) {
                  rtDynamicBoundsError(3, 1, 2, tf_emlrtBCI);
                }

                d = BoardIdx[BoardIdx.size(0) * 2 + 2];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, g_emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > d_this))
                {
                  rtDynamicBoundsError(static_cast<int>(d), 1, d_this,
                                       rf_emlrtBCI);
                }

                row3[3 * i + 2] = Points[(static_cast<int>(d) + Points.size(0) *
                  i) - 1];
              }

              if (b) {
                emlrtDimSizeImpxCheckR2021b(Points.size(1), Points.size(1),
                  nb_emlrtECI);
              }

              if (col1.size(1) == row3.size(1)) {
                num.set_size(3, col1.size(1));
                for (i = 0; i < loop_ub_tmp; i++) {
                  num[i] = col1[i] + row3[i];
                }
              } else {
                plus(num, col1, row3);
              }

              row2.set_size(3, row2.size(1));
              for (i = 0; i < loop_ub_tmp; i++) {
                row2[i] = 2.0F * row2[i];
              }

              if ((num.size(1) != row2.size(1)) && ((num.size(1) != 1) &&
                   (row2.size(1) != 1))) {
                emlrtDimSizeImpxCheckR2021b(num.size(1), row2.size(1),
                  nb_emlrtECI);
              }

              if (num.size(1) == row2.size(1)) {
                loop_ub = 3 * num.size(1);
                num.set_size(3, num.size(1));
                for (i = 0; i < loop_ub; i++) {
                  num[i] = num[i] - row2[i];
                }
              } else {
                b_minus(num, row2);
              }

              if (b) {
                emlrtDimSizeImpxCheckR2021b(Points.size(1), Points.size(1),
                  ob_emlrtECI);
              }

              if (col1.size(1) == row3.size(1)) {
                loop_ub = 3 * col1.size(1);
                col1.set_size(3, col1.size(1));
                for (i = 0; i < loop_ub; i++) {
                  col1[i] = col1[i] - row3[i];
                }
              } else {
                b_minus(col1, row3);
              }

              if (num.size(1) < 1) {
                rtDynamicBoundsError(1, 1, num.size(1), xf_emlrtBCI);
              }

              if (num.size(1) < 2) {
                rtDynamicBoundsError(2, 1, num.size(1), yf_emlrtBCI);
              }

              if (col1.size(1) < 1) {
                rtDynamicBoundsError(1, 1, col1.size(1), ag_emlrtBCI);
              }

              if (col1.size(1) < 2) {
                rtDynamicBoundsError(2, 1, col1.size(1), bg_emlrtBCI);
              }

              x[0] /= y_idx_0;
              b_x[0] = rt_hypotf_snf(num[0], num[3]) / rt_hypotf_snf(col1[0],
                col1[3]);
              x[1] /= y_idx_1;
              b_x[1] = rt_hypotf_snf(num[1], num[4]) / rt_hypotf_snf(col1[1],
                col1[4]);
              x[2] /= y_idx_2;
              b_x[2] = rt_hypotf_snf(num[2], num[5]) / rt_hypotf_snf(col1[2],
                col1[5]);
              e = static_cast<float>(this_idx_0_tmp) * std::fmax(std::fmax(0.0F,
                ::coder::internal::maximum(x)), ::coder::internal::maximum(b_x))
                - static_cast<float>(this_idx_0_tmp);
            }

            return e;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                float oldEnergy
          // Return Type  : float
          //
          float Checkerboard::computeNewEnergyHorizontal(const ::coder::array<
            double, 2U> &idx, float oldEnergy) const
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              809,                     // lineNo
              48,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              816,                     // lineNo
              57,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              816,                     // lineNo
              98,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              818,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              790,                     // lineNo
              44,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              790,                     // lineNo
              74,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              791,                     // lineNo
              37,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              796,                     // lineNo
              61,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              796,                     // lineNo
              99,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              818,                     // lineNo
              99,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              797,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              798,                     // lineNo
              101,                     // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              798,                     // lineNo
              63,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              817,                     // lineNo
              61,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 791,// lineNo
              33,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 796,// lineNo
              57,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 796,// lineNo
              95,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 797,// lineNo
              51,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo k_emlrtDCI{ 798,// lineNo
              59,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo l_emlrtDCI{ 798,// lineNo
              97,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo m_emlrtDCI{ 809,// lineNo
              44,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo n_emlrtDCI{ 816,// lineNo
              53,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo o_emlrtDCI{ 816,// lineNo
              94,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo p_emlrtDCI{ 817,// lineNo
              57,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo q_emlrtDCI{ 818,// lineNo
              55,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo r_emlrtDCI{ 818,// lineNo
              95,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo s_emlrtDCI{ 790,// lineNo
              40,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo t_emlrtDCI{ 790,// lineNo
              70,                      // colNo
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            array<double, 3U> c_this;
            array<double, 3U> denom;
            array<double, 3U> num;
            array<double, 3U> r2;
            array<double, 2U> b_denom;
            array<double, 2U> b_num;
            array<double, 2U> validNewColIdx;
            array<double, 1U> b_y;
            array<double, 1U> c_num;
            array<double, 1U> d_num;
            array<double, 1U> x;
            array<int, 1U> r1;
            array<bool, 2U> b_this;
            array<bool, 1U> r;
            array<bool, 1U> validIdx;
            double y;
            float newEnergy;
            float newEnergy_tmp;
            int iv[3];
            int iv1[3];
            int b_idx;
            int b_loop_ub;
            int c_idx;
            int d_idx;
            int end;
            int i;
            int i1;
            int i2;
            int i3;
            int loop_ub;
            int trueCount;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), eg_emlrtBCI);
            }

            i = static_cast<int>(std::floor(idx[0]));
            if (idx[0] != i) {
              rtIntegerError(idx[0], s_emlrtDCI);
            }

            i1 = BoardIdx.size(1);
            b_idx = static_cast<int>(idx[0]);
            if ((b_idx < 1) || (b_idx > i1)) {
              rtDynamicBoundsError(b_idx, 1, i1, me_emlrtBCI);
            }

            validIdx.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i1 = 0; i1 < loop_ub; i1++) {
              validIdx[i1] = (BoardIdx[i1 + BoardIdx.size(0) * (b_idx - 1)] >
                              0.0);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), qf_emlrtBCI);
            }

            i1 = static_cast<int>(std::floor(idx[1]));
            if (idx[1] != i1) {
              rtIntegerError(idx[1], t_emlrtDCI);
            }

            i2 = BoardIdx.size(1);
            c_idx = static_cast<int>(idx[1]);
            if ((c_idx < 1) || (c_idx > i2)) {
              rtDynamicBoundsError(c_idx, 1, i2, ne_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i2 = 0; i2 < loop_ub; i2++) {
              r[i2] = (BoardIdx[i2 + BoardIdx.size(0) * (c_idx - 1)] > 0.0);
            }

            if (validIdx.size(0) != r.size(0)) {
              rtSizeEq1DError(validIdx.size(0), r.size(0), fb_emlrtECI);
            }

            loop_ub = validIdx.size(0);
            for (i2 = 0; i2 < loop_ub; i2++) {
              validIdx[i2] = (validIdx[i2] && r[i2]);
            }

            if (idx.size(1) < 3) {
              rtDynamicBoundsError(3, 1, idx.size(1), rf_emlrtBCI);
            }

            i2 = static_cast<int>(std::floor(idx[2]));
            if (idx[2] != i2) {
              rtIntegerError(idx[2], g_emlrtDCI);
            }

            i3 = BoardIdx.size(1);
            d_idx = static_cast<int>(idx[2]);
            if ((d_idx < 1) || (d_idx > i3)) {
              rtDynamicBoundsError(d_idx, 1, i3, oe_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i3 = 0; i3 < loop_ub; i3++) {
              r[i3] = (BoardIdx[i3 + BoardIdx.size(0) * (d_idx - 1)] > 0.0);
            }

            if ((validIdx.size(0) != r.size(0)) && ((validIdx.size(0) != 1) &&
                 (r.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(validIdx.size(0), r.size(0),
                gb_emlrtECI);
            }

            if (validIdx.size(0) == r.size(0)) {
              loop_ub = validIdx.size(0);
              for (i3 = 0; i3 < loop_ub; i3++) {
                validIdx[i3] = (validIdx[i3] && r[i3]);
              }
            } else {
              c_and(validIdx, r);
            }

            newEnergy = 0.0F;
            if (any(validIdx)) {
              if (idx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, idx.size(1), sf_emlrtBCI);
              }

              end = validIdx.size(0) - 1;
              trueCount = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  trueCount++;
                }
              }

              r1.set_size(trueCount);
              trueCount = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  r1[trueCount] = b_i;
                  trueCount++;
                }
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i3 = 0; i3 < loop_ub; i3++) {
                if (r1[i3] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i3], 0, trueCount - 1, gf_emlrtBCI);
                }
              }

              if (idx[0] != i) {
                rtIntegerError(idx[0], h_emlrtDCI);
              }

              i3 = BoardCoords.size(1);
              if ((b_idx < 1) || (b_idx > i3)) {
                rtDynamicBoundsError(b_idx, 1, i3, pe_emlrtBCI);
              }

              if (idx.size(1) < 3) {
                rtDynamicBoundsError(3, 1, idx.size(1), tf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i3 = 0; i3 < loop_ub; i3++) {
                if (r1[i3] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i3], 0, trueCount - 1, hf_emlrtBCI);
                }
              }

              if (idx[2] != i2) {
                rtIntegerError(idx[2], i_emlrtDCI);
              }

              i3 = BoardCoords.size(1);
              if (d_idx > i3) {
                rtDynamicBoundsError(d_idx, 1, i3, qe_emlrtBCI);
              }

              iv[0] = r1.size(0);
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = r1.size(0);
              iv1[1] = 1;
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], hb_emlrtECI);
              }

              if (idx.size(1) < 2) {
                rtDynamicBoundsError(2, 1, idx.size(1), vf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i3 = 0; i3 < loop_ub; i3++) {
                if (r1[i3] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i3], 0, trueCount - 1, if_emlrtBCI);
                }
              }

              if (idx[1] != i1) {
                rtIntegerError(idx[1], j_emlrtDCI);
              }

              i1 = BoardCoords.size(1);
              if (c_idx > i1) {
                rtDynamicBoundsError(c_idx, 1, i1, re_emlrtBCI);
              }

              r2.set_size(r1.size(0), 1, BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_loop_ub = r1.size(0);
                for (i3 = 0; i3 < b_loop_ub; i3++) {
                  r2[i3 + r2.size(0) * i1] = 2.0 * BoardCoords[(r1[i3] +
                    BoardCoords.size(0) * (c_idx - 1)) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1];
                }
              }

              if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) && (r2.size(0)
                    != 1))) {
                emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0), ib_emlrtECI);
              }

              i1 = BoardCoords.size(2);
              if ((i1 != r2.size(2)) && ((i1 != 1) && (r2.size(2) != 1))) {
                emlrtDimSizeImpxCheckR2021b(i1, r2.size(2), hb_emlrtECI);
              }

              if ((r1.size(0) == r2.size(0)) && (BoardCoords.size(2) == r2.size
                   (2))) {
                c_this.set_size(r1.size(0), 1, BoardCoords.size(2));
                loop_ub = BoardCoords.size(2);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  b_loop_ub = r1.size(0);
                  for (i3 = 0; i3 < b_loop_ub; i3++) {
                    c_this[i3 + c_this.size(0) * i1] = (BoardCoords[(r1[i3] +
                      BoardCoords.size(0) * (b_idx - 1)) + BoardCoords.size(0) *
                      BoardCoords.size(1) * i1] + BoardCoords[(r1[i3] +
                      BoardCoords.size(0) * (d_idx - 1)) + BoardCoords.size(0) *
                      BoardCoords.size(1) * i1]) - r2[i3 + r2.size(0) * i1];
                  }
                }

                b_squeeze(c_this, b_num);
              } else {
                binary_expand_op(b_num, this, r1, idx, r2);
              }

              if (idx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, idx.size(1), xf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                if ((r1[i1] < 0) || (r1[i1] > trueCount - 1)) {
                  rtDynamicBoundsError(r1[i1], 0, trueCount - 1, jf_emlrtBCI);
                }
              }

              if (idx[0] != i) {
                rtIntegerError(idx[0], k_emlrtDCI);
              }

              if (idx.size(1) < 3) {
                rtDynamicBoundsError(3, 1, idx.size(1), wf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                if ((r1[i1] < 0) || (r1[i1] > trueCount - 1)) {
                  rtDynamicBoundsError(r1[i1], 0, trueCount - 1, kf_emlrtBCI);
                }
              }

              if (idx[2] != i2) {
                rtIntegerError(idx[2], l_emlrtDCI);
              }

              iv[0] = r1.size(0);
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = r1.size(0);
              iv1[1] = 1;
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], jb_emlrtECI);
              }

              c_this.set_size(r1.size(0), 1, BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_loop_ub = r1.size(0);
                for (i2 = 0; i2 < b_loop_ub; i2++) {
                  c_this[i2 + c_this.size(0) * i1] = BoardCoords[(r1[i2] +
                    BoardCoords.size(0) * (b_idx - 1)) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1] - BoardCoords[(r1[i2] +
                    BoardCoords.size(0) * (d_idx - 1)) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1];
                }
              }

              b_squeeze(c_this, b_denom);
              if (b_num.size(1) > 1) {
                if (b_denom.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, b_denom.size(1), se_emlrtBCI);
                }

                if (b_denom.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, b_denom.size(1), te_emlrtBCI);
                }

                c_num.set_size(b_num.size(0));
                loop_ub = b_num.size(0);
                d_num.set_size(b_num.size(0));
                for (i1 = 0; i1 < loop_ub; i1++) {
                  c_num[i1] = b_num[i1];
                  d_num[i1] = b_num[i1 + b_num.size(0)];
                }

                b_hypot(c_num, d_num, x);
                c_num.set_size(b_denom.size(0));
                loop_ub = b_denom.size(0);
                d_num.set_size(b_denom.size(0));
                for (i1 = 0; i1 < loop_ub; i1++) {
                  c_num[i1] = b_denom[i1];
                  d_num[i1] = b_denom[i1 + b_denom.size(0)];
                }

                b_hypot(c_num, d_num, b_y);
                if ((x.size(0) != 1) && (b_y.size(0) != 1) && (x.size(0) !=
                     b_y.size(0))) {
                  j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
                }

                if (x.size(0) == b_y.size(0)) {
                  loop_ub = x.size(0);
                  for (i1 = 0; i1 < loop_ub; i1++) {
                    x[i1] = x[i1] / b_y[i1];
                  }

                  y = ::coder::internal::maximum(x);
                } else {
                  y = binary_expand_op(x, b_y);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
              } else {
                i1 = b_num.size(0) * b_num.size(1);
                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, ue_emlrtBCI);
                }

                if (i1 < 2) {
                  rtDynamicBoundsError(2, 1, 1, ve_emlrtBCI);
                }

                i1 = b_denom.size(0) * b_denom.size(1);
                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, we_emlrtBCI);
                }

                if (i1 < 2) {
                  rtDynamicBoundsError(2, 1, 1, xe_emlrtBCI);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>
                                      (rt_hypotd_snf(b_num[0], b_num[1]) /
                  rt_hypotd_snf(b_denom[0], b_denom[1])));
              }
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), ag_emlrtBCI);
            }

            if (idx[0] != i) {
              rtIntegerError(idx[0], m_emlrtDCI);
            }

            b_this.set_size(1, BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_this[i1] = (BoardIdx[i1 + BoardIdx.size(0) * (b_idx - 1)] > 0.0);
            }

            Checkerboard::arrayFind(b_this, validNewColIdx);
            if (validNewColIdx.size(1) != 0) {
              int c_loop_ub;
              int i4;
              int i5;
              int i6;
              i1 = validNewColIdx.size(1);
              loop_ub = BoardCoords.size(2);
              b_loop_ub = BoardCoords.size(2);
              i2 = BoardCoords.size(0);
              i3 = BoardCoords.size(1);
              i4 = BoardCoords.size(2);
              c_loop_ub = BoardCoords.size(2);
              i5 = BoardCoords.size(0);
              i6 = BoardCoords.size(2);
              for (int b_i{0}; b_i < i1; b_i++) {
                if (b_i + 1 > validNewColIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, validNewColIdx.size(1),
                                       ye_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), bg_emlrtBCI);
                }

                d_idx = static_cast<int>(validNewColIdx[b_i]);
                if ((d_idx < 1) || (d_idx > i2)) {
                  rtDynamicBoundsError(d_idx, 1, i2, af_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], n_emlrtDCI);
                }

                if ((b_idx < 1) || (b_idx > i3)) {
                  rtDynamicBoundsError(b_idx, 1, i3, bf_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), cg_emlrtBCI);
                }

                trueCount = static_cast<int>(validNewColIdx[b_i] + 2.0);
                if ((trueCount < 1) || (trueCount > i2)) {
                  rtDynamicBoundsError(trueCount, 1, i2, cf_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], o_emlrtDCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), yf_emlrtBCI);
                }

                end = static_cast<int>(validNewColIdx[b_i] + 1.0);
                if ((end < 1) || (end > i2)) {
                  rtDynamicBoundsError(end, 1, i2, df_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], p_emlrtDCI);
                }

                num.set_size(1, 1, i4);
                for (c_idx = 0; c_idx < loop_ub; c_idx++) {
                  num[c_idx] = 2.0 * BoardCoords[((end + BoardCoords.size(0) *
                    (b_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                    c_idx) - 1];
                }

                if ((c_loop_ub != num.size(2)) && ((c_loop_ub != 1) && (num.size
                      (2) != 1))) {
                  emlrtDimSizeImpxCheckR2021b(c_loop_ub, num.size(2),
                    kb_emlrtECI);
                }

                if (c_loop_ub == num.size(2)) {
                  num.set_size(1, 1, c_loop_ub);
                  for (c_idx = 0; c_idx < c_loop_ub; c_idx++) {
                    num[c_idx] = (BoardCoords[((d_idx + BoardCoords.size(0) *
                      (b_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                      c_idx) - 1] + BoardCoords[((trueCount + BoardCoords.size(0)
                      * (b_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1)
                      * c_idx) - 1]) - num[c_idx];
                  }
                } else {
                  binary_expand_op(num, this, validNewColIdx, b_i, idx);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), dg_emlrtBCI);
                }

                if (d_idx > i5) {
                  rtDynamicBoundsError(d_idx, 1, i5, ef_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], q_emlrtDCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), uf_emlrtBCI);
                }

                if (trueCount > i5) {
                  rtDynamicBoundsError(trueCount, 1, i5, ff_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], r_emlrtDCI);
                }

                denom.set_size(1, 1, i6);
                for (c_idx = 0; c_idx < b_loop_ub; c_idx++) {
                  denom[c_idx] = BoardCoords[((d_idx + BoardCoords.size(0) *
                    (b_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                    c_idx) - 1] - BoardCoords[((trueCount + BoardCoords.size(0) *
                    (b_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                    c_idx) - 1];
                }

                if (std::isnan(newEnergy)) {
                  s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
                }

                if (newEnergy != 0.0F) {
                  c_idx = num.size(2);
                  d_idx = denom.size(2);
                  c_num = num.reshape(c_idx);
                  d_num = denom.reshape(d_idx);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(newEnergy, static_cast<float>(y));
                } else {
                  c_idx = num.size(2);
                  d_idx = denom.size(2);
                  c_num = num.reshape(c_idx);
                  d_num = denom.reshape(d_idx);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
                }
              }
            }

            if (std::isnan(newEnergy)) {
              s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
            }

            newEnergy_tmp = static_cast<float>(BoardIdx.size(0) * BoardIdx.size
              (1));
            if (newEnergy != 0.0F) {
              newEnergy = newEnergy * newEnergy_tmp - newEnergy_tmp;
            } else {
              newEnergy = rtInfF;
            }

            return newEnergy;
          }

          //
          // Arguments    : float oldEnergy
          // Return Type  : float
          //
          float Checkerboard::computeNewEnergyHorizontal(float oldEnergy) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              798,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              798,                     // lineNo
              97,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              809,                     // lineNo
              44,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              818,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyHorizontal",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 3U> c_this;
            array<double, 3U> denom;
            array<double, 3U> num;
            array<double, 3U> r2;
            array<double, 2U> b_denom;
            array<double, 2U> b_num;
            array<double, 2U> validNewColIdx;
            array<double, 1U> b_y;
            array<double, 1U> c_num;
            array<double, 1U> d_num;
            array<double, 1U> x;
            array<int, 1U> r1;
            array<bool, 2U> b_this;
            array<bool, 1U> r;
            array<bool, 1U> validIdx;
            double y;
            float newEnergy;
            float newEnergy_tmp;
            int iv[3];
            int iv1[3];
            int b_loop_ub;
            int end;
            int i;
            int i1;
            int loop_ub;
            int trueCount;
            i = BoardIdx.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, me_emlrtBCI);
            }

            validIdx.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              validIdx[i] = (BoardIdx[i] > 0.0);
            }

            i = BoardIdx.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ne_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[i + BoardIdx.size(0)] > 0.0);
            }

            if (validIdx.size(0) != r.size(0)) {
              rtSizeEq1DError(validIdx.size(0), r.size(0), fb_emlrtECI);
            }

            loop_ub = validIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              validIdx[i] = (validIdx[i] && r[i]);
            }

            i = BoardIdx.size(1);
            if (i < 3) {
              rtDynamicBoundsError(3, 1, i, oe_emlrtBCI);
            }

            r.set_size(BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[i + BoardIdx.size(0) * 2] > 0.0);
            }

            if ((validIdx.size(0) != r.size(0)) && ((validIdx.size(0) != 1) &&
                 (r.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(validIdx.size(0), r.size(0),
                gb_emlrtECI);
            }

            if (validIdx.size(0) == r.size(0)) {
              loop_ub = validIdx.size(0);
              for (i = 0; i < loop_ub; i++) {
                validIdx[i] = (validIdx[i] && r[i]);
              }
            } else {
              c_and(validIdx, r);
            }

            newEnergy = 0.0F;
            if (any(validIdx)) {
              i = BoardCoords.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, pe_emlrtBCI);
              }

              end = validIdx.size(0) - 1;
              trueCount = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  trueCount++;
                }
              }

              r1.set_size(trueCount);
              trueCount = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  r1[trueCount] = b_i;
                  trueCount++;
                }
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i = 0; i < loop_ub; i++) {
                if (r1[i] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i], 0, trueCount - 1, gf_emlrtBCI);
                }
              }

              i = BoardCoords.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, qe_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i = 0; i < loop_ub; i++) {
                if (r1[i] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i], 0, trueCount - 1, hf_emlrtBCI);
                }
              }

              iv[0] = r1.size(0);
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = r1.size(0);
              iv1[1] = 1;
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], hb_emlrtECI);
              }

              i = BoardCoords.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, re_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i = 0; i < loop_ub; i++) {
                if (r1[i] > trueCount - 1) {
                  rtDynamicBoundsError(r1[i], 0, trueCount - 1, if_emlrtBCI);
                }
              }

              r2.set_size(r1.size(0), 1, BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(0);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  r2[i1 + r2.size(0) * i] = 2.0 * BoardCoords[(r1[i1] +
                    BoardCoords.size(0)) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i];
                }
              }

              if ((r1.size(0) != r2.size(0)) && ((r1.size(0) != 1) && (r2.size(0)
                    != 1))) {
                emlrtDimSizeImpxCheckR2021b(r1.size(0), r2.size(0), ib_emlrtECI);
              }

              i = BoardCoords.size(2);
              if ((i != r2.size(2)) && ((i != 1) && (r2.size(2) != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, r2.size(2), hb_emlrtECI);
              }

              if ((r1.size(0) == r2.size(0)) && (BoardCoords.size(2) == r2.size
                   (2))) {
                c_this.set_size(r1.size(0), 1, BoardCoords.size(2));
                loop_ub = BoardCoords.size(2);
                for (i = 0; i < loop_ub; i++) {
                  b_loop_ub = r1.size(0);
                  for (i1 = 0; i1 < b_loop_ub; i1++) {
                    c_this[i1 + c_this.size(0) * i] = (BoardCoords[r1[i1] +
                      BoardCoords.size(0) * BoardCoords.size(1) * i] +
                      BoardCoords[(r1[i1] + BoardCoords.size(0) * 2) +
                      BoardCoords.size(0) * BoardCoords.size(1) * i]) - r2[i1 +
                      r2.size(0) * i];
                  }
                }

                b_squeeze(c_this, b_num);
              } else {
                binary_expand_op(b_num, this, r1, r2);
              }

              i = BoardCoords.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, qf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i = 0; i < loop_ub; i++) {
                if ((r1[i] < 0) || (r1[i] > trueCount - 1)) {
                  rtDynamicBoundsError(r1[i], 0, trueCount - 1, jf_emlrtBCI);
                }
              }

              i = BoardCoords.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, rf_emlrtBCI);
              }

              trueCount = BoardCoords.size(0);
              loop_ub = r1.size(0);
              for (i = 0; i < loop_ub; i++) {
                if ((r1[i] < 0) || (r1[i] > trueCount - 1)) {
                  rtDynamicBoundsError(r1[i], 0, trueCount - 1, kf_emlrtBCI);
                }
              }

              iv[0] = r1.size(0);
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = r1.size(0);
              iv1[1] = 1;
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], jb_emlrtECI);
              }

              c_this.set_size(r1.size(0), 1, BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(0);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  c_this[i1 + c_this.size(0) * i] = BoardCoords[r1[i1] +
                    BoardCoords.size(0) * BoardCoords.size(1) * i] -
                    BoardCoords[(r1[i1] + BoardCoords.size(0) * 2) +
                    BoardCoords.size(0) * BoardCoords.size(1) * i];
                }
              }

              b_squeeze(c_this, b_denom);
              if (b_num.size(1) > 1) {
                if (b_denom.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, b_denom.size(1), se_emlrtBCI);
                }

                if (b_denom.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, b_denom.size(1), te_emlrtBCI);
                }

                c_num.set_size(b_num.size(0));
                loop_ub = b_num.size(0);
                d_num.set_size(b_num.size(0));
                for (i = 0; i < loop_ub; i++) {
                  c_num[i] = b_num[i];
                  d_num[i] = b_num[i + b_num.size(0)];
                }

                b_hypot(c_num, d_num, x);
                c_num.set_size(b_denom.size(0));
                loop_ub = b_denom.size(0);
                d_num.set_size(b_denom.size(0));
                for (i = 0; i < loop_ub; i++) {
                  c_num[i] = b_denom[i];
                  d_num[i] = b_denom[i + b_denom.size(0)];
                }

                b_hypot(c_num, d_num, b_y);
                if ((x.size(0) != 1) && (b_y.size(0) != 1) && (x.size(0) !=
                     b_y.size(0))) {
                  j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
                }

                if (x.size(0) == b_y.size(0)) {
                  loop_ub = x.size(0);
                  for (i = 0; i < loop_ub; i++) {
                    x[i] = x[i] / b_y[i];
                  }

                  y = ::coder::internal::maximum(x);
                } else {
                  y = binary_expand_op(x, b_y);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
              } else {
                i = b_num.size(0) * b_num.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, ue_emlrtBCI);
                }

                if (i < 2) {
                  rtDynamicBoundsError(2, 1, 1, ve_emlrtBCI);
                }

                i = b_denom.size(0) * b_denom.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, we_emlrtBCI);
                }

                if (i < 2) {
                  rtDynamicBoundsError(2, 1, 1, xe_emlrtBCI);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>
                                      (rt_hypotd_snf(b_num[0], b_num[1]) /
                  rt_hypotd_snf(b_denom[0], b_denom[1])));
              }
            }

            i = BoardIdx.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, sf_emlrtBCI);
            }

            b_this.set_size(1, BoardIdx.size(0));
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_this[i] = (BoardIdx[i] > 0.0);
            }

            Checkerboard::arrayFind(b_this, validNewColIdx);
            if (validNewColIdx.size(1) != 0) {
              int c_loop_ub;
              int i2;
              int i3;
              int i4;
              int i5;
              int i6;
              i = validNewColIdx.size(1);
              loop_ub = BoardCoords.size(2);
              b_loop_ub = BoardCoords.size(2);
              i1 = BoardCoords.size(1);
              i2 = BoardCoords.size(0);
              i3 = BoardCoords.size(2);
              c_loop_ub = BoardCoords.size(2);
              i4 = BoardCoords.size(1);
              i5 = BoardCoords.size(0);
              i6 = BoardCoords.size(2);
              for (int b_i{0}; b_i < i; b_i++) {
                int b_validNewColIdx;
                if (b_i + 1 > validNewColIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, validNewColIdx.size(1),
                                       ye_emlrtBCI);
                }

                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, bf_emlrtBCI);
                }

                b_validNewColIdx = static_cast<int>(validNewColIdx[b_i]);
                if ((b_validNewColIdx < 1) || (b_validNewColIdx > i2)) {
                  rtDynamicBoundsError(b_validNewColIdx, 1, i2, af_emlrtBCI);
                }

                trueCount = static_cast<int>(validNewColIdx[b_i] + 2.0);
                if ((trueCount < 1) || (trueCount > i2)) {
                  rtDynamicBoundsError(trueCount, 1, i2, cf_emlrtBCI);
                }

                end = static_cast<int>(validNewColIdx[b_i] + 1.0);
                if ((end < 1) || (end > i2)) {
                  rtDynamicBoundsError(end, 1, i2, df_emlrtBCI);
                }

                num.set_size(1, 1, i3);
                for (int i7{0}; i7 < loop_ub; i7++) {
                  num[i7] = 2.0 * BoardCoords[(end + BoardCoords.size(0) *
                    BoardCoords.size(1) * i7) - 1];
                }

                if ((c_loop_ub != num.size(2)) && ((c_loop_ub != 1) && (num.size
                      (2) != 1))) {
                  emlrtDimSizeImpxCheckR2021b(c_loop_ub, num.size(2),
                    kb_emlrtECI);
                }

                if (c_loop_ub == num.size(2)) {
                  num.set_size(1, 1, c_loop_ub);
                  for (int i7{0}; i7 < c_loop_ub; i7++) {
                    num[i7] = (BoardCoords[(b_validNewColIdx + BoardCoords.size
                                (0) * BoardCoords.size(1) * i7) - 1] +
                               BoardCoords[(trueCount + BoardCoords.size(0) *
                                BoardCoords.size(1) * i7) - 1]) - num[i7];
                  }
                } else {
                  b_binary_expand_op(num, this, validNewColIdx, b_i);
                }

                if (i4 < 1) {
                  rtDynamicBoundsError(1, 1, i4, tf_emlrtBCI);
                }

                if (b_validNewColIdx > i5) {
                  rtDynamicBoundsError(b_validNewColIdx, 1, i5, ef_emlrtBCI);
                }

                if (trueCount > i5) {
                  rtDynamicBoundsError(trueCount, 1, i5, ff_emlrtBCI);
                }

                denom.set_size(1, 1, i6);
                for (int i7{0}; i7 < b_loop_ub; i7++) {
                  denom[i7] = BoardCoords[(b_validNewColIdx + BoardCoords.size(0)
                    * BoardCoords.size(1) * i7) - 1] - BoardCoords[(trueCount +
                    BoardCoords.size(0) * BoardCoords.size(1) * i7) - 1];
                }

                if (std::isnan(newEnergy)) {
                  s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
                }

                if (newEnergy != 0.0F) {
                  b_validNewColIdx = num.size(2);
                  trueCount = denom.size(2);
                  c_num = num.reshape(b_validNewColIdx);
                  d_num = denom.reshape(trueCount);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(newEnergy, static_cast<float>(y));
                } else {
                  b_validNewColIdx = num.size(2);
                  trueCount = denom.size(2);
                  c_num = num.reshape(b_validNewColIdx);
                  d_num = denom.reshape(trueCount);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
                }
              }
            }

            if (std::isnan(newEnergy)) {
              s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
            }

            newEnergy_tmp = static_cast<float>(BoardIdx.size(0) * BoardIdx.size
              (1));
            if (newEnergy != 0.0F) {
              newEnergy = newEnergy * newEnergy_tmp - newEnergy_tmp;
            } else {
              newEnergy = rtInfF;
            }

            return newEnergy;
          }

          //
          // Arguments    : float oldEnergy
          // Return Type  : float
          //
          float Checkerboard::computeNewEnergyVertical(float oldEnergy) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              753,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              753,                     // lineNo
              88,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              764,                     // lineNo
              41,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              773,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 3U> b;
            array<double, 3U> denom;
            array<double, 3U> num;
            array<double, 3U> r2;
            array<double, 3U> r3;
            array<double, 3U> r4;
            array<double, 2U> b_denom;
            array<double, 2U> b_num;
            array<double, 2U> validNewRowIdx;
            array<double, 1U> b_y;
            array<double, 1U> c_num;
            array<double, 1U> d_num;
            array<double, 1U> x;
            array<int, 2U> r1;
            array<bool, 2U> r;
            array<bool, 2U> validIdx;
            double y;
            float newEnergy;
            float newEnergy_tmp;
            int iv[3];
            int iv1[3];
            int b_loop_ub;
            int end;
            int i;
            int i1;
            int loop_ub;
            int loop_ub_tmp;
            i = BoardIdx.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, wc_emlrtBCI);
            }

            validIdx.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              validIdx[i] = (BoardIdx[BoardIdx.size(0) * i] > 0.0);
            }

            i = BoardIdx.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, xc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[BoardIdx.size(0) * i + 1] > 0.0);
            }

            if (validIdx.size(1) != r.size(1)) {
              rtSizeEqNDCheck(validIdx.size(), r.size(), ab_emlrtECI);
            }

            validIdx.set_size(1, validIdx.size(1));
            loop_ub_tmp = validIdx.size(1) - 1;
            for (i = 0; i <= loop_ub_tmp; i++) {
              validIdx[i] = (validIdx[i] && r[i]);
            }

            i = BoardIdx.size(0);
            if (i < 3) {
              rtDynamicBoundsError(3, 1, i, yc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[BoardIdx.size(0) * i + 2] > 0.0);
            }

            if ((validIdx.size(1) != r.size(1)) && ((validIdx.size(1) != 1) &&
                 (r.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(validIdx.size(1), r.size(1),
                ab_emlrtECI);
            }

            if (validIdx.size(1) == r.size(1)) {
              validIdx.set_size(1, validIdx.size(1));
              for (i = 0; i <= loop_ub_tmp; i++) {
                validIdx[i] = (validIdx[i] && r[i]);
              }
            } else {
              b_and(validIdx, r);
            }

            newEnergy = 0.0F;
            if (b_any(validIdx)) {
              i = BoardCoords.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, ad_emlrtBCI);
              }

              end = validIdx.size(1) - 1;
              loop_ub_tmp = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  loop_ub_tmp++;
                }
              }

              r1.set_size(1, loop_ub_tmp);
              loop_ub_tmp = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  r1[loop_ub_tmp] = b_i;
                  loop_ub_tmp++;
                }
              }

              end = BoardCoords.size(1);
              r2.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(1);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  if (r1[i1] > end - 1) {
                    rtDynamicBoundsError(r1[i1], 0, end - 1, qd_emlrtBCI);
                  }

                  r2[i1 + r2.size(1) * i] = BoardCoords[BoardCoords.size(0) *
                    r1[i1] + BoardCoords.size(0) * BoardCoords.size(1) * i];
                }
              }

              i = BoardCoords.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, bd_emlrtBCI);
              }

              end = BoardCoords.size(1);
              r3.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(1);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  if (r1[i1] > end - 1) {
                    rtDynamicBoundsError(r1[i1], 0, end - 1, rd_emlrtBCI);
                  }

                  r3[i1 + r3.size(1) * i] = BoardCoords[(BoardCoords.size(0) *
                    r1[i1] + BoardCoords.size(0) * BoardCoords.size(1) * i) + 2];
                }
              }

              iv[0] = 1;
              iv[1] = r1.size(1);
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = r1.size(1);
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], bb_emlrtECI);
              }

              i = BoardCoords.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, cd_emlrtBCI);
              }

              end = BoardCoords.size(1);
              b.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(1);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  if (r1[i1] > end - 1) {
                    rtDynamicBoundsError(r1[i1], 0, end - 1, sd_emlrtBCI);
                  }

                  b[i1 + b.size(1) * i] = BoardCoords[(BoardCoords.size(0) *
                    r1[i1] + BoardCoords.size(0) * BoardCoords.size(1) * i) + 1];
                }
              }

              loop_ub_tmp = b.size(1) * b.size(2);
              b.set_size(1, b.size(1), b.size(2));
              for (i = 0; i < loop_ub_tmp; i++) {
                b[i] = 2.0 * b[i];
              }

              if ((r1.size(1) != b.size(1)) && ((r1.size(1) != 1) && (b.size(1)
                    != 1))) {
                emlrtDimSizeImpxCheckR2021b(r1.size(1), b.size(1), cb_emlrtECI);
              }

              i = BoardCoords.size(2);
              if ((i != b.size(2)) && ((i != 1) && (b.size(2) != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, b.size(2), bb_emlrtECI);
              }

              if ((r2.size(1) == b.size(1)) && (r2.size(2) == b.size(2))) {
                r4.set_size(1, r2.size(1), r2.size(2));
                for (i = 0; i < loop_ub_tmp; i++) {
                  r4[i] = (r2[i] + r3[i]) - b[i];
                }

                squeeze(r4, b_num);
              } else {
                binary_expand_op(b_num, r2, r3, b);
              }

              i = BoardCoords.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, qf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              r2.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(1);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  if (r1[i1] > end - 1) {
                    rtDynamicBoundsError(r1[i1], 0, end - 1, td_emlrtBCI);
                  }

                  r2[i1 + r2.size(1) * i] = BoardCoords[BoardCoords.size(0) *
                    r1[i1] + BoardCoords.size(0) * BoardCoords.size(1) * i];
                }
              }

              i = BoardCoords.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, rf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              r3.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i = 0; i < loop_ub; i++) {
                b_loop_ub = r1.size(1);
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  if (r1[i1] > end - 1) {
                    rtDynamicBoundsError(r1[i1], 0, end - 1, ud_emlrtBCI);
                  }

                  r3[i1 + r3.size(1) * i] = BoardCoords[(BoardCoords.size(0) *
                    r1[i1] + BoardCoords.size(0) * BoardCoords.size(1) * i) + 2];
                }
              }

              r4.set_size(1, r2.size(1), r2.size(2));
              for (i = 0; i < loop_ub_tmp; i++) {
                r4[i] = r2[i] - r3[i];
              }

              squeeze(r4, b_denom);
              if (b_num.size(1) > 1) {
                if (b_denom.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, b_denom.size(1), dd_emlrtBCI);
                }

                if (b_denom.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, b_denom.size(1), ed_emlrtBCI);
                }

                c_num.set_size(b_num.size(0));
                loop_ub = b_num.size(0);
                d_num.set_size(b_num.size(0));
                for (i = 0; i < loop_ub; i++) {
                  c_num[i] = b_num[i];
                  d_num[i] = b_num[i + b_num.size(0)];
                }

                b_hypot(c_num, d_num, x);
                c_num.set_size(b_denom.size(0));
                loop_ub = b_denom.size(0);
                d_num.set_size(b_denom.size(0));
                for (i = 0; i < loop_ub; i++) {
                  c_num[i] = b_denom[i];
                  d_num[i] = b_denom[i + b_denom.size(0)];
                }

                b_hypot(c_num, d_num, b_y);
                if ((x.size(0) != 1) && (b_y.size(0) != 1) && (x.size(0) !=
                     b_y.size(0))) {
                  j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
                }

                if (x.size(0) == b_y.size(0)) {
                  loop_ub = x.size(0);
                  for (i = 0; i < loop_ub; i++) {
                    x[i] = x[i] / b_y[i];
                  }

                  y = ::coder::internal::maximum(x);
                } else {
                  y = binary_expand_op(x, b_y);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
              } else {
                i = b_num.size(0) * b_num.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, fd_emlrtBCI);
                }

                if (i < 2) {
                  rtDynamicBoundsError(2, 1, 1, gd_emlrtBCI);
                }

                i = b_denom.size(0) * b_denom.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, hd_emlrtBCI);
                }

                if (i < 2) {
                  rtDynamicBoundsError(2, 1, 1, id_emlrtBCI);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>
                                      (rt_hypotd_snf(b_num[0], b_num[1]) /
                  rt_hypotd_snf(b_denom[0], b_denom[1])));
              }
            }

            i = BoardIdx.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, sf_emlrtBCI);
            }

            validIdx.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              validIdx[i] = (BoardIdx[BoardIdx.size(0) * i] > 0.0);
            }

            Checkerboard::arrayFind(validIdx, validNewRowIdx);
            if (validNewRowIdx.size(1) != 0) {
              int c_loop_ub;
              int i2;
              int i3;
              int i4;
              int i5;
              int i6;
              i = validNewRowIdx.size(1);
              loop_ub = BoardCoords.size(2);
              b_loop_ub = BoardCoords.size(2);
              i1 = BoardCoords.size(0);
              i2 = BoardCoords.size(1);
              i3 = BoardCoords.size(2);
              c_loop_ub = BoardCoords.size(2);
              i4 = BoardCoords.size(0);
              i5 = BoardCoords.size(1);
              i6 = BoardCoords.size(2);
              for (int b_i{0}; b_i < i; b_i++) {
                int b_validNewRowIdx;
                if (b_i + 1 > validNewRowIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, validNewRowIdx.size(1),
                                       jd_emlrtBCI);
                }

                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, kd_emlrtBCI);
                }

                b_validNewRowIdx = static_cast<int>(validNewRowIdx[b_i]);
                if ((b_validNewRowIdx < 1) || (b_validNewRowIdx > i2)) {
                  rtDynamicBoundsError(b_validNewRowIdx, 1, i2, ld_emlrtBCI);
                }

                end = static_cast<int>(validNewRowIdx[b_i] + 2.0);
                if ((end < 1) || (end > i2)) {
                  rtDynamicBoundsError(end, 1, i2, md_emlrtBCI);
                }

                loop_ub_tmp = static_cast<int>(validNewRowIdx[b_i] + 1.0);
                if ((loop_ub_tmp < 1) || (loop_ub_tmp > i2)) {
                  rtDynamicBoundsError(loop_ub_tmp, 1, i2, nd_emlrtBCI);
                }

                num.set_size(1, 1, i3);
                for (int i7{0}; i7 < loop_ub; i7++) {
                  num[i7] = 2.0 * BoardCoords[BoardCoords.size(0) * (loop_ub_tmp
                    - 1) + BoardCoords.size(0) * BoardCoords.size(1) * i7];
                }

                if ((c_loop_ub != num.size(2)) && ((c_loop_ub != 1) && (num.size
                      (2) != 1))) {
                  emlrtDimSizeImpxCheckR2021b(c_loop_ub, num.size(2),
                    db_emlrtECI);
                }

                if (c_loop_ub == num.size(2)) {
                  num.set_size(1, 1, c_loop_ub);
                  for (int i7{0}; i7 < c_loop_ub; i7++) {
                    num[i7] = (BoardCoords[BoardCoords.size(0) *
                               (b_validNewRowIdx - 1) + BoardCoords.size(0) *
                               BoardCoords.size(1) * i7] +
                               BoardCoords[BoardCoords.size(0) * (end - 1) +
                               BoardCoords.size(0) * BoardCoords.size(1) * i7])
                      - num[i7];
                  }
                } else {
                  binary_expand_op(num, this, validNewRowIdx, b_i);
                }

                if (i4 < 1) {
                  rtDynamicBoundsError(1, 1, i4, tf_emlrtBCI);
                }

                if (b_validNewRowIdx > i5) {
                  rtDynamicBoundsError(b_validNewRowIdx, 1, i5, od_emlrtBCI);
                }

                if (end > i5) {
                  rtDynamicBoundsError(end, 1, i5, pd_emlrtBCI);
                }

                denom.set_size(1, 1, i6);
                for (int i7{0}; i7 < b_loop_ub; i7++) {
                  denom[i7] = BoardCoords[BoardCoords.size(0) *
                    (b_validNewRowIdx - 1) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i7] - BoardCoords[BoardCoords.size(0) *
                    (end - 1) + BoardCoords.size(0) * BoardCoords.size(1) * i7];
                }

                if (std::isnan(newEnergy)) {
                  s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
                }

                if (newEnergy != 0.0F) {
                  b_validNewRowIdx = num.size(2);
                  end = denom.size(2);
                  c_num = num.reshape(b_validNewRowIdx);
                  d_num = denom.reshape(end);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(newEnergy, static_cast<float>(y));
                } else {
                  b_validNewRowIdx = num.size(2);
                  end = denom.size(2);
                  c_num = num.reshape(b_validNewRowIdx);
                  d_num = denom.reshape(end);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
                }
              }
            }

            if (std::isnan(newEnergy)) {
              s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
            }

            newEnergy_tmp = static_cast<float>(BoardIdx.size(0) * BoardIdx.size
              (1));
            if (newEnergy != 0.0F) {
              newEnergy = newEnergy * newEnergy_tmp - newEnergy_tmp;
            } else {
              newEnergy = rtInfF;
            }

            return newEnergy;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                float oldEnergy
          // Return Type  : float
          //
          float Checkerboard::computeNewEnergyVertical(const ::coder::array<
            double, 2U> &idx, float oldEnergy) const
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              771,                     // lineNo
              87,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              772,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              773,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              773,                     // lineNo
              89,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              745,                     // lineNo
              42,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              745,                     // lineNo
              72,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              746,                     // lineNo
              35,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              751,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              751,                     // lineNo
              90,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              752,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              753,                     // lineNo
              54,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              753,                     // lineNo
              92,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              764,                     // lineNo
              45,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              771,                     // lineNo
              48,                      // colNo
              "",                      // aName
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 746,// lineNo
              31,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 751,// lineNo
              86,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 772,// lineNo
              46,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 752,// lineNo
              42,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo k_emlrtDCI{ 753,// lineNo
              88,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo l_emlrtDCI{ 753,// lineNo
              50,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo m_emlrtDCI{ 771,// lineNo
              44,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo n_emlrtDCI{ 764,// lineNo
              41,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo o_emlrtDCI{ 771,// lineNo
              83,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo p_emlrtDCI{ 773,// lineNo
              46,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo q_emlrtDCI{ 745,// lineNo
              38,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo r_emlrtDCI{ 745,// lineNo
              68,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo s_emlrtDCI{ 751,// lineNo
              48,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo t_emlrtDCI{ 773,// lineNo
              85,                      // colNo
              "Checkerboard/computeNewEnergyVertical",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            array<double, 3U> b;
            array<double, 3U> denom;
            array<double, 3U> num;
            array<double, 3U> r2;
            array<double, 3U> r3;
            array<double, 3U> r4;
            array<double, 2U> b_denom;
            array<double, 2U> b_num;
            array<double, 2U> validNewRowIdx;
            array<double, 1U> b_y;
            array<double, 1U> c_num;
            array<double, 1U> d_num;
            array<double, 1U> x;
            array<int, 2U> r1;
            array<bool, 2U> r;
            array<bool, 2U> validIdx;
            double y;
            float newEnergy;
            float newEnergy_tmp;
            int iv[3];
            int iv1[3];
            int b_idx;
            int b_loop_ub;
            int c_idx;
            int d_idx;
            int end;
            int i;
            int i1;
            int i2;
            int i3;
            int i4;
            int loop_ub;
            int loop_ub_tmp;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), eg_emlrtBCI);
            }

            i = static_cast<int>(std::floor(idx[0]));
            if (idx[0] != i) {
              rtIntegerError(idx[0], q_emlrtDCI);
            }

            i1 = BoardIdx.size(0);
            b_idx = static_cast<int>(idx[0]);
            if ((b_idx < 1) || (b_idx > i1)) {
              rtDynamicBoundsError(b_idx, 1, i1, wc_emlrtBCI);
            }

            validIdx.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              validIdx[i1] = (BoardIdx[(b_idx + BoardIdx.size(0) * i1) - 1] >
                              0.0);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), qf_emlrtBCI);
            }

            i1 = static_cast<int>(std::floor(idx[1]));
            if (idx[1] != i1) {
              rtIntegerError(idx[1], r_emlrtDCI);
            }

            i2 = BoardIdx.size(0);
            c_idx = static_cast<int>(idx[1]);
            if ((c_idx < 1) || (c_idx > i2)) {
              rtDynamicBoundsError(c_idx, 1, i2, xc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i2 = 0; i2 < loop_ub; i2++) {
              r[i2] = (BoardIdx[(c_idx + BoardIdx.size(0) * i2) - 1] > 0.0);
            }

            if (validIdx.size(1) != r.size(1)) {
              rtSizeEqNDCheck(validIdx.size(), r.size(), ab_emlrtECI);
            }

            validIdx.set_size(1, validIdx.size(1));
            loop_ub_tmp = validIdx.size(1) - 1;
            for (i2 = 0; i2 <= loop_ub_tmp; i2++) {
              validIdx[i2] = (validIdx[i2] && r[i2]);
            }

            if (idx.size(1) < 3) {
              rtDynamicBoundsError(3, 1, idx.size(1), rf_emlrtBCI);
            }

            i2 = static_cast<int>(std::floor(idx[2]));
            if (idx[2] != i2) {
              rtIntegerError(idx[2], g_emlrtDCI);
            }

            i3 = BoardIdx.size(0);
            d_idx = static_cast<int>(idx[2]);
            if ((d_idx < 1) || (d_idx > i3)) {
              rtDynamicBoundsError(d_idx, 1, i3, yc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i3 = 0; i3 < loop_ub; i3++) {
              r[i3] = (BoardIdx[(d_idx + BoardIdx.size(0) * i3) - 1] > 0.0);
            }

            if ((validIdx.size(1) != r.size(1)) && ((validIdx.size(1) != 1) &&
                 (r.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(validIdx.size(1), r.size(1),
                ab_emlrtECI);
            }

            if (validIdx.size(1) == r.size(1)) {
              validIdx.set_size(1, validIdx.size(1));
              for (i3 = 0; i3 <= loop_ub_tmp; i3++) {
                validIdx[i3] = (validIdx[i3] && r[i3]);
              }
            } else {
              b_and(validIdx, r);
            }

            newEnergy = 0.0F;
            if (b_any(validIdx)) {
              if (idx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, idx.size(1), sf_emlrtBCI);
              }

              end = validIdx.size(1) - 1;
              loop_ub_tmp = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  loop_ub_tmp++;
                }
              }

              r1.set_size(1, loop_ub_tmp);
              loop_ub_tmp = 0;
              for (int b_i{0}; b_i <= end; b_i++) {
                if (validIdx[b_i]) {
                  r1[loop_ub_tmp] = b_i;
                  loop_ub_tmp++;
                }
              }

              end = BoardCoords.size(1);
              if (idx[0] != i) {
                rtIntegerError(idx[0], s_emlrtDCI);
              }

              i3 = BoardCoords.size(0);
              if ((b_idx < 1) || (b_idx > i3)) {
                rtDynamicBoundsError(b_idx, 1, i3, ad_emlrtBCI);
              }

              r2.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i3 = 0; i3 < loop_ub; i3++) {
                b_loop_ub = r1.size(1);
                for (i4 = 0; i4 < b_loop_ub; i4++) {
                  if (r1[i4] > end - 1) {
                    rtDynamicBoundsError(r1[i4], 0, end - 1, qd_emlrtBCI);
                  }

                  r2[i4 + r2.size(1) * i3] = BoardCoords[((b_idx +
                    BoardCoords.size(0) * r1[i4]) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i3) - 1];
                }
              }

              if (idx.size(1) < 3) {
                rtDynamicBoundsError(3, 1, idx.size(1), tf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              if (idx[2] != i2) {
                rtIntegerError(idx[2], h_emlrtDCI);
              }

              i3 = BoardCoords.size(0);
              if (d_idx > i3) {
                rtDynamicBoundsError(d_idx, 1, i3, bd_emlrtBCI);
              }

              r3.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i3 = 0; i3 < loop_ub; i3++) {
                b_loop_ub = r1.size(1);
                for (i4 = 0; i4 < b_loop_ub; i4++) {
                  if (r1[i4] > end - 1) {
                    rtDynamicBoundsError(r1[i4], 0, end - 1, rd_emlrtBCI);
                  }

                  r3[i4 + r3.size(1) * i3] = BoardCoords[((d_idx +
                    BoardCoords.size(0) * r1[i4]) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i3) - 1];
                }
              }

              iv[0] = 1;
              iv[1] = r1.size(1);
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = r1.size(1);
              iv1[2] = BoardCoords.size(2);
              if (iv[2] != iv1[2]) {
                rtSizeEqNDCheck(&iv[0], &iv1[0], bb_emlrtECI);
              }

              if (idx.size(1) < 2) {
                rtDynamicBoundsError(2, 1, idx.size(1), uf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              if (idx[1] != i1) {
                rtIntegerError(idx[1], j_emlrtDCI);
              }

              i1 = BoardCoords.size(0);
              if (c_idx > i1) {
                rtDynamicBoundsError(c_idx, 1, i1, cd_emlrtBCI);
              }

              b.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_loop_ub = r1.size(1);
                for (i3 = 0; i3 < b_loop_ub; i3++) {
                  if (r1[i3] > end - 1) {
                    rtDynamicBoundsError(r1[i3], 0, end - 1, sd_emlrtBCI);
                  }

                  b[i3 + b.size(1) * i1] = BoardCoords[((c_idx +
                    BoardCoords.size(0) * r1[i3]) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1) - 1];
                }
              }

              loop_ub_tmp = b.size(1) * b.size(2);
              b.set_size(1, b.size(1), b.size(2));
              for (i1 = 0; i1 < loop_ub_tmp; i1++) {
                b[i1] = 2.0 * b[i1];
              }

              if ((r1.size(1) != b.size(1)) && ((r1.size(1) != 1) && (b.size(1)
                    != 1))) {
                emlrtDimSizeImpxCheckR2021b(r1.size(1), b.size(1), cb_emlrtECI);
              }

              i1 = BoardCoords.size(2);
              if ((i1 != b.size(2)) && ((i1 != 1) && (b.size(2) != 1))) {
                emlrtDimSizeImpxCheckR2021b(i1, b.size(2), bb_emlrtECI);
              }

              if ((r2.size(1) == b.size(1)) && (r2.size(2) == b.size(2))) {
                r4.set_size(1, r2.size(1), r2.size(2));
                for (i1 = 0; i1 < loop_ub_tmp; i1++) {
                  r4[i1] = (r2[i1] + r3[i1]) - b[i1];
                }

                squeeze(r4, b_num);
              } else {
                binary_expand_op(b_num, r2, r3, b);
              }

              if (idx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, idx.size(1), vf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              if (idx[0] != i) {
                rtIntegerError(idx[0], l_emlrtDCI);
              }

              r2.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_loop_ub = r1.size(1);
                for (i3 = 0; i3 < b_loop_ub; i3++) {
                  if (r1[i3] > end - 1) {
                    rtDynamicBoundsError(r1[i3], 0, end - 1, td_emlrtBCI);
                  }

                  r2[i3 + r2.size(1) * i1] = BoardCoords[((b_idx +
                    BoardCoords.size(0) * r1[i3]) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1) - 1];
                }
              }

              if (idx.size(1) < 3) {
                rtDynamicBoundsError(3, 1, idx.size(1), wf_emlrtBCI);
              }

              end = BoardCoords.size(1);
              if (idx[2] != i2) {
                rtIntegerError(idx[2], k_emlrtDCI);
              }

              r3.set_size(1, r1.size(1), BoardCoords.size(2));
              loop_ub = BoardCoords.size(2);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_loop_ub = r1.size(1);
                for (i2 = 0; i2 < b_loop_ub; i2++) {
                  if (r1[i2] > end - 1) {
                    rtDynamicBoundsError(r1[i2], 0, end - 1, ud_emlrtBCI);
                  }

                  r3[i2 + r3.size(1) * i1] = BoardCoords[((d_idx +
                    BoardCoords.size(0) * r1[i2]) + BoardCoords.size(0) *
                    BoardCoords.size(1) * i1) - 1];
                }
              }

              r4.set_size(1, r2.size(1), r2.size(2));
              for (i1 = 0; i1 < loop_ub_tmp; i1++) {
                r4[i1] = r2[i1] - r3[i1];
              }

              squeeze(r4, b_denom);
              if (b_num.size(1) > 1) {
                if (b_denom.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, b_denom.size(1), dd_emlrtBCI);
                }

                if (b_denom.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, b_denom.size(1), ed_emlrtBCI);
                }

                c_num.set_size(b_num.size(0));
                loop_ub = b_num.size(0);
                d_num.set_size(b_num.size(0));
                for (i1 = 0; i1 < loop_ub; i1++) {
                  c_num[i1] = b_num[i1];
                  d_num[i1] = b_num[i1 + b_num.size(0)];
                }

                b_hypot(c_num, d_num, x);
                c_num.set_size(b_denom.size(0));
                loop_ub = b_denom.size(0);
                d_num.set_size(b_denom.size(0));
                for (i1 = 0; i1 < loop_ub; i1++) {
                  c_num[i1] = b_denom[i1];
                  d_num[i1] = b_denom[i1 + b_denom.size(0)];
                }

                b_hypot(c_num, d_num, b_y);
                if ((x.size(0) != 1) && (b_y.size(0) != 1) && (x.size(0) !=
                     b_y.size(0))) {
                  j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
                }

                if (x.size(0) == b_y.size(0)) {
                  loop_ub = x.size(0);
                  for (i1 = 0; i1 < loop_ub; i1++) {
                    x[i1] = x[i1] / b_y[i1];
                  }

                  y = ::coder::internal::maximum(x);
                } else {
                  y = binary_expand_op(x, b_y);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
              } else {
                i1 = b_num.size(0) * b_num.size(1);
                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, fd_emlrtBCI);
                }

                if (i1 < 2) {
                  rtDynamicBoundsError(2, 1, 1, gd_emlrtBCI);
                }

                i1 = b_denom.size(0) * b_denom.size(1);
                if (i1 < 1) {
                  rtDynamicBoundsError(1, 1, i1, hd_emlrtBCI);
                }

                if (i1 < 2) {
                  rtDynamicBoundsError(2, 1, 1, id_emlrtBCI);
                }

                newEnergy = std::fmax(oldEnergy, static_cast<float>
                                      (rt_hypotd_snf(b_num[0], b_num[1]) /
                  rt_hypotd_snf(b_denom[0], b_denom[1])));
              }
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), xf_emlrtBCI);
            }

            if (idx[0] != i) {
              rtIntegerError(idx[0], n_emlrtDCI);
            }

            validIdx.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              validIdx[i1] = (BoardIdx[(b_idx + BoardIdx.size(0) * i1) - 1] >
                              0.0);
            }

            Checkerboard::arrayFind(validIdx, validNewRowIdx);
            if (validNewRowIdx.size(1) != 0) {
              int c_loop_ub;
              int i5;
              int i6;
              i1 = validNewRowIdx.size(1);
              loop_ub = BoardCoords.size(2);
              b_loop_ub = BoardCoords.size(2);
              i2 = BoardCoords.size(0);
              i3 = BoardCoords.size(1);
              i4 = BoardCoords.size(2);
              c_loop_ub = BoardCoords.size(2);
              i5 = BoardCoords.size(1);
              i6 = BoardCoords.size(2);
              for (int b_i{0}; b_i < i1; b_i++) {
                if (b_i + 1 > validNewRowIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, validNewRowIdx.size(1),
                                       jd_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), yf_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], m_emlrtDCI);
                }

                if ((b_idx < 1) || (b_idx > i2)) {
                  rtDynamicBoundsError(b_idx, 1, i2, kd_emlrtBCI);
                }

                d_idx = static_cast<int>(validNewRowIdx[b_i]);
                if ((d_idx < 1) || (d_idx > i3)) {
                  rtDynamicBoundsError(d_idx, 1, i3, ld_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), ag_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], o_emlrtDCI);
                }

                end = static_cast<int>(validNewRowIdx[b_i] + 2.0);
                if ((end < 1) || (end > i3)) {
                  rtDynamicBoundsError(end, 1, i3, md_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), bg_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], i_emlrtDCI);
                }

                loop_ub_tmp = static_cast<int>(validNewRowIdx[b_i] + 1.0);
                if ((loop_ub_tmp < 1) || (loop_ub_tmp > i3)) {
                  rtDynamicBoundsError(loop_ub_tmp, 1, i3, nd_emlrtBCI);
                }

                num.set_size(1, 1, i4);
                for (c_idx = 0; c_idx < loop_ub; c_idx++) {
                  num[c_idx] = 2.0 * BoardCoords[((b_idx + BoardCoords.size(0) *
                    (loop_ub_tmp - 1)) + BoardCoords.size(0) * BoardCoords.size
                    (1) * c_idx) - 1];
                }

                if ((c_loop_ub != num.size(2)) && ((c_loop_ub != 1) && (num.size
                      (2) != 1))) {
                  emlrtDimSizeImpxCheckR2021b(c_loop_ub, num.size(2),
                    db_emlrtECI);
                }

                if (c_loop_ub == num.size(2)) {
                  num.set_size(1, 1, c_loop_ub);
                  for (c_idx = 0; c_idx < c_loop_ub; c_idx++) {
                    num[c_idx] = (BoardCoords[((b_idx + BoardCoords.size(0) *
                      (d_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                      c_idx) - 1] + BoardCoords[((b_idx + BoardCoords.size(0) *
                      (end - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                      c_idx) - 1]) - num[c_idx];
                  }
                } else {
                  binary_expand_op(num, this, idx, validNewRowIdx, b_i);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), cg_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], p_emlrtDCI);
                }

                if (d_idx > i5) {
                  rtDynamicBoundsError(d_idx, 1, i5, od_emlrtBCI);
                }

                if (idx.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, idx.size(1), dg_emlrtBCI);
                }

                if (idx[0] != i) {
                  rtIntegerError(idx[0], t_emlrtDCI);
                }

                if (end > i5) {
                  rtDynamicBoundsError(end, 1, i5, pd_emlrtBCI);
                }

                denom.set_size(1, 1, i6);
                for (c_idx = 0; c_idx < b_loop_ub; c_idx++) {
                  denom[c_idx] = BoardCoords[((b_idx + BoardCoords.size(0) *
                    (d_idx - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                    c_idx) - 1] - BoardCoords[((b_idx + BoardCoords.size(0) *
                    (end - 1)) + BoardCoords.size(0) * BoardCoords.size(1) *
                    c_idx) - 1];
                }

                if (std::isnan(newEnergy)) {
                  s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
                }

                if (newEnergy != 0.0F) {
                  c_idx = num.size(2);
                  d_idx = denom.size(2);
                  c_num = num.reshape(c_idx);
                  d_num = denom.reshape(d_idx);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(newEnergy, static_cast<float>(y));
                } else {
                  c_idx = num.size(2);
                  d_idx = denom.size(2);
                  c_num = num.reshape(c_idx);
                  d_num = denom.reshape(d_idx);
                  y = b_norm(c_num) / b_norm(d_num);
                  newEnergy = std::fmax(oldEnergy, static_cast<float>(y));
                }
              }
            }

            if (std::isnan(newEnergy)) {
              s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
            }

            newEnergy_tmp = static_cast<float>(BoardIdx.size(0) * BoardIdx.size
              (1));
            if (newEnergy != 0.0F) {
              newEnergy = newEnergy * newEnergy_tmp - newEnergy_tmp;
            } else {
              newEnergy = rtInfF;
            }

            return newEnergy;
          }

          //
          // Arguments    : ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::d_fitPolynomialIndices(::coder::array<double, 2U>
            &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> c_this;
            array<double, 2U> removedIdx;
            array<int, 2U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            int b_this;
            int i;
            int k;
            int loop_ub;
            int n;
            b_findIndependentVar(coordsToUse);
            newIndices.set_size(1, BoardCoords.size(0));
            loop_ub = BoardCoords.size(0);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(0);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(0);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ab_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     bb_emlrtBCI);
              }

              b_index.set_size(1, BoardCoords.size(1));
              loop_ub = BoardCoords.size(1);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_index[i1] = BoardCoords[(j + BoardCoords.size(0) * i1) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(b_index, ii);
              if (ii.size(1) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                double refCoordValue;
                int currCurve_size[2];
                int coordDist_tmp;
                bool exitg1;
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, yd_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                k = ii[0];
                if ((k < 1) || (k > i1)) {
                  rtDynamicBoundsError(k, 1, i1, xd_emlrtBCI);
                }

                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, wd_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                k = ii[1];
                if ((k < 1) || (k > i1)) {
                  rtDynamicBoundsError(k, 1, i1, vd_emlrtBCI);
                }

                currRad = coordsToUse[0];
                coordDist_tmp = ii[0];
                coordDist = (BoardCoords[(j + BoardCoords.size(0) * (ii[0] - 1))
                             + BoardCoords.size(0) * BoardCoords.size(1) * (
                  static_cast<int>(coordsToUse[0]) - 1)] - BoardCoords[(j +
                  BoardCoords.size(0) * (ii[1] - 1)) + BoardCoords.size(0) *
                             BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)]) / (static_cast<double>(ii[1]) -
                  static_cast<double>(coordDist_tmp));
                n = 0;
                i1 = ii.size(1);
                for (k = 0; k < i1; k++) {
                  if (ii[k] != 0) {
                    n++;
                  }
                }

                b_this = BoardCoords.size(1);
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, eb_emlrtBCI);
                }

                k = BoardCoords.size(1);
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, gb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       hb_emlrtBCI);
                }

                b_index.set_size(1, ii.size(1));
                loop_ub = ii.size(1);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > b_this)) {
                    rtDynamicBoundsError(ii[i1], 1, b_this, ib_emlrtBCI);
                  }

                  b_index[i1] = BoardCoords[(j + BoardCoords.size(0) * (ii[i1] -
                    1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                    static_cast<int>(currRad) - 1)];
                }

                c_this.set_size(1, ii.size(1));
                loop_ub = ii.size(1);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > k)) {
                    rtDynamicBoundsError(ii[i1], 1, k, jb_emlrtBCI);
                  }

                  c_this[i1] = BoardCoords[(j + BoardCoords.size(0) * (ii[i1] -
                    1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                    static_cast<int>(coordsToUse[1]) - 1)];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(b_index, c_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(0);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, kb_emlrtBCI);
                }

                refCoordValue = BoardCoords[(j + BoardCoords.size(0) * (ii[0] -
                  1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                  static_cast<int>(coordsToUse[0]) - 1)];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     static_cast<double>(coordDist_tmp) * 1.5 *
                                     std::abs(coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  bool p;
                  p = true;
                  k = 0;
                  exitg2 = false;
                  while ((!exitg2) && (k < 2)) {
                    if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      k++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (k = 0; k < loop_ub; k++) {
                      removedIdx[i1 + k] = b_index[k];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }

            n = 0;
            i = newIndices.size(1);
            for (k = 0; k < i; k++) {
              if (newIndices[k] != 0.0) {
                n++;
              }
            }

            if (n < 4) {
              k = newIndices.size(1) - 1;
              for (b_this = 0; b_this <= k; b_this++) {
                if (newIndices[b_this] > 0.0) {
                  if (b_this > k) {
                    rtDynamicBoundsError(b_this, 0, k, lf_emlrtBCI);
                  }

                  newIndices[b_this] = 0.0;
                }
              }
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &indices
          //                ::coder::array<double, 2U> &newBoard
          //                ::coder::array<double, 3U> &newBoardCoords
          // Return Type  : void
          //
          void Checkerboard::expandBoardDown(const ::coder::array<double, 2U>
            &indices, ::coder::array<double, 2U> &newBoard, ::coder::array<
            double, 3U> &newBoardCoords) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              708,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              701,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              708,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              708,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              708,                     // lineNo
              60,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              710,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              702,                     // lineNo
              24,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 704,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 704,// lineNo
              36,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 700,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 700,// lineNo
              30,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              701,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              702,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ -1,// nDims
              708,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
              710,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardDown",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 2U> r2;
            array<int, 2U> r;
            array<int, 1U> r1;
            double d;
            int iv1[3];
            int iv[2];
            int b_loop_ub;
            int b_this;
            int end_tmp;
            int i;
            int i2;
            int loop_ub;
            d = static_cast<double>(BoardIdx.size(0)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, j_emlrtDCI);
            }

            newBoard.set_size(static_cast<int>(d), BoardIdx.size(1));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, i_emlrtDCI);
            }

            loop_ub = static_cast<int>(d) * BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i] = 0.0;
            }

            i = BoardIdx.size(0) + 1;
            if (i < 1) {
              rtDynamicBoundsError(i, 1, i, rf_emlrtBCI);
            }

            iv[0] = 1;
            iv[1] = BoardIdx.size(1);
            rtSubAssignSizeCheck(&iv[0], 2, ((::coder::array<double, 2U> *)
              &indices)->size(), 2, lb_emlrtECI);
            b_this = BoardIdx.size(0);
            loop_ub = indices.size(1);
            for (i = 0; i < loop_ub; i++) {
              newBoard[b_this + newBoard.size(0) * i] = indices[i];
            }

            if (newBoard.size(0) - 1 < 1) {
              i = 0;
            } else {
              if ((newBoard.size(0) - 1 < 1) || (newBoard.size(0) - 1 >
                   newBoard.size(0))) {
                rtDynamicBoundsError(newBoard.size(0) - 1, 1, newBoard.size(0),
                                     wf_emlrtBCI);
              }

              i = newBoard.size(0) - 1;
            }

            iv[0] = i;
            iv[1] = newBoard.size(1);
            rtSubAssignSizeCheck(&iv[0], 2, ((::coder::array<double, 2U> *)
              &BoardIdx)->size(), 2, mb_emlrtECI);
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = BoardIdx.size(0);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                newBoard[i1 + newBoard.size(0) * i] = BoardIdx[i1 +
                  BoardIdx.size(0) * i];
              }
            }

            d = static_cast<double>(BoardCoords.size(0)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, h_emlrtDCI);
            }

            newBoardCoords.set_size(static_cast<int>(d), BoardCoords.size(1),
              BoardCoords.size(2));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, g_emlrtDCI);
            }

            loop_ub = static_cast<int>(d) * BoardCoords.size(1) *
              BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              newBoardCoords[i] = 0.0;
            }

            i = BoardCoords.size(0) + 1;
            if (i < 1) {
              rtDynamicBoundsError(i, 1, i, qf_emlrtBCI);
            }

            end_tmp = indices.size(1) - 1;
            b_this = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                b_this++;
              }
            }

            r.set_size(1, b_this);
            b_this = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                r[b_this] = loop_ub;
                b_this++;
              }
            }

            b_this = BoardCoords.size(1);
            r1.set_size(r.size(1));
            loop_ub = r.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r[i] > b_this - 1) {
                rtDynamicBoundsError(r[i], 0, b_this - 1, sf_emlrtBCI);
              }

              r1[i] = r[i];
            }

            b_this = Points.size(0);
            r2.set_size(r.size(1), Points.size(1));
            loop_ub = Points.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = r.size(1);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                if (r[i1] > end_tmp) {
                  rtDynamicBoundsError(r[i1], 0, end_tmp, tf_emlrtBCI);
                }

                i2 = static_cast<int>(indices[r[i1]]);
                if ((i2 < 1) || (i2 > b_this)) {
                  rtDynamicBoundsError(i2, 1, b_this, uf_emlrtBCI);
                }

                r2[i1 + r2.size(0) * i] = Points[(i2 + Points.size(0) * i) - 1];
              }
            }

            iv1[0] = 1;
            iv1[1] = r1.size(0);
            iv1[2] = BoardCoords.size(2);
            rtSubAssignSizeCheck(&iv1[0], 3, r2.size(), 2, nb_emlrtECI);
            iv1[1] = r1.size(0);
            iv1[2] = BoardCoords.size(2);
            b_this = BoardCoords.size(0);
            loop_ub = iv1[2];
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = iv1[1];
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                newBoardCoords[(b_this + newBoardCoords.size(0) * r1[i1]) +
                  newBoardCoords.size(0) * newBoardCoords.size(1) * i] = r2[i1 +
                  iv1[1] * i];
              }
            }

            if (newBoardCoords.size(0) - 1 < 1) {
              i = 0;
            } else {
              if ((newBoardCoords.size(0) - 1 < 1) || (newBoardCoords.size(0) -
                   1 > newBoardCoords.size(0))) {
                rtDynamicBoundsError(newBoardCoords.size(0) - 1, 1,
                                     newBoardCoords.size(0), vf_emlrtBCI);
              }

              i = newBoardCoords.size(0) - 1;
            }

            iv1[0] = i;
            iv1[1] = newBoardCoords.size(1);
            iv1[2] = newBoardCoords.size(2);
            rtSubAssignSizeCheck(&iv1[0], 3, ((::coder::array<double, 3U> *)
              &BoardCoords)->size(), 3, ob_emlrtECI);
            loop_ub = BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = BoardCoords.size(1);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                b_this = BoardCoords.size(0);
                for (i2 = 0; i2 < b_this; i2++) {
                  newBoardCoords[(i2 + newBoardCoords.size(0) * i1) +
                    newBoardCoords.size(0) * newBoardCoords.size(1) * i] =
                    BoardCoords[(i2 + BoardCoords.size(0) * i1) +
                    BoardCoords.size(0) * BoardCoords.size(1) * i];
                }
              }
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &indices
          //                ::coder::array<double, 2U> &newBoard
          //                ::coder::array<double, 3U> &newBoardCoords
          // Return Type  : void
          //
          void Checkerboard::expandBoardLeft(const ::coder::array<double, 2U>
            &indices, ::coder::array<double, 2U> &newBoard, ::coder::array<
            double, 3U> &newBoardCoords) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              723,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              723,                     // lineNo
              66,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              723,                     // lineNo
              58,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 715,// lineNo
              54,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 715,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 720,// lineNo
              17,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 719,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              716,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              717,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ -1,// nDims
              723,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
              725,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardLeft",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 2U> r2;
            array<int, 2U> r;
            array<int, 1U> r1;
            double d;
            int b_newBoardCoords[3];
            int b_newBoard[2];
            int b_loop_ub;
            int end_tmp;
            int i;
            int i1;
            int i2;
            int loop_ub;
            int trueCount;
            newBoard.set_size(BoardIdx.size(0), newBoard.size(1));
            d = static_cast<double>(BoardIdx.size(1)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, g_emlrtDCI);
            }

            newBoard.set_size(newBoard.size(0), static_cast<int>(d));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, h_emlrtDCI);
            }

            loop_ub = BoardIdx.size(0) * static_cast<int>(d);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i] = 0.0;
            }

            rtSubAssignSizeCheck(((::coder::array<double, 2U> *)&BoardIdx)->size
                                 (), 1, ((::coder::array<double, 2U> *)&indices
                                 )->size(), 2, lb_emlrtECI);
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i] = indices[i];
            }

            if (newBoard.size(1) < 2) {
              i = 0;
              i1 = 0;
            } else {
              i = 1;
              i1 = newBoard.size(1);
            }

            b_newBoard[0] = newBoard.size(0);
            b_newBoard[1] = i1 - i;
            rtSubAssignSizeCheck(&b_newBoard[0], 2, ((::coder::array<double, 2U>
              *)&BoardIdx)->size(), 2, mb_emlrtECI);
            loop_ub = BoardIdx.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_loop_ub = BoardIdx.size(0);
              for (i2 = 0; i2 < b_loop_ub; i2++) {
                newBoard[i2 + newBoard.size(0) * (i + i1)] = BoardIdx[i2 +
                  BoardIdx.size(0) * i1];
              }
            }

            newBoardCoords.set_size(BoardCoords.size(0), newBoardCoords.size(1),
              newBoardCoords.size(2));
            d = static_cast<double>(BoardCoords.size(1)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, i_emlrtDCI);
            }

            newBoardCoords.set_size(newBoardCoords.size(0), static_cast<int>(d),
              BoardCoords.size(2));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, j_emlrtDCI);
            }

            loop_ub = BoardCoords.size(0) * static_cast<int>(d) *
              BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              newBoardCoords[i] = 0.0;
            }

            end_tmp = indices.size(1) - 1;
            trueCount = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                trueCount++;
              }
            }

            r.set_size(1, trueCount);
            trueCount = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                r[trueCount] = loop_ub;
                trueCount++;
              }
            }

            trueCount = BoardCoords.size(0);
            r1.set_size(r.size(1));
            loop_ub = r.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r[i] > trueCount - 1) {
                rtDynamicBoundsError(r[i], 0, trueCount - 1, qf_emlrtBCI);
              }

              r1[i] = r[i];
            }

            trueCount = Points.size(0);
            r2.set_size(r.size(1), Points.size(1));
            loop_ub = Points.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = r.size(1);
              for (i1 = 0; i1 < b_loop_ub; i1++) {
                if (r[i1] > end_tmp) {
                  rtDynamicBoundsError(r[i1], 0, end_tmp, rf_emlrtBCI);
                }

                i2 = static_cast<int>(indices[r[i1]]);
                if ((i2 < 1) || (i2 > trueCount)) {
                  rtDynamicBoundsError(i2, 1, trueCount, sf_emlrtBCI);
                }

                r2[i1 + r2.size(0) * i] = Points[(i2 + Points.size(0) * i) - 1];
              }
            }

            b_newBoardCoords[0] = r1.size(0);
            b_newBoardCoords[1] = 1;
            b_newBoardCoords[2] = BoardCoords.size(2);
            rtSubAssignSizeCheck(&b_newBoardCoords[0], 3, r2.size(), 2,
                                 nb_emlrtECI);
            b_newBoardCoords[0] = r1.size(0);
            b_newBoardCoords[2] = BoardCoords.size(2);
            loop_ub = b_newBoardCoords[2];
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = b_newBoardCoords[0];
              for (i1 = 0; i1 < b_loop_ub; i1++) {
                newBoardCoords[r1[i1] + newBoardCoords.size(0) *
                  newBoardCoords.size(1) * i] = r2[i1 + b_newBoardCoords[0] * i];
              }
            }

            if (newBoardCoords.size(1) < 2) {
              i = 0;
              i1 = 0;
            } else {
              i = 1;
              i1 = newBoardCoords.size(1);
            }

            b_newBoardCoords[0] = newBoardCoords.size(0);
            b_newBoardCoords[1] = i1 - i;
            b_newBoardCoords[2] = newBoardCoords.size(2);
            rtSubAssignSizeCheck(&b_newBoardCoords[0], 3, ((::coder::array<
              double, 3U> *)&BoardCoords)->size(), 3, ob_emlrtECI);
            loop_ub = BoardCoords.size(2);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_loop_ub = BoardCoords.size(1);
              for (i2 = 0; i2 < b_loop_ub; i2++) {
                trueCount = BoardCoords.size(0);
                for (end_tmp = 0; end_tmp < trueCount; end_tmp++) {
                  newBoardCoords[(end_tmp + newBoardCoords.size(0) * (i + i2)) +
                    newBoardCoords.size(0) * newBoardCoords.size(1) * i1] =
                    BoardCoords[(end_tmp + BoardCoords.size(0) * i2) +
                    BoardCoords.size(0) * BoardCoords.size(1) * i1];
                }
              }
            }
          }

          //
          // Arguments    : void
          // Return Type  : bool
          //
          bool Checkerboard::expandBoardOnce()
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              356,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              356,                     // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              337,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              337,                     // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              318,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              318,                     // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              375,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              375,                     // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardDirectionally",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 3U> b_this;
            array<double, 3U> c_this;
            array<double, 3U> r;
            array<double, 2U> b_p2;
            array<double, 2U> d_this;
            array<double, 2U> e_this;
            array<double, 2U> idx;
            array<double, 2U> newIndices;
            array<double, 2U> p1;
            array<double, 2U> p2;
            array<double, 2U> removedIdx;
            array<double, 2U> validIdx;
            array<int, 2U> ii;
            array<int, 2U> r1;
            array<int, 2U> r2;
            array<int, 2U> r3;
            array<int, 2U> r4;
            double currCurve_data[5];
            double currCoord;
            double moveDistMultiplier;
            int i;
            bool success;
            PreviousEnergy = Energy;
            i = 0;
            int exitg1;
            do {
              exitg1 = 0;
              if (i < 4) {
                if (!IsDirectionBad[i]) {
                  float oldEnergy;
                  LastExpandDirection = static_cast<double>(i) + 1.0;
                  oldEnergy = (Energy + static_cast<float>(BoardIdx.size(0) *
                    BoardIdx.size(1))) / static_cast<float>(BoardIdx.size(0) *
                    BoardIdx.size(1));
                  switch (i + 1) {
                   case 1:
                    {
                      int b_i;
                      int loop_ub;
                      if (IsDistortionHigh) {
                        fitPolynomialIndices(newIndices);
                        if (!all(newIndices)) {
                          int b_loop_ub;
                          int i1;
                          int n;
                          int numCols;
                          b_i = BoardCoords.size(0);
                          if (b_i < 2) {
                            rtDynamicBoundsError(2, 1, b_i, t_emlrtBCI);
                          }

                          b_this.set_size(1, BoardCoords.size(1),
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(1);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                                [(BoardCoords.size(0) * i1 + BoardCoords.size(0)
                                  * BoardCoords.size(1) * b_i) + 1];
                            }
                          }

                          squeeze(b_this, p1);
                          b_i = BoardCoords.size(0);
                          if (b_i < 1) {
                            rtDynamicBoundsError(1, 1, b_i, u_emlrtBCI);
                          }

                          b_this.set_size(1, BoardCoords.size(1),
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(1);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              b_this[i1 + b_this.size(1) * b_i] =
                                BoardCoords[BoardCoords.size(0) * i1 +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                            }
                          }

                          squeeze(b_this, p2);
                          if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                               (p1.size(0) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                              t_emlrtECI);
                          }

                          if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                               (p1.size(1) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                              u_emlrtECI);
                          }

                          if ((p2.size(0) == p1.size(0)) && (p2.size(1) ==
                               p1.size(1))) {
                            b_p2.set_size(p2.size(0), p2.size(1));
                            loop_ub = p2.size(0) * p2.size(1);
                            for (b_i = 0; b_i < loop_ub; b_i++) {
                              b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                            }

                            findClosestIndices(b_p2, validIdx);
                          } else {
                            binary_expand_op(validIdx, this, p2, p1);
                          }

                          n = newIndices.size(1) - 1;
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              numCols++;
                            }
                          }

                          r1.set_size(1, numCols);
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              r1[numCols] = b_loop_ub;
                              numCols++;
                            }
                          }

                          loop_ub = r1.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            if ((r1[b_i] < 0) || (r1[b_i] > validIdx.size(1) - 1))
                            {
                              rtDynamicBoundsError(r1[b_i], 0, validIdx.size(1)
                                                   - 1, uf_emlrtBCI);
                            }
                          }

                          loop_ub = r1.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            i1 = r1[b_i];
                            if ((i1 < 0) || (i1 > n)) {
                              rtDynamicBoundsError(i1, 0, n, vf_emlrtBCI);
                            }

                            newIndices[i1] = validIdx[i1];
                          }
                        }
                      } else {
                        int b_loop_ub;
                        b_i = BoardCoords.size(0);
                        if (b_i < 2) {
                          rtDynamicBoundsError(2, 1, b_i, t_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [(BoardCoords.size(0) * i1 + BoardCoords.size(0) *
                                BoardCoords.size(1) * b_i) + 1];
                          }
                        }

                        squeeze(b_this, p1);
                        b_i = BoardCoords.size(0);
                        if (b_i < 1) {
                          rtDynamicBoundsError(1, 1, b_i, u_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] =
                              BoardCoords[BoardCoords.size(0) * i1 +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        squeeze(b_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            t_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            u_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          b_p2.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }

                          findClosestIndices(b_p2, newIndices);
                        } else {
                          binary_expand_op(newIndices, this, p2, p1);
                        }
                      }

                      expandBoardUp(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      oldEnergy = computeNewEnergyVertical(oldEnergy);
                    }
                    break;

                   case 2:
                    {
                      int b_i;
                      int loop_ub;
                      int numCols;
                      numCols = BoardCoords.size(0);
                      if (numCols < numCols - 2) {
                        idx.set_size(1, 0);
                      } else {
                        idx.set_size(1, 3);
                        for (b_i = 0; b_i < 3; b_i++) {
                          idx[b_i] = numCols - b_i;
                        }
                      }

                      if (IsDistortionHigh) {
                        fitPolynomialIndices(idx, newIndices);
                        if (!all(newIndices)) {
                          int b_loop_ub;
                          int i1;
                          int n;
                          if (idx.size(1) < 2) {
                            rtDynamicBoundsError(2, 1, idx.size(1), cb_emlrtBCI);
                          }

                          if (idx[1] != idx[1]) {
                            rtIntegerError(idx[1], d_emlrtDCI);
                          }

                          b_i = BoardCoords.size(0);
                          numCols = static_cast<int>(idx[1]);
                          if ((numCols < 1) || (numCols > b_i)) {
                            rtDynamicBoundsError(numCols, 1, b_i, t_emlrtBCI);
                          }

                          b_this.set_size(1, BoardCoords.size(1),
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(1);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                                [((numCols + BoardCoords.size(0) * i1) +
                                  BoardCoords.size(0) * BoardCoords.size(1) *
                                  b_i) - 1];
                            }
                          }

                          squeeze(b_this, p1);
                          if (idx.size(1) < 1) {
                            rtDynamicBoundsError(1, 1, idx.size(1), db_emlrtBCI);
                          }

                          if (idx[0] != idx[0]) {
                            rtIntegerError(idx[0], e_emlrtDCI);
                          }

                          b_i = BoardCoords.size(0);
                          numCols = static_cast<int>(idx[0]);
                          if ((numCols < 1) || (numCols > b_i)) {
                            rtDynamicBoundsError(numCols, 1, b_i, u_emlrtBCI);
                          }

                          b_this.set_size(1, BoardCoords.size(1),
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(1);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                                [((numCols + BoardCoords.size(0) * i1) +
                                  BoardCoords.size(0) * BoardCoords.size(1) *
                                  b_i) - 1];
                            }
                          }

                          squeeze(b_this, p2);
                          if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                               (p1.size(0) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                              t_emlrtECI);
                          }

                          if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                               (p1.size(1) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                              u_emlrtECI);
                          }

                          if ((p2.size(0) == p1.size(0)) && (p2.size(1) ==
                               p1.size(1))) {
                            b_p2.set_size(p2.size(0), p2.size(1));
                            loop_ub = p2.size(0) * p2.size(1);
                            for (b_i = 0; b_i < loop_ub; b_i++) {
                              b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                            }

                            findClosestIndices(b_p2, validIdx);
                          } else {
                            binary_expand_op(validIdx, this, p2, p1);
                          }

                          n = newIndices.size(1) - 1;
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              numCols++;
                            }
                          }

                          r3.set_size(1, numCols);
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              r3[numCols] = b_loop_ub;
                              numCols++;
                            }
                          }

                          loop_ub = r3.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            if ((r3[b_i] < 0) || (r3[b_i] > validIdx.size(1) - 1))
                            {
                              rtDynamicBoundsError(r3[b_i], 0, validIdx.size(1)
                                                   - 1, sf_emlrtBCI);
                            }
                          }

                          loop_ub = r3.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            i1 = r3[b_i];
                            if ((i1 < 0) || (i1 > n)) {
                              rtDynamicBoundsError(i1, 0, n, tf_emlrtBCI);
                            }

                            newIndices[i1] = validIdx[i1];
                          }
                        }
                      } else {
                        int b_loop_ub;
                        if (idx.size(1) < 2) {
                          rtDynamicBoundsError(2, 1, idx.size(1), cb_emlrtBCI);
                        }

                        if (idx[1] != idx[1]) {
                          rtIntegerError(idx[1], d_emlrtDCI);
                        }

                        b_i = BoardCoords.size(0);
                        numCols = static_cast<int>(idx[1]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, t_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [((numCols + BoardCoords.size(0) * i1) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i)
                              - 1];
                          }
                        }

                        squeeze(b_this, p1);
                        if (idx.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, idx.size(1), db_emlrtBCI);
                        }

                        if (idx[0] != idx[0]) {
                          rtIntegerError(idx[0], e_emlrtDCI);
                        }

                        b_i = BoardCoords.size(0);
                        numCols = static_cast<int>(idx[0]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, u_emlrtBCI);
                        }

                        b_this.set_size(1, BoardCoords.size(1), BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(1);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            b_this[i1 + b_this.size(1) * b_i] = BoardCoords
                              [((numCols + BoardCoords.size(0) * i1) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i)
                              - 1];
                          }
                        }

                        squeeze(b_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            t_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            u_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          b_p2.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }

                          findClosestIndices(b_p2, newIndices);
                        } else {
                          binary_expand_op(newIndices, this, p2, p1);
                        }
                      }

                      expandBoardDown(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      idx.set_size(1, idx.size(1));
                      loop_ub = idx.size(1) - 1;
                      for (b_i = 0; b_i <= loop_ub; b_i++) {
                        idx[b_i] = idx[b_i] + 1.0;
                      }

                      oldEnergy = computeNewEnergyVertical(idx, oldEnergy);
                    }
                    break;

                   case 3:
                    {
                      int b_i;
                      int loop_ub;
                      if (IsDistortionHigh) {
                        b_fitPolynomialIndices(newIndices);
                        if (!all(newIndices)) {
                          int b_loop_ub;
                          int i1;
                          int n;
                          int numCols;
                          b_i = BoardCoords.size(1);
                          if (b_i < 2) {
                            rtDynamicBoundsError(2, 1, b_i, v_emlrtBCI);
                          }

                          c_this.set_size(BoardCoords.size(0), 1,
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(0);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              c_this[i1 + c_this.size(0) * b_i] = BoardCoords
                                [(i1 + BoardCoords.size(0)) + BoardCoords.size(0)
                                * BoardCoords.size(1) * b_i];
                            }
                          }

                          b_squeeze(c_this, p1);
                          b_i = BoardCoords.size(1);
                          if (b_i < 1) {
                            rtDynamicBoundsError(1, 1, b_i, w_emlrtBCI);
                          }

                          c_this.set_size(BoardCoords.size(0), 1,
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(0);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              c_this[i1 + c_this.size(0) * b_i] = BoardCoords[i1
                                + BoardCoords.size(0) * BoardCoords.size(1) *
                                b_i];
                            }
                          }

                          b_squeeze(c_this, p2);
                          if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                               (p1.size(0) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                              v_emlrtECI);
                          }

                          if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                               (p1.size(1) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                              w_emlrtECI);
                          }

                          if ((p2.size(0) == p1.size(0)) && (p2.size(1) ==
                               p1.size(1))) {
                            b_p2.set_size(p2.size(0), p2.size(1));
                            loop_ub = p2.size(0) * p2.size(1);
                            for (b_i = 0; b_i < loop_ub; b_i++) {
                              b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                            }

                            findClosestIndices(b_p2, validIdx);
                          } else {
                            binary_expand_op(validIdx, this, p2, p1);
                          }

                          n = newIndices.size(1) - 1;
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              numCols++;
                            }
                          }

                          r2.set_size(1, numCols);
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              r2[numCols] = b_loop_ub;
                              numCols++;
                            }
                          }

                          loop_ub = r2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            if ((r2[b_i] < 0) || (r2[b_i] > validIdx.size(1) - 1))
                            {
                              rtDynamicBoundsError(r2[b_i], 0, validIdx.size(1)
                                                   - 1, qf_emlrtBCI);
                            }
                          }

                          loop_ub = r2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            i1 = r2[b_i];
                            if ((i1 < 0) || (i1 > n)) {
                              rtDynamicBoundsError(i1, 0, n, rf_emlrtBCI);
                            }

                            newIndices[i1] = validIdx[i1];
                          }
                        }
                      } else {
                        int b_loop_ub;
                        b_i = BoardCoords.size(1);
                        if (b_i < 2) {
                          rtDynamicBoundsError(2, 1, b_i, v_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0)) + BoardCoords.size(0) *
                              BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p1);
                        b_i = BoardCoords.size(1);
                        if (b_i < 1) {
                          rtDynamicBoundsError(1, 1, b_i, w_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[i1 +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            v_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            w_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          b_p2.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }

                          findClosestIndices(b_p2, newIndices);
                        } else {
                          binary_expand_op(newIndices, this, p2, p1);
                        }
                      }

                      expandBoardLeft(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      oldEnergy = computeNewEnergyHorizontal(oldEnergy);
                    }
                    break;

                   default:
                    {
                      int b_i;
                      int loop_ub;
                      int numCols;
                      numCols = BoardCoords.size(1);
                      if (numCols < numCols - 2) {
                        idx.set_size(1, 0);
                      } else {
                        idx.set_size(1, 3);
                        for (b_i = 0; b_i < 3; b_i++) {
                          idx[b_i] = numCols - b_i;
                        }
                      }

                      if (IsDistortionHigh) {
                        double coordsToUse[2];
                        int b_loop_ub;
                        int i1;
                        int n;
                        b_findIndependentVar(idx, coordsToUse);
                        newIndices.set_size(1, BoardCoords.size(0));
                        loop_ub = BoardCoords.size(0);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          newIndices[b_i] = 0.0;
                        }

                        removedIdx.set_size(1, 0);
                        b_i = newIndices.size(1);
                        for (int j{0}; j < b_i; j++) {
                          double refCoordValue;
                          i1 = BoardCoords.size(0);
                          if (j + 1 > i1) {
                            rtDynamicBoundsError(j + 1, 1, i1, ab_emlrtBCI);
                          }

                          i1 = BoardCoords.size(2);
                          refCoordValue = coordsToUse[0];
                          if ((static_cast<int>(coordsToUse[0]) < 1) || (
                               static_cast<int>(coordsToUse[0]) > i1)) {
                            rtDynamicBoundsError(static_cast<int>(coordsToUse[0]),
                                                 1, i1, bb_emlrtBCI);
                          }

                          validIdx.set_size(1, BoardCoords.size(1));
                          loop_ub = BoardCoords.size(1);
                          for (i1 = 0; i1 < loop_ub; i1++) {
                            validIdx[i1] = BoardCoords[(j + BoardCoords.size(0) *
                              i1) + BoardCoords.size(0) * BoardCoords.size(1) *
                              (static_cast<int>(refCoordValue) - 1)];
                          }

                          eml_find(validIdx, ii);
                          validIdx.set_size(1, ii.size(1));
                          loop_ub = ii.size(1);
                          for (i1 = 0; i1 < loop_ub; i1++) {
                            validIdx[i1] = ii[i1];
                          }

                          if (validIdx.size(1) >= 2) {
                            double coordDist;
                            double currRad;
                            int currCurve_size[2];
                            int i2;
                            bool exitg2;
                            coordDist = findSearchParams(idx, validIdx,
                              static_cast<double>(j) + 1.0, coordsToUse,
                              moveDistMultiplier, currCoord);
                            n = 0;
                            i1 = validIdx.size(1);
                            for (numCols = 0; numCols < i1; numCols++) {
                              if (static_cast<int>(validIdx[numCols]) != 0) {
                                n++;
                              }
                            }

                            numCols = BoardCoords.size(1);
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, eb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            if ((static_cast<int>(coordsToUse[0]) < 1) || (
                                 static_cast<int>(coordsToUse[0]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [0]), 1, i1, fb_emlrtBCI);
                            }

                            b_loop_ub = BoardCoords.size(1);
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, gb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            refCoordValue = coordsToUse[1];
                            if ((static_cast<int>(coordsToUse[1]) < 1) || (
                                 static_cast<int>(coordsToUse[1]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [1]), 1, i1, hb_emlrtBCI);
                            }

                            d_this.set_size(1, validIdx.size(1));
                            loop_ub = validIdx.size(1);
                            for (i1 = 0; i1 < loop_ub; i1++) {
                              i2 = static_cast<int>(validIdx[i1]);
                              if ((i2 < 1) || (i2 > numCols)) {
                                rtDynamicBoundsError(i2, 1, numCols, ib_emlrtBCI);
                              }

                              d_this[i1] = BoardCoords[(j + BoardCoords.size(0) *
                                (i2 - 1)) + BoardCoords.size(0) *
                                BoardCoords.size(1) * (static_cast<int>
                                (coordsToUse[0]) - 1)];
                            }

                            e_this.set_size(1, validIdx.size(1));
                            loop_ub = validIdx.size(1);
                            for (i1 = 0; i1 < loop_ub; i1++) {
                              i2 = static_cast<int>(validIdx[i1]);
                              if ((i2 < 1) || (i2 > b_loop_ub)) {
                                rtDynamicBoundsError(i2, 1, b_loop_ub,
                                                     jb_emlrtBCI);
                              }

                              e_this[i1] = BoardCoords[(j + BoardCoords.size(0) *
                                (i2 - 1)) + BoardCoords.size(0) *
                                BoardCoords.size(1) * (static_cast<int>
                                (refCoordValue) - 1)];
                            }

                            if (n > 5) {
                              i1 = 4;
                            } else {
                              i1 = 2;
                            }

                            polyfit(d_this, e_this, static_cast<double>(i1),
                                    currCurve_data, currCurve_size);
                            currRad = coordDist / 4.0;
                            i1 = BoardCoords.size(0);
                            if (j + 1 > i1) {
                              rtDynamicBoundsError(j + 1, 1, i1, kb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(1);
                            if ((static_cast<int>(currCoord) < 1) || (
                                 static_cast<int>(currCoord) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(currCoord),
                                                   1, i1, lb_emlrtBCI);
                            }

                            i1 = BoardCoords.size(2);
                            if ((static_cast<int>(coordsToUse[0]) < 1) || (
                                 static_cast<int>(coordsToUse[0]) > i1)) {
                              rtDynamicBoundsError(static_cast<int>(coordsToUse
                                [0]), 1, i1, mb_emlrtBCI);
                            }

                            refCoordValue = BoardCoords[(j + BoardCoords.size(0)
                              * (static_cast<int>(currCoord) - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * (
                              static_cast<int>(coordsToUse[0]) - 1)];
                            currCoord = currRad + refCoordValue;
                            exitg2 = false;
                            while ((!exitg2) && (std::abs(currCoord -
                                     refCoordValue) < moveDistMultiplier * 1.5 *
                                                 std::abs(coordDist))) {
                              double currPt[2];
                              bool exitg3;
                              bool p;
                              p = true;
                              numCols = 0;
                              exitg3 = false;
                              while ((!exitg3) && (numCols < 2)) {
                                if (!(coordsToUse[numCols] == static_cast<double>
                                      (numCols) + 1.0)) {
                                  p = false;
                                  exitg3 = true;
                                } else {
                                  numCols++;
                                }
                              }

                              if (p) {
                                double y;
                                y = currCurve_data[0];
                                i1 = currCurve_size[1];
                                for (numCols = 0; numCols <= i1 - 2; numCols++)
                                {
                                  y = currCoord * y + currCurve_data[numCols + 1];
                                }

                                currPt[0] = currCoord;
                                currPt[1] = y;
                              } else {
                                double y;
                                y = currCurve_data[0];
                                i1 = currCurve_size[1];
                                for (numCols = 0; numCols <= i1 - 2; numCols++)
                                {
                                  y = currCoord * y + currCurve_data[numCols + 1];
                                }

                                currPt[0] = y;
                                currPt[1] = currCoord;
                              }

                              findClosestOnCurve(currPt, std::abs(currRad),
                                                 currCurve_data, currCurve_size,
                                                 coordsToUse, removedIdx,
                                                 validIdx);
                              if (validIdx.size(1) != 0) {
                                if (validIdx.size(1) != 1) {
                                  rtSizeEq1DError(1, validIdx.size(1),
                                                  x_emlrtECI);
                                }

                                if (j + 1 > newIndices.size(1)) {
                                  rtDynamicBoundsError(j + 1, 1, newIndices.size
                                                       (1), nb_emlrtBCI);
                                }

                                newIndices[j] = validIdx[0];
                                i1 = removedIdx.size(1);
                                loop_ub = validIdx.size(1);
                                removedIdx.set_size(removedIdx.size(0),
                                                    removedIdx.size(1) +
                                                    validIdx.size(1));
                                for (i2 = 0; i2 < loop_ub; i2++) {
                                  removedIdx[i1 + i2] = validIdx[i2];
                                }

                                exitg2 = true;
                              } else {
                                currCoord += currRad;
                              }
                            }
                          }
                        }

                        if (!all(newIndices)) {
                          if (idx.size(1) < 2) {
                            rtDynamicBoundsError(2, 1, idx.size(1), x_emlrtBCI);
                          }

                          if (idx[1] != idx[1]) {
                            rtIntegerError(idx[1], b_emlrtDCI);
                          }

                          b_i = BoardCoords.size(1);
                          numCols = static_cast<int>(idx[1]);
                          if ((numCols < 1) || (numCols > b_i)) {
                            rtDynamicBoundsError(numCols, 1, b_i, v_emlrtBCI);
                          }

                          c_this.set_size(BoardCoords.size(0), 1,
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(0);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              c_this[i1 + c_this.size(0) * b_i] = BoardCoords
                                [(i1 + BoardCoords.size(0) * (numCols - 1)) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                            }
                          }

                          b_squeeze(c_this, p1);
                          if (idx.size(1) < 1) {
                            rtDynamicBoundsError(1, 1, idx.size(1), y_emlrtBCI);
                          }

                          if (idx[0] != idx[0]) {
                            rtIntegerError(idx[0], c_emlrtDCI);
                          }

                          b_i = BoardCoords.size(1);
                          numCols = static_cast<int>(idx[0]);
                          if ((numCols < 1) || (numCols > b_i)) {
                            rtDynamicBoundsError(numCols, 1, b_i, w_emlrtBCI);
                          }

                          c_this.set_size(BoardCoords.size(0), 1,
                                          BoardCoords.size(2));
                          loop_ub = BoardCoords.size(2);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_loop_ub = BoardCoords.size(0);
                            for (i1 = 0; i1 < b_loop_ub; i1++) {
                              c_this[i1 + c_this.size(0) * b_i] = BoardCoords
                                [(i1 + BoardCoords.size(0) * (numCols - 1)) +
                                BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                            }
                          }

                          b_squeeze(c_this, p2);
                          if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                               (p1.size(0) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                              v_emlrtECI);
                          }

                          if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                               (p1.size(1) != 1))) {
                            emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                              w_emlrtECI);
                          }

                          if ((p2.size(0) == p1.size(0)) && (p2.size(1) ==
                               p1.size(1))) {
                            b_p2.set_size(p2.size(0), p2.size(1));
                            loop_ub = p2.size(0) * p2.size(1);
                            for (b_i = 0; b_i < loop_ub; b_i++) {
                              b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                            }

                            findClosestIndices(b_p2, validIdx);
                          } else {
                            binary_expand_op(validIdx, this, p2, p1);
                          }

                          n = newIndices.size(1) - 1;
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              numCols++;
                            }
                          }

                          r4.set_size(1, numCols);
                          numCols = 0;
                          for (b_loop_ub = 0; b_loop_ub <= n; b_loop_ub++) {
                            if (newIndices[b_loop_ub] == 0.0) {
                              r4[numCols] = b_loop_ub;
                              numCols++;
                            }
                          }

                          loop_ub = r4.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            if ((r4[b_i] < 0) || (r4[b_i] > validIdx.size(1) - 1))
                            {
                              rtDynamicBoundsError(r4[b_i], 0, validIdx.size(1)
                                                   - 1, wf_emlrtBCI);
                            }
                          }

                          loop_ub = r4.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            i1 = r4[b_i];
                            if ((i1 < 0) || (i1 > n)) {
                              rtDynamicBoundsError(i1, 0, n, xf_emlrtBCI);
                            }

                            newIndices[i1] = validIdx[i1];
                          }
                        }
                      } else {
                        int b_loop_ub;
                        if (idx.size(1) < 2) {
                          rtDynamicBoundsError(2, 1, idx.size(1), x_emlrtBCI);
                        }

                        if (idx[1] != idx[1]) {
                          rtIntegerError(idx[1], b_emlrtDCI);
                        }

                        b_i = BoardCoords.size(1);
                        numCols = static_cast<int>(idx[1]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, v_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0) * (numCols - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p1);
                        if (idx.size(1) < 1) {
                          rtDynamicBoundsError(1, 1, idx.size(1), y_emlrtBCI);
                        }

                        if (idx[0] != idx[0]) {
                          rtIntegerError(idx[0], c_emlrtDCI);
                        }

                        b_i = BoardCoords.size(1);
                        numCols = static_cast<int>(idx[0]);
                        if ((numCols < 1) || (numCols > b_i)) {
                          rtDynamicBoundsError(numCols, 1, b_i, w_emlrtBCI);
                        }

                        c_this.set_size(BoardCoords.size(0), 1, BoardCoords.size
                                        (2));
                        loop_ub = BoardCoords.size(2);
                        for (b_i = 0; b_i < loop_ub; b_i++) {
                          b_loop_ub = BoardCoords.size(0);
                          for (int i1{0}; i1 < b_loop_ub; i1++) {
                            c_this[i1 + c_this.size(0) * b_i] = BoardCoords[(i1
                              + BoardCoords.size(0) * (numCols - 1)) +
                              BoardCoords.size(0) * BoardCoords.size(1) * b_i];
                          }
                        }

                        b_squeeze(c_this, p2);
                        if ((p2.size(0) != p1.size(0)) && ((p2.size(0) != 1) &&
                             (p1.size(0) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(0), p1.size(0),
                            v_emlrtECI);
                        }

                        if ((p2.size(1) != p1.size(1)) && ((p2.size(1) != 1) &&
                             (p1.size(1) != 1))) {
                          emlrtDimSizeImpxCheckR2021b(p2.size(1), p1.size(1),
                            w_emlrtECI);
                        }

                        if ((p2.size(0) == p1.size(0)) && (p2.size(1) == p1.size
                             (1))) {
                          b_p2.set_size(p2.size(0), p2.size(1));
                          loop_ub = p2.size(0) * p2.size(1);
                          for (b_i = 0; b_i < loop_ub; b_i++) {
                            b_p2[b_i] = (p2[b_i] + p2[b_i]) - p1[b_i];
                          }

                          findClosestIndices(b_p2, newIndices);
                        } else {
                          binary_expand_op(newIndices, this, p2, p1);
                        }
                      }

                      expandBoardRight(newIndices, p1, r);
                      BoardIdx.set_size(p1.size(0), p1.size(1));
                      loop_ub = p1.size(0) * p1.size(1);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardIdx[b_i] = p1[b_i];
                      }

                      BoardCoords.set_size(r.size(0), r.size(1), r.size(2));
                      loop_ub = r.size(0) * r.size(1) * r.size(2);
                      for (b_i = 0; b_i < loop_ub; b_i++) {
                        BoardCoords[b_i] = r[b_i];
                      }

                      idx.set_size(1, idx.size(1));
                      loop_ub = idx.size(1) - 1;
                      for (b_i = 0; b_i <= loop_ub; b_i++) {
                        idx[b_i] = idx[b_i] + 1.0;
                      }

                      oldEnergy = computeNewEnergyHorizontal(idx, oldEnergy);
                    }
                    break;
                  }

                  Energy = oldEnergy;
                  if (Energy < PreviousEnergy) {
                    success = true;
                    exitg1 = 1;
                  } else {
                    undoLastExpansion();
                    IsDirectionBad[i] = true;
                    i++;
                  }
                } else {
                  i++;
                }
              } else {
                success = false;
                exitg1 = 1;
              }
            } while (exitg1 == 0);

            return success;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &indices
          //                ::coder::array<double, 2U> &newBoard
          //                ::coder::array<double, 3U> &newBoardCoords
          // Return Type  : void
          //
          void Checkerboard::expandBoardRight(const ::coder::array<double, 2U>
            &indices, ::coder::array<double, 2U> &newBoard, ::coder::array<
            double, 3U> &newBoardCoords) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              731,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              738,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              738,                     // lineNo
              38,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              738,                     // lineNo
              68,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              738,                     // lineNo
              60,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              740,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              732,                     // lineNo
              27,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 730,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 730,// lineNo
              54,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 735,// lineNo
              17,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 734,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              731,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              732,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ -1,// nDims
              738,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
              740,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardRight",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 2U> r2;
            array<int, 2U> r;
            array<int, 1U> r1;
            double d;
            int b_newBoardCoords[3];
            int b_newBoard[2];
            int b_loop_ub;
            int b_this;
            int end_tmp;
            int i;
            int i2;
            int loop_ub;
            newBoard.set_size(BoardIdx.size(0), newBoard.size(1));
            d = static_cast<double>(BoardIdx.size(1)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, h_emlrtDCI);
            }

            newBoard.set_size(newBoard.size(0), static_cast<int>(d));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, g_emlrtDCI);
            }

            loop_ub = BoardIdx.size(0) * static_cast<int>(d);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i] = 0.0;
            }

            i = BoardIdx.size(1) + 1;
            if (i < 1) {
              rtDynamicBoundsError(i, 1, i, qf_emlrtBCI);
            }

            rtSubAssignSizeCheck(((::coder::array<double, 2U> *)&BoardIdx)->size
                                 (), 1, ((::coder::array<double, 2U> *)&indices
                                 )->size(), 2, lb_emlrtECI);
            b_this = BoardIdx.size(1);
            loop_ub = BoardIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i + newBoard.size(0) * b_this] = indices[i];
            }

            if (newBoard.size(1) - 1 < 1) {
              i = 0;
            } else {
              if ((newBoard.size(1) - 1 < 1) || (newBoard.size(1) - 1 >
                   newBoard.size(1))) {
                rtDynamicBoundsError(newBoard.size(1) - 1, 1, newBoard.size(1),
                                     wf_emlrtBCI);
              }

              i = newBoard.size(1) - 1;
            }

            b_newBoard[0] = newBoard.size(0);
            b_newBoard[1] = i;
            rtSubAssignSizeCheck(&b_newBoard[0], 2, ((::coder::array<double, 2U>
              *)&BoardIdx)->size(), 2, mb_emlrtECI);
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = BoardIdx.size(0);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                newBoard[i1 + newBoard.size(0) * i] = BoardIdx[i1 +
                  BoardIdx.size(0) * i];
              }
            }

            newBoardCoords.set_size(BoardCoords.size(0), newBoardCoords.size(1),
              newBoardCoords.size(2));
            d = static_cast<double>(BoardCoords.size(1)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, i_emlrtDCI);
            }

            newBoardCoords.set_size(newBoardCoords.size(0), static_cast<int>(d),
              BoardCoords.size(2));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, j_emlrtDCI);
            }

            loop_ub = BoardCoords.size(0) * static_cast<int>(d) *
              BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              newBoardCoords[i] = 0.0;
            }

            end_tmp = indices.size(1) - 1;
            b_this = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                b_this++;
              }
            }

            r.set_size(1, b_this);
            b_this = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                r[b_this] = loop_ub;
                b_this++;
              }
            }

            b_this = BoardCoords.size(0);
            r1.set_size(r.size(1));
            loop_ub = r.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r[i] > b_this - 1) {
                rtDynamicBoundsError(r[i], 0, b_this - 1, rf_emlrtBCI);
              }

              r1[i] = r[i];
            }

            i = BoardCoords.size(1) + 1;
            if (i < 1) {
              rtDynamicBoundsError(i, 1, i, sf_emlrtBCI);
            }

            b_this = Points.size(0);
            r2.set_size(r.size(1), Points.size(1));
            loop_ub = Points.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = r.size(1);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                if (r[i1] > end_tmp) {
                  rtDynamicBoundsError(r[i1], 0, end_tmp, tf_emlrtBCI);
                }

                i2 = static_cast<int>(indices[r[i1]]);
                if ((i2 < 1) || (i2 > b_this)) {
                  rtDynamicBoundsError(i2, 1, b_this, uf_emlrtBCI);
                }

                r2[i1 + r2.size(0) * i] = Points[(i2 + Points.size(0) * i) - 1];
              }
            }

            b_newBoardCoords[0] = r1.size(0);
            b_newBoardCoords[1] = 1;
            b_newBoardCoords[2] = BoardCoords.size(2);
            rtSubAssignSizeCheck(&b_newBoardCoords[0], 3, r2.size(), 2,
                                 nb_emlrtECI);
            b_newBoardCoords[0] = r1.size(0);
            b_newBoardCoords[2] = BoardCoords.size(2);
            b_this = BoardCoords.size(1);
            loop_ub = b_newBoardCoords[2];
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = b_newBoardCoords[0];
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                newBoardCoords[(r1[i1] + newBoardCoords.size(0) * b_this) +
                  newBoardCoords.size(0) * newBoardCoords.size(1) * i] = r2[i1 +
                  b_newBoardCoords[0] * i];
              }
            }

            if (newBoardCoords.size(1) - 1 < 1) {
              i = 0;
            } else {
              if ((newBoardCoords.size(1) - 1 < 1) || (newBoardCoords.size(1) -
                   1 > newBoardCoords.size(1))) {
                rtDynamicBoundsError(newBoardCoords.size(1) - 1, 1,
                                     newBoardCoords.size(1), vf_emlrtBCI);
              }

              i = newBoardCoords.size(1) - 1;
            }

            b_newBoardCoords[0] = newBoardCoords.size(0);
            b_newBoardCoords[1] = i;
            b_newBoardCoords[2] = newBoardCoords.size(2);
            rtSubAssignSizeCheck(&b_newBoardCoords[0], 3, ((::coder::array<
              double, 3U> *)&BoardCoords)->size(), 3, ob_emlrtECI);
            loop_ub = BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = BoardCoords.size(1);
              for (int i1{0}; i1 < b_loop_ub; i1++) {
                b_this = BoardCoords.size(0);
                for (i2 = 0; i2 < b_this; i2++) {
                  newBoardCoords[(i2 + newBoardCoords.size(0) * i1) +
                    newBoardCoords.size(0) * newBoardCoords.size(1) * i] =
                    BoardCoords[(i2 + BoardCoords.size(0) * i1) +
                    BoardCoords.size(0) * BoardCoords.size(1) * i];
                }
              }
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &indices
          //                ::coder::array<double, 2U> &newBoard
          //                ::coder::array<double, 3U> &newBoardCoords
          // Return Type  : void
          //
          void Checkerboard::expandBoardUp(const ::coder::array<double, 2U>
            &indices, ::coder::array<double, 2U> &newBoard, ::coder::array<
            double, 3U> &newBoardCoords) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              693,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              693,                     // lineNo
              66,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              693,                     // lineNo
              58,                      // colNo
              "",                      // aName
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 685,// lineNo
              30,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 685,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 689,// lineNo
              36,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 689,// lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              686,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              687,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ -1,// nDims
              693,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
              695,                     // lineNo
              13,                      // colNo
              "Checkerboard/expandBoardUp",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 2U> r2;
            array<int, 2U> r;
            array<int, 1U> r1;
            double d;
            int iv1[3];
            int iv[2];
            int b_loop_ub;
            int end_tmp;
            int i;
            int i1;
            int i2;
            int loop_ub;
            int trueCount;
            d = static_cast<double>(BoardIdx.size(0)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, g_emlrtDCI);
            }

            newBoard.set_size(static_cast<int>(d), BoardIdx.size(1));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, h_emlrtDCI);
            }

            loop_ub = static_cast<int>(d) * BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              newBoard[i] = 0.0;
            }

            iv[0] = 1;
            iv[1] = BoardIdx.size(1);
            rtSubAssignSizeCheck(&iv[0], 2, ((::coder::array<double, 2U> *)
              &indices)->size(), 2, lb_emlrtECI);
            loop_ub = indices.size(1);
            for (i = 0; i < loop_ub; i++) {
              newBoard[newBoard.size(0) * i] = indices[i];
            }

            if (newBoard.size(0) < 2) {
              i = 0;
              i1 = 0;
            } else {
              i = 1;
              i1 = newBoard.size(0);
            }

            iv[0] = i1 - i;
            iv[1] = newBoard.size(1);
            rtSubAssignSizeCheck(&iv[0], 2, ((::coder::array<double, 2U> *)
              &BoardIdx)->size(), 2, mb_emlrtECI);
            loop_ub = BoardIdx.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_loop_ub = BoardIdx.size(0);
              for (i2 = 0; i2 < b_loop_ub; i2++) {
                newBoard[(i + i2) + newBoard.size(0) * i1] = BoardIdx[i2 +
                  BoardIdx.size(0) * i1];
              }
            }

            d = static_cast<double>(BoardCoords.size(0)) + 1.0;
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, i_emlrtDCI);
            }

            newBoardCoords.set_size(static_cast<int>(d), BoardCoords.size(1),
              BoardCoords.size(2));
            if (d != static_cast<int>(d)) {
              rtIntegerError(d, j_emlrtDCI);
            }

            loop_ub = static_cast<int>(d) * BoardCoords.size(1) *
              BoardCoords.size(2);
            for (i = 0; i < loop_ub; i++) {
              newBoardCoords[i] = 0.0;
            }

            end_tmp = indices.size(1) - 1;
            trueCount = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                trueCount++;
              }
            }

            r.set_size(1, trueCount);
            trueCount = 0;
            for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
              if (indices[loop_ub] > 0.0) {
                r[trueCount] = loop_ub;
                trueCount++;
              }
            }

            trueCount = BoardCoords.size(1);
            r1.set_size(r.size(1));
            loop_ub = r.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r[i] > trueCount - 1) {
                rtDynamicBoundsError(r[i], 0, trueCount - 1, qf_emlrtBCI);
              }

              r1[i] = r[i];
            }

            trueCount = Points.size(0);
            r2.set_size(r.size(1), Points.size(1));
            loop_ub = Points.size(1);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = r.size(1);
              for (i1 = 0; i1 < b_loop_ub; i1++) {
                if (r[i1] > end_tmp) {
                  rtDynamicBoundsError(r[i1], 0, end_tmp, rf_emlrtBCI);
                }

                i2 = static_cast<int>(indices[r[i1]]);
                if ((i2 < 1) || (i2 > trueCount)) {
                  rtDynamicBoundsError(i2, 1, trueCount, sf_emlrtBCI);
                }

                r2[i1 + r2.size(0) * i] = Points[(i2 + Points.size(0) * i) - 1];
              }
            }

            iv1[0] = 1;
            iv1[1] = r1.size(0);
            iv1[2] = BoardCoords.size(2);
            rtSubAssignSizeCheck(&iv1[0], 3, r2.size(), 2, nb_emlrtECI);
            iv1[1] = r1.size(0);
            iv1[2] = BoardCoords.size(2);
            loop_ub = iv1[2];
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = iv1[1];
              for (i1 = 0; i1 < b_loop_ub; i1++) {
                newBoardCoords[newBoardCoords.size(0) * r1[i1] +
                  newBoardCoords.size(0) * newBoardCoords.size(1) * i] = r2[i1 +
                  iv1[1] * i];
              }
            }

            if (newBoardCoords.size(0) < 2) {
              i = 0;
              i1 = 0;
            } else {
              i = 1;
              i1 = newBoardCoords.size(0);
            }

            iv1[0] = i1 - i;
            iv1[1] = newBoardCoords.size(1);
            iv1[2] = newBoardCoords.size(2);
            rtSubAssignSizeCheck(&iv1[0], 3, ((::coder::array<double, 3U> *)
              &BoardCoords)->size(), 3, ob_emlrtECI);
            loop_ub = BoardCoords.size(2);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_loop_ub = BoardCoords.size(1);
              for (i2 = 0; i2 < b_loop_ub; i2++) {
                trueCount = BoardCoords.size(0);
                for (end_tmp = 0; end_tmp < trueCount; end_tmp++) {
                  newBoardCoords[((i + end_tmp) + newBoardCoords.size(0) * i2) +
                    newBoardCoords.size(0) * newBoardCoords.size(1) * i1] =
                    BoardCoords[(end_tmp + BoardCoords.size(0) * i2) +
                    BoardCoords.size(0) * BoardCoords.size(1) * i1];
                }
              }
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &predictedPoints
          //                ::coder::array<double, 2U> &indices
          // Return Type  : void
          //
          void Checkerboard::findClosestIndices(const ::coder::array<double, 2U>
            &predictedPoints, ::coder::array<double, 2U> &indices) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              614,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              614,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestIndices",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 2U> remIdx;
            array<double, 2U> y;
            array<double, 1U> b_this;
            array<float, 2U> d_this;
            array<float, 2U> diffs;
            array<float, 1U> b_diffs;
            array<float, 1U> c_diffs;
            array<float, 1U> dists;
            array<int, 2U> r1;
            array<int, 1U> ii;
            array<bool, 2U> distIdx;
            array<bool, 1U> r;
            int b;
            int b_loop_ub;
            int c_loop_ub;
            int c_this;
            int i;
            int loop_ub;
            indices.set_size(1, predictedPoints.size(0));
            loop_ub = predictedPoints.size(0);
            for (i = 0; i < loop_ub; i++) {
              indices[i] = 0.0;
            }

            b = Points.size(0);
            if (b < 1) {
              y.set_size(1, 0);
            } else {
              y.set_size(1, b);
              loop_ub = b - 1;
              for (i = 0; i <= loop_ub; i++) {
                y[i] = static_cast<double>(i) + 1.0;
              }
            }

            b = BoardIdx.size(0) * BoardIdx.size(1);
            b_this = BoardIdx.reshape(b);
            do_vectors(y, b_this, remIdx, ii);
            if (remIdx.size(1) != 0) {
              if (predictedPoints.size(1) < 1) {
                rtDynamicBoundsError(1, 1, predictedPoints.size(1), rc_emlrtBCI);
              }

              r.set_size(predictedPoints.size(0));
              loop_ub = predictedPoints.size(0);
              for (i = 0; i < loop_ub; i++) {
                r[i] = !std::isnan(predictedPoints[i]);
              }

              c_eml_find(r, ii);
              i = ii.size(0);
              if (ii.size(0) - 1 >= 0) {
                c_this = Points.size(0);
                b_loop_ub = Points.size(1);
                c_loop_ub = predictedPoints.size(1);
              }

              for (int b_i{0}; b_i < i; b_i++) {
                int end_tmp;
                int i1;
                bool b_b;
                if (b_i + 1 > ii.size(0)) {
                  rtDynamicBoundsError(b_i + 1, 1, ii.size(0), sc_emlrtBCI);
                }

                i1 = ii[b_i];
                b_b = ((i1 < 1) || (i1 > predictedPoints.size(0)));
                if (b_b) {
                  rtDynamicBoundsError(i1, 1, predictedPoints.size(0),
                                       qc_emlrtBCI);
                }

                d_this.set_size(remIdx.size(1), Points.size(1));
                for (int i2{0}; i2 < b_loop_ub; i2++) {
                  loop_ub = remIdx.size(1);
                  for (end_tmp = 0; end_tmp < loop_ub; end_tmp++) {
                    if (remIdx[end_tmp] != static_cast<int>(std::floor
                         (remIdx[end_tmp]))) {
                      rtIntegerError(remIdx[end_tmp], f_emlrtDCI);
                    }

                    b = static_cast<int>(remIdx[end_tmp]);
                    if ((b < 1) || (b > c_this)) {
                      rtDynamicBoundsError(b, 1, c_this, tc_emlrtBCI);
                    }

                    d_this[end_tmp + d_this.size(0) * i2] = Points[(b +
                      Points.size(0) * i2) - 1];
                  }
                }

                y.set_size(1, predictedPoints.size(1));
                for (int i2{0}; i2 < c_loop_ub; i2++) {
                  y[i2] = predictedPoints[(ii[b_i] + predictedPoints.size(0) *
                    i2) - 1];
                }

                bsxfun(d_this, y, diffs);
                if (diffs.size(1) < 1) {
                  rtDynamicBoundsError(1, 1, diffs.size(1), pc_emlrtBCI);
                }

                if (diffs.size(1) < 2) {
                  rtDynamicBoundsError(2, 1, diffs.size(1), oc_emlrtBCI);
                }

                b_diffs.set_size(diffs.size(0));
                loop_ub = diffs.size(0);
                c_diffs.set_size(diffs.size(0));
                for (int i2{0}; i2 < loop_ub; i2++) {
                  b_diffs[i2] = diffs[i2];
                  c_diffs[i2] = diffs[i2 + diffs.size(0)];
                }

                b_hypot(b_diffs, c_diffs, dists);
                end_tmp = indices.size(1) - 1;
                b = 0;
                for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
                  if (indices[loop_ub] > 0.0) {
                    b++;
                  }
                }

                r1.set_size(1, b);
                b = 0;
                for (loop_ub = 0; loop_ub <= end_tmp; loop_ub++) {
                  if (indices[loop_ub] > 0.0) {
                    r1[b] = loop_ub;
                    b++;
                  }
                }

                loop_ub = r1.size(1);
                for (int i2{0}; i2 < loop_ub; i2++) {
                  if ((r1[i2] < 0) || (r1[i2] > end_tmp)) {
                    rtDynamicBoundsError(r1[i2], 0, end_tmp, uc_emlrtBCI);
                  }
                }

                loop_ub = r1.size(1);
                y.set_size(1, r1.size(1));
                for (int i2{0}; i2 < loop_ub; i2++) {
                  y[i2] = indices[r1[i2]];
                }

                isMember(remIdx, y, distIdx);
                b = distIdx.size(1) - 1;
                for (loop_ub = 0; loop_ub <= b; loop_ub++) {
                  if (distIdx[loop_ub]) {
                    if (loop_ub > dists.size(0) - 1) {
                      rtDynamicBoundsError(loop_ub, 0, dists.size(0) - 1,
                                           vc_emlrtBCI);
                    }

                    dists[loop_ub] = rtInfF;
                  }
                }

                ::coder::internal::minimum(dists, b);
                if ((b < 1) || (b > remIdx.size(1))) {
                  rtDynamicBoundsError(b, 1, remIdx.size(1), qf_emlrtBCI);
                }

                if (b_i + 1 > ii.size(0)) {
                  rtDynamicBoundsError(b_i + 1, 1, ii.size(0), rf_emlrtBCI);
                }

                indices[i1 - 1] = remIdx[b - 1];
              }
            }
          }

          //
          // Arguments    : const double predictedPoint[2]
          //                double radius
          //                const double curve_data[]
          //                const int curve_size[2]
          //                const double coordsToUse[2]
          //                const ::coder::array<double, 2U> &removedIdx
          //                ::coder::array<double, 2U> &idx
          // Return Type  : void
          //
          void Checkerboard::findClosestOnCurve(const double predictedPoint[2],
            double radius, const double curve_data[], const int curve_size[2],
            const double coordsToUse[2], const ::coder::array<double, 2U>
            &removedIdx, ::coder::array<double, 2U> &idx) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              670,                     // lineNo
              26,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              646,                     // lineNo
              48,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              661,                     // lineNo
              47,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              661,                     // lineNo
              40,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              669,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              675,                     // lineNo
              17,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              677,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 646,// lineNo
              48,                      // colNo
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ 1,// nDims
              670,                     // lineNo
              45,                      // colNo
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ 2,// nDims
              670,                     // lineNo
              45,                      // colNo
              "Checkerboard/findClosestOnCurve",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtRunTimeErrorInfo s_emlrtRTEI{ 288,// lineNo
              27,                      // colNo
              "check_non_axis_size",   // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/cat.m"// pName
            };

            static rtRunTimeErrorInfo t_emlrtRTEI{ 419,// lineNo
              15,                      // colNo
              "assert_pmaxsize",       // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/ops/colon.m"// pName
            };

            array<double, 2U> dataPts;
            array<double, 2U> firstCoord;
            array<double, 2U> remIdx;
            array<double, 2U> y;
            array<double, 1U> b_idx;
            array<double, 1U> b_this;
            array<double, 1U> b_varargin_2;
            array<double, 1U> dist;
            array<float, 2U> b_a;
            array<float, 2U> currPt;
            array<float, 2U> diffs;
            array<float, 2U> queryPts;
            array<float, 1U> b_diffs;
            array<float, 1U> c_diffs;
            array<float, 1U> dists;
            array<int, 1U> ii;
            array<int, 1U> r;
            array<bool, 1U> candIdx;
            int acoef;
            int b_acoef;
            int b_loop_ub;
            int i;
            int i1;
            int k;
            int loop_ub;
            int ncols;
            int outsize_idx_1;
            int varargin_2;
            bool overflow;
            acoef = Points.size(0);
            if (acoef < 1) {
              y.set_size(1, 0);
            } else {
              y.set_size(1, acoef);
              loop_ub = acoef - 1;
              for (i = 0; i <= loop_ub; i++) {
                y[i] = static_cast<double>(i) + 1.0;
              }
            }

            acoef = BoardIdx.size(0) * BoardIdx.size(1);
            b_this = BoardIdx.reshape(acoef);
            do_vectors(y, b_this, remIdx, ii);
            firstCoord.set_size(1, remIdx.size(1));
            loop_ub = remIdx.size(0) * remIdx.size(1) - 1;
            for (i = 0; i <= loop_ub; i++) {
              firstCoord[i] = remIdx[i];
            }

            do_vectors(firstCoord, removedIdx, remIdx, ii);
            acoef = Points.size(0);
            loop_ub = remIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (remIdx[i] != static_cast<int>(std::floor(remIdx[i]))) {
                rtIntegerError(remIdx[i], g_emlrtDCI);
              }

              i1 = static_cast<int>(remIdx[i]);
              if ((i1 < 1) || (i1 > acoef)) {
                rtDynamicBoundsError(i1, 1, acoef, rf_emlrtBCI);
              }
            }

            if ((Points.size(1) != 1) && (Points.size(1) != 2)) {
              n_rtErrorWithMessageID(m_emlrtRTEI.fName, m_emlrtRTEI.lineNo);
            }

            diffs.set_size(remIdx.size(1), 2);
            if (remIdx.size(1) != 0) {
              acoef = (Points.size(1) != 1);
              b_acoef = (remIdx.size(1) != 1);
              for (k = 0; k < 2; k++) {
                varargin_2 = acoef * k;
                i = diffs.size(0) - 1;
                for (loop_ub = 0; loop_ub <= i; loop_ub++) {
                  diffs[loop_ub + diffs.size(0) * k] = Points[(static_cast<int>
                    (remIdx[b_acoef * loop_ub]) + Points.size(0) * varargin_2) -
                    1] - static_cast<float>(predictedPoint[k]);
                }
              }
            }

            b_diffs.set_size(diffs.size(0));
            loop_ub = diffs.size(0);
            c_diffs.set_size(diffs.size(0));
            for (i = 0; i < loop_ub; i++) {
              b_diffs[i] = diffs[i];
              c_diffs[i] = diffs[i + diffs.size(0)];
            }

            b_hypot(b_diffs, c_diffs, dists);
            candIdx.set_size(dists.size(0));
            loop_ub = dists.size(0);
            for (i = 0; i < loop_ub; i++) {
              candIdx[i] = (dists[i] < radius);
            }

            b_acoef = 0;
            i = candIdx.size(0);
            for (k = 0; k < i; k++) {
              if (candIdx[k]) {
                b_acoef++;
              }
            }

            if (b_acoef > 1) {
              double a;
              double a_tmp;
              bool exitg1;
              bool p;
              a_tmp = predictedPoint[static_cast<int>(coordsToUse[0]) - 1];
              a = a_tmp - radius;
              a_tmp += radius;
              if (std::isnan(a) || std::isnan(a_tmp)) {
                firstCoord.set_size(1, 1);
                firstCoord[0] = rtNaN;
              } else if (a_tmp < a) {
                firstCoord.set_size(1, 0);
              } else if ((std::isinf(a) || std::isinf(a_tmp)) && (a == a_tmp)) {
                firstCoord.set_size(1, 1);
                firstCoord[0] = rtNaN;
              } else if (std::floor(a) == a) {
                loop_ub = static_cast<int>(a_tmp - a);
                firstCoord.set_size(1, loop_ub + 1);
                for (i = 0; i <= loop_ub; i++) {
                  firstCoord[i] = a + static_cast<double>(i);
                }
              } else {
                double apnd;
                double cdiff;
                double ndbl;
                ndbl = std::floor((a_tmp - a) + 0.5);
                apnd = a + ndbl;
                cdiff = apnd - a_tmp;
                if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(std::
                     abs(a), std::abs(a_tmp))) {
                  ndbl++;
                  apnd = a_tmp;
                } else if (cdiff > 0.0) {
                  apnd = a + (ndbl - 1.0);
                } else {
                  ndbl++;
                }

                if (ndbl >= 0.0) {
                  b_acoef = static_cast<int>(ndbl);
                } else {
                  b_acoef = 0;
                }

                if (ndbl > 2.147483647E+9) {
                  rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
                }

                firstCoord.set_size(1, b_acoef);
                if (b_acoef > 0) {
                  firstCoord[0] = a;
                  if (b_acoef > 1) {
                    firstCoord[b_acoef - 1] = apnd;
                    acoef = (b_acoef - 1) / 2;
                    for (k = 0; k <= acoef - 2; k++) {
                      firstCoord[k + 1] = a + (static_cast<double>(k) + 1.0);
                      firstCoord[(b_acoef - k) - 2] = apnd - (static_cast<double>
                        (k) + 1.0);
                    }

                    if (acoef << 1 == b_acoef - 1) {
                      firstCoord[acoef] = (a + apnd) / 2.0;
                    } else {
                      firstCoord[acoef] = a + static_cast<double>(acoef);
                      firstCoord[acoef + 1] = apnd - static_cast<double>(acoef);
                    }
                  }
                }
              }

              p = true;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k < 2)) {
                if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                  p = false;
                  exitg1 = true;
                } else {
                  k++;
                }
              }

              if (p) {
                b_idx.set_size(firstCoord.size(1));
                loop_ub = firstCoord.size(1);
                for (i = 0; i < loop_ub; i++) {
                  b_idx[i] = firstCoord[i];
                }

                y.set_size(1, firstCoord.size(1));
                if (firstCoord.size(1) != 0) {
                  acoef = firstCoord.size(1);
                  y.set_size(1, firstCoord.size(1));
                  for (i = 0; i < acoef; i++) {
                    y[i] = curve_data[0];
                  }

                  i = curve_size[1];
                  for (k = 0; k <= i - 2; k++) {
                    if (firstCoord.size(1) == y.size(1)) {
                      a_tmp = curve_data[k + 1];
                      loop_ub = firstCoord.size(1) - 1;
                      y.set_size(1, firstCoord.size(1));
                      for (i1 = 0; i1 <= loop_ub; i1++) {
                        y[i1] = firstCoord[i1] * y[i1] + a_tmp;
                      }
                    } else {
                      binary_expand_op(y, firstCoord, curve_data, k);
                    }
                  }
                }

                b_varargin_2.set_size(y.size(1));
                loop_ub = y.size(1);
                for (i = 0; i < loop_ub; i++) {
                  b_varargin_2[i] = y[i];
                }

                if (b_varargin_2.size(0) != b_idx.size(0)) {
                  o_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
                }

                dataPts.set_size(b_idx.size(0), 2);
                loop_ub = b_idx.size(0);
                for (i = 0; i < loop_ub; i++) {
                  dataPts[i] = b_idx[i];
                }

                loop_ub = b_varargin_2.size(0);
                for (i = 0; i < loop_ub; i++) {
                  dataPts[i + dataPts.size(0)] = b_varargin_2[i];
                }
              } else {
                y.set_size(1, firstCoord.size(1));
                if (firstCoord.size(1) != 0) {
                  acoef = firstCoord.size(1);
                  y.set_size(1, firstCoord.size(1));
                  for (i = 0; i < acoef; i++) {
                    y[i] = curve_data[0];
                  }

                  i = curve_size[1];
                  for (k = 0; k <= i - 2; k++) {
                    if (firstCoord.size(1) == y.size(1)) {
                      a_tmp = curve_data[k + 1];
                      loop_ub = firstCoord.size(1) - 1;
                      y.set_size(1, firstCoord.size(1));
                      for (i1 = 0; i1 <= loop_ub; i1++) {
                        y[i1] = firstCoord[i1] * y[i1] + a_tmp;
                      }
                    } else {
                      binary_expand_op(y, firstCoord, curve_data, k);
                    }
                  }
                }

                b_idx.set_size(y.size(1));
                loop_ub = y.size(1);
                for (i = 0; i < loop_ub; i++) {
                  b_idx[i] = y[i];
                }

                b_varargin_2.set_size(firstCoord.size(1));
                loop_ub = firstCoord.size(1);
                for (i = 0; i < loop_ub; i++) {
                  b_varargin_2[i] = firstCoord[i];
                }

                if (b_varargin_2.size(0) != b_idx.size(0)) {
                  o_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
                }

                dataPts.set_size(b_idx.size(0), 2);
                loop_ub = b_idx.size(0);
                for (i = 0; i < loop_ub; i++) {
                  dataPts[i] = b_idx[i];
                }

                loop_ub = b_varargin_2.size(0);
                for (i = 0; i < loop_ub; i++) {
                  dataPts[i + dataPts.size(0)] = b_varargin_2[i];
                }
              }

              b_acoef = candIdx.size(0) - 1;
              acoef = 0;
              for (k = 0; k <= b_acoef; k++) {
                if (candIdx[k]) {
                  acoef++;
                }
              }

              r.set_size(acoef);
              acoef = 0;
              for (k = 0; k <= b_acoef; k++) {
                if (candIdx[k]) {
                  r[acoef] = k;
                  acoef++;
                }
              }

              acoef = Points.size(0);
              queryPts.set_size(r.size(0), Points.size(1));
              loop_ub = Points.size(1);
              for (i = 0; i < loop_ub; i++) {
                b_acoef = r.size(0);
                for (i1 = 0; i1 < b_acoef; i1++) {
                  if (r[i1] > remIdx.size(1) - 1) {
                    rtDynamicBoundsError(r[i1], 0, remIdx.size(1) - 1,
                                         sf_emlrtBCI);
                  }

                  varargin_2 = static_cast<int>(remIdx[r[i1]]);
                  if ((varargin_2 < 1) || (varargin_2 > acoef)) {
                    rtDynamicBoundsError(varargin_2, 1, acoef, tf_emlrtBCI);
                  }

                  queryPts[i1 + queryPts.size(0) * i] = Points[(varargin_2 +
                    Points.size(0) * i) - 1];
                }
              }

              dist.set_size(r.size(0));
              i = r.size(0);
              if (r.size(0) - 1 >= 0) {
                b_loop_ub = Points.size(1);
                outsize_idx_1 = Points.size(1);
                ncols = Points.size(1);
                overflow = (Points.size(1) > 2147483646);
              }

              for (k = 0; k < i; k++) {
                float varargin_1;
                if (k + 1 > r.size(0)) {
                  rtDynamicBoundsError(k + 1, 1, r.size(0), uf_emlrtBCI);
                }

                b_a.set_size(1, Points.size(1));
                for (i1 = 0; i1 < b_loop_ub; i1++) {
                  b_a[i1] = queryPts[k + queryPts.size(0) * i1];
                }

                currPt.set_size(dataPts.size(0), outsize_idx_1);
                acoef = dataPts.size(0);
                if (overflow) {
                  check_forloop_overflow_error();
                }

                for (varargin_2 = 0; varargin_2 < ncols; varargin_2++) {
                  b_acoef = varargin_2 * acoef;
                  if (acoef > 2147483646) {
                    check_forloop_overflow_error();
                  }

                  for (loop_ub = 0; loop_ub < acoef; loop_ub++) {
                    currPt[b_acoef + loop_ub] = b_a[varargin_2];
                  }
                }

                if ((dataPts.size(0) != currPt.size(0)) && ((dataPts.size(0) !=
                      1) && (currPt.size(0) != 1))) {
                  emlrtDimSizeImpxCheckR2021b(dataPts.size(0), currPt.size(0),
                    lb_emlrtECI);
                }

                if ((currPt.size(1) != 2) && (currPt.size(1) != 1)) {
                  emlrtDimSizeImpxCheckR2021b(2, currPt.size(1), mb_emlrtECI);
                }

                if ((dataPts.size(0) == currPt.size(0)) && (currPt.size(1) == 2))
                {
                  diffs.set_size(dataPts.size(0), 2);
                  loop_ub = dataPts.size(0) << 1;
                  for (i1 = 0; i1 < loop_ub; i1++) {
                    varargin_1 = static_cast<float>(dataPts[i1]) - currPt[i1];
                    diffs[i1] = varargin_1 * varargin_1;
                  }
                } else {
                  binary_expand_op(diffs, dataPts, currPt);
                }

                if (diffs.size(0) == 0) {
                  dists.set_size(0);
                } else {
                  acoef = diffs.size(0);
                  dists.set_size(diffs.size(0));
                  if (diffs.size(0) > 2147483646) {
                    check_forloop_overflow_error();
                  }

                  for (b_acoef = 0; b_acoef < acoef; b_acoef++) {
                    dists[b_acoef] = diffs[b_acoef];
                  }

                  for (b_acoef = 0; b_acoef < acoef; b_acoef++) {
                    dists[b_acoef] = dists[b_acoef] + diffs[acoef + b_acoef];
                  }
                }

                varargin_1 = ::coder::internal::minimum(dists);
                if (varargin_1 < 0.0F) {
                  d_rtErrorWithMessageID("sqrt", f_emlrtRTEI.fName,
                    f_emlrtRTEI.lineNo);
                }

                varargin_1 = std::sqrt(varargin_1);
                if (k + 1 > dist.size(0)) {
                  rtDynamicBoundsError(k + 1, 1, dist.size(0), qf_emlrtBCI);
                }

                dist[k] = varargin_1;
              }

              ::coder::internal::minimum(dist, acoef);
              b_eml_find(candIdx, static_cast<double>(acoef), ii);
              b_idx.set_size(ii.size(0));
              loop_ub = ii.size(0);
              for (i = 0; i < loop_ub; i++) {
                b_idx[i] = ii[i];
              }

              idx.set_size(1, 1);
              if (b_idx.size(0) < 1) {
                rtDynamicBoundsError(b_idx.size(0), 1, b_idx.size(0),
                                     vf_emlrtBCI);
              }

              i = static_cast<int>(b_idx[b_idx.size(0) - 1]);
              if ((i < 1) || (i > remIdx.size(1))) {
                rtDynamicBoundsError(i, 1, remIdx.size(1), vf_emlrtBCI);
              }

              idx[0] = remIdx[i - 1];
            } else if (b_acoef == 1) {
              b_acoef = candIdx.size(0) - 1;
              acoef = 0;
              for (k = 0; k <= b_acoef; k++) {
                if (candIdx[k]) {
                  acoef++;
                }
              }

              idx.set_size(1, acoef);
              acoef = 0;
              for (k = 0; k <= b_acoef; k++) {
                if (candIdx[k]) {
                  if (k > remIdx.size(1) - 1) {
                    rtDynamicBoundsError(k, 0, remIdx.size(1) - 1, wf_emlrtBCI);
                  }

                  idx[acoef] = remIdx[k];
                  acoef++;
                }
              }
            } else {
              idx.set_size(1, 0);
            }
          }

          //
          // Arguments    : double coordsToUse[2]
          // Return Type  : void
          //
          void Checkerboard::findIndependentVar(double coordsToUse[2]) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              512,                     // lineNo
              58,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              512,                     // lineNo
              98,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<double, 2U> r3;
            array<double, 2U> r4;
            array<double, 2U> r5;
            array<int, 2U> r2;
            array<bool, 2U> r;
            array<bool, 2U> r1;
            double b_x;
            double x;
            int end;
            int i;
            int loop_ub;
            i = BoardIdx.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, cc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              r[i] = (BoardIdx[BoardIdx.size(0) * i] > 0.0);
            }

            i = BoardIdx.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, dc_emlrtBCI);
            }

            r1.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i = 0; i < loop_ub; i++) {
              r1[i] = (BoardIdx[BoardIdx.size(0) * i + 1] > 0.0);
            }

            if (r.size(1) != r1.size(1)) {
              rtSizeEqNDCheck(r.size(), r1.size(), y_emlrtECI);
            }

            i = BoardCoords.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ec_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, fc_emlrtBCI);
            }

            end = r.size(1) - 1;
            loop_ub = 0;
            for (i = 0; i <= end; i++) {
              if (r[i] && r1[i]) {
                loop_ub++;
              }
            }

            r2.set_size(1, loop_ub);
            loop_ub = 0;
            for (i = 0; i <= end; i++) {
              if (r[i] && r1[i]) {
                r2[loop_ub] = i;
                loop_ub++;
              }
            }

            end = BoardCoords.size(1);
            r3.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, kc_emlrtBCI);
              }

              r3[i] = BoardCoords[BoardCoords.size(0) * r2[i] + 1];
            }

            i = BoardCoords.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, gc_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, hc_emlrtBCI);
            }

            end = BoardCoords.size(1);
            r4.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, lc_emlrtBCI);
              }

              r4[i] = BoardCoords[BoardCoords.size(0) * r2[i]];
            }

            r5.set_size(1, r3.size(1));
            loop_ub = r3.size(1);
            for (i = 0; i < loop_ub; i++) {
              r5[i] = r3[i] - r4[i];
            }

            x = mean(r5);
            i = BoardCoords.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ic_emlrtBCI);
            }

            end = BoardCoords.size(1);
            r3.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, mc_emlrtBCI);
              }

              r3[i] = BoardCoords[(r2[i] + BoardCoords.size(1)) *
                BoardCoords.size(0) + 1];
            }

            i = BoardCoords.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
            }

            i = BoardCoords.size(2);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, jc_emlrtBCI);
            }

            end = BoardCoords.size(1);
            r4.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, nc_emlrtBCI);
              }

              r4[i] = BoardCoords[(r2[i] + BoardCoords.size(1)) *
                BoardCoords.size(0)];
            }

            r5.set_size(1, r3.size(1));
            loop_ub = r3.size(1);
            for (i = 0; i < loop_ub; i++) {
              r5[i] = r3[i] - r4[i];
            }

            b_x = mean(r5);
            if (std::abs(x) > std::abs(b_x)) {
              coordsToUse[0] = 1.0;
              coordsToUse[1] = 2.0;
            } else {
              coordsToUse[0] = 2.0;
              coordsToUse[1] = 1.0;
            }
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                double coordsToUse[2]
          // Return Type  : void
          //
          void Checkerboard::findIndependentVar(const ::coder::array<double, 2U>
            &idx, double coordsToUse[2]) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              510,                     // lineNo
              78,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              510,                     // lineNo
              48,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              511,                     // lineNo
              62,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              511,                     // lineNo
              102,                     // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              512,                     // lineNo
              62,                      // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              512,                     // lineNo
              102,                     // colNo
              "",                      // aName
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 510,// lineNo
              74,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 510,// lineNo
              44,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 511,// lineNo
              58,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 511,// lineNo
              98,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo k_emlrtDCI{ 512,// lineNo
              58,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo l_emlrtDCI{ 512,// lineNo
              98,                      // colNo
              "Checkerboard/findIndependentVar",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            array<double, 2U> r3;
            array<double, 2U> r4;
            array<double, 2U> r5;
            array<int, 2U> r2;
            array<bool, 2U> r;
            array<bool, 2U> r1;
            double b_x;
            double x;
            int b_i;
            int b_idx;
            int c_idx;
            int end;
            int i;
            int i1;
            int loop_ub;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), rf_emlrtBCI);
            }

            i = static_cast<int>(std::floor(idx[0]));
            if (idx[0] != i) {
              rtIntegerError(idx[0], h_emlrtDCI);
            }

            i1 = BoardIdx.size(0);
            b_idx = static_cast<int>(idx[0]);
            if ((b_idx < 1) || (b_idx > i1)) {
              rtDynamicBoundsError(b_idx, 1, i1, cc_emlrtBCI);
            }

            r.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              r[i1] = (BoardIdx[(b_idx + BoardIdx.size(0) * i1) - 1] > 0.0);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), qf_emlrtBCI);
            }

            i1 = static_cast<int>(std::floor(idx[1]));
            if (idx[1] != i1) {
              rtIntegerError(idx[1], g_emlrtDCI);
            }

            b_i = BoardIdx.size(0);
            c_idx = static_cast<int>(idx[1]);
            if ((c_idx < 1) || (c_idx > b_i)) {
              rtDynamicBoundsError(c_idx, 1, b_i, dc_emlrtBCI);
            }

            r1.set_size(1, BoardIdx.size(1));
            loop_ub = BoardIdx.size(1);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              r1[b_i] = (BoardIdx[(c_idx + BoardIdx.size(0) * b_i) - 1] > 0.0);
            }

            if (r.size(1) != r1.size(1)) {
              rtSizeEqNDCheck(r.size(), r1.size(), y_emlrtECI);
            }

            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), sf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 1) {
              rtDynamicBoundsError(1, 1, b_i, fc_emlrtBCI);
            }

            end = r.size(1) - 1;
            loop_ub = 0;
            for (b_i = 0; b_i <= end; b_i++) {
              if (r[b_i] && r1[b_i]) {
                loop_ub++;
              }
            }

            r2.set_size(1, loop_ub);
            loop_ub = 0;
            for (b_i = 0; b_i <= end; b_i++) {
              if (r[b_i] && r1[b_i]) {
                r2[loop_ub] = b_i;
                loop_ub++;
              }
            }

            end = BoardCoords.size(1);
            if (idx[1] != i1) {
              rtIntegerError(idx[1], i_emlrtDCI);
            }

            b_i = BoardCoords.size(0);
            if (c_idx > b_i) {
              rtDynamicBoundsError(c_idx, 1, b_i, ec_emlrtBCI);
            }

            r3.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              if (r2[b_i] > end - 1) {
                rtDynamicBoundsError(r2[b_i], 0, end - 1, kc_emlrtBCI);
              }

              r3[b_i] = BoardCoords[(c_idx + BoardCoords.size(0) * r2[b_i]) - 1];
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), tf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 1) {
              rtDynamicBoundsError(1, 1, b_i, hc_emlrtBCI);
            }

            end = BoardCoords.size(1);
            if (idx[0] != i) {
              rtIntegerError(idx[0], j_emlrtDCI);
            }

            b_i = BoardCoords.size(0);
            if (b_idx > b_i) {
              rtDynamicBoundsError(b_idx, 1, b_i, gc_emlrtBCI);
            }

            r4.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              if (r2[b_i] > end - 1) {
                rtDynamicBoundsError(r2[b_i], 0, end - 1, lc_emlrtBCI);
              }

              r4[b_i] = BoardCoords[(b_idx + BoardCoords.size(0) * r2[b_i]) - 1];
            }

            r5.set_size(1, r3.size(1));
            loop_ub = r3.size(1);
            for (b_i = 0; b_i < loop_ub; b_i++) {
              r5[b_i] = r3[b_i] - r4[b_i];
            }

            x = mean(r5);
            if (idx.size(1) < 2) {
              rtDynamicBoundsError(2, 1, idx.size(1), uf_emlrtBCI);
            }

            b_i = BoardCoords.size(2);
            if (b_i < 2) {
              rtDynamicBoundsError(2, 1, b_i, ic_emlrtBCI);
            }

            end = BoardCoords.size(1);
            if (idx[1] != i1) {
              rtIntegerError(idx[1], k_emlrtDCI);
            }

            r3.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i1 = 0; i1 < loop_ub; i1++) {
              if (r2[i1] > end - 1) {
                rtDynamicBoundsError(r2[i1], 0, end - 1, mc_emlrtBCI);
              }

              r3[i1] = BoardCoords[((c_idx + BoardCoords.size(0) * r2[i1]) +
                                    BoardCoords.size(0) * BoardCoords.size(1)) -
                1];
            }

            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), vf_emlrtBCI);
            }

            i1 = BoardCoords.size(2);
            if (i1 < 2) {
              rtDynamicBoundsError(2, 1, i1, jc_emlrtBCI);
            }

            end = BoardCoords.size(1);
            if (idx[0] != i) {
              rtIntegerError(idx[0], l_emlrtDCI);
            }

            r4.set_size(1, r2.size(1));
            loop_ub = r2.size(1);
            for (i = 0; i < loop_ub; i++) {
              if (r2[i] > end - 1) {
                rtDynamicBoundsError(r2[i], 0, end - 1, nc_emlrtBCI);
              }

              r4[i] = BoardCoords[((b_idx + BoardCoords.size(0) * r2[i]) +
                                   BoardCoords.size(0) * BoardCoords.size(1)) -
                1];
            }

            r5.set_size(1, r3.size(1));
            loop_ub = r3.size(1);
            for (i = 0; i < loop_ub; i++) {
              r5[i] = r3[i] - r4[i];
            }

            b_x = mean(r5);
            if (std::abs(x) > std::abs(b_x)) {
              coordsToUse[0] = 1.0;
              coordsToUse[1] = 2.0;
            } else {
              coordsToUse[0] = 2.0;
              coordsToUse[1] = 1.0;
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &pointVectors
          //                const ::coder::array<float, 1U> &euclideanDists
          //                const ::coder::array<float, 2U> &v
          // Return Type  : double
          //
          double Checkerboard::findNeighbor(const ::coder::array<float, 2U>
            &pointVectors, const ::coder::array<float, 1U> &euclideanDists,
            const ::coder::array<float, 2U> &v) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              236,                     // lineNo
              75,                      // colNo
              "",                      // aName
              "Checkerboard/findNeighbor",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              236,                     // lineNo
              81,                      // colNo
              "",                      // aName
              "Checkerboard/findNeighbor",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            array<float, 1U> angleCosines;
            array<float, 1U> dists;
            array<int, 1U> r;
            double neighborIdx;
            float b;
            int inner;
            int mc;
            if (v.size(1) < 1) {
              rtDynamicBoundsError(1, 1, v.size(1), qf_emlrtBCI);
            }

            if (v.size(1) < 2) {
              rtDynamicBoundsError(2, 1, v.size(1), rf_emlrtBCI);
            }

            if (pointVectors.size(1) != v.size(1)) {
              if (((pointVectors.size(0) == 1) && (pointVectors.size(1) == 1)) ||
                  (v.size(1) == 1)) {
                k_rtErrorWithMessageID(i_emlrtRTEI.fName, i_emlrtRTEI.lineNo);
              } else {
                l_rtErrorWithMessageID(j_emlrtRTEI.fName, j_emlrtRTEI.lineNo);
              }
            }

            mc = pointVectors.size(0);
            inner = pointVectors.size(1);
            angleCosines.set_size(pointVectors.size(0));
            if (pointVectors.size(0) > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int i{0}; i < mc; i++) {
              angleCosines[i] = 0.0F;
            }

            if (pointVectors.size(1) > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int k{0}; k < inner; k++) {
              int aoffset;
              aoffset = k * pointVectors.size(0);
              if (mc > 2147483646) {
                check_forloop_overflow_error();
              }

              for (int i{0}; i < mc; i++) {
                angleCosines[i] = angleCosines[i] + pointVectors[aoffset + i] *
                  v[k];
              }
            }

            b = rt_hypotf_snf(v[0], v[1]);
            dists.set_size(euclideanDists.size(0));
            mc = euclideanDists.size(0);
            for (inner = 0; inner < mc; inner++) {
              dists[inner] = euclideanDists[inner] * b;
            }

            if ((angleCosines.size(0) != 1) && (dists.size(0) != 1) &&
                (angleCosines.size(0) != dists.size(0))) {
              j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
            }

            if (angleCosines.size(0) == dists.size(0)) {
              mc = angleCosines.size(0);
              for (inner = 0; inner < mc; inner++) {
                angleCosines[inner] = angleCosines[inner] / dists[inner];
              }
            } else {
              rdivide(angleCosines, dists);
            }

            dists.set_size(euclideanDists.size(0));
            mc = euclideanDists.size(0);
            for (inner = 0; inner < mc; inner++) {
              dists[inner] = 1.5F * euclideanDists[inner];
            }

            if ((dists.size(0) != angleCosines.size(0)) && ((dists.size(0) != 1)
                 && (angleCosines.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(dists.size(0), angleCosines.size(0),
                s_emlrtECI);
            }

            if (dists.size(0) == angleCosines.size(0)) {
              mc = dists.size(0);
              for (inner = 0; inner < mc; inner++) {
                dists[inner] = dists[inner] * (1.0F - angleCosines[inner]);
              }
            } else {
              binary_expand_op(dists, angleCosines);
            }

            if ((euclideanDists.size(0) != dists.size(0)) &&
                ((euclideanDists.size(0) != 1) && (dists.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(euclideanDists.size(0), dists.size(0),
                r_emlrtECI);
            }

            if (euclideanDists.size(0) == dists.size(0)) {
              dists.set_size(euclideanDists.size(0));
              mc = euclideanDists.size(0);
              for (inner = 0; inner < mc; inner++) {
                dists[inner] = euclideanDists[inner] + dists[inner];
              }
            } else {
              plus(dists, euclideanDists);
            }

            inner = BoardIdx.size(0) * BoardIdx.size(1) - 1;
            mc = 0;
            for (int i{0}; i <= inner; i++) {
              if (BoardIdx[i] > 0.0) {
                mc++;
              }
            }

            r.set_size(mc);
            mc = 0;
            for (int i{0}; i <= inner; i++) {
              if (BoardIdx[i] > 0.0) {
                double d;
                if (i > inner) {
                  rtDynamicBoundsError(i, 0, inner, r_emlrtBCI);
                }

                d = BoardIdx[i];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                     dists.size(0))) {
                  rtDynamicBoundsError(static_cast<int>(d), 1, dists.size(0),
                                       q_emlrtBCI);
                }

                r[mc] = static_cast<int>(d);
                mc++;
              }
            }

            mc = r.size(0);
            for (inner = 0; inner < mc; inner++) {
              dists[r[inner] - 1] = rtInfF;
            }

            mc = angleCosines.size(0) - 1;
            for (int i{0}; i <= mc; i++) {
              if (angleCosines[i] < 0.0F) {
                if (i > dists.size(0) - 1) {
                  rtDynamicBoundsError(i, 0, dists.size(0) - 1, s_emlrtBCI);
                }

                dists[i] = rtInfF;
              }
            }

            b = ::coder::internal::minimum(dists, mc);
            neighborIdx = mc;
            if (std::isinf(b)) {
              neighborIdx = -1.0;
            }

            return neighborIdx;
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &pointVectors
          //                const ::coder::array<float, 1U> &euclideanDists
          //                const float v[2]
          // Return Type  : double
          //
          double Checkerboard::findNeighbor(const ::coder::array<float, 2U>
            &pointVectors, const ::coder::array<float, 1U> &euclideanDists,
            const float v[2]) const
          {
            array<float, 1U> angleCosines;
            array<float, 1U> dists;
            array<int, 1U> r;
            double neighborIdx;
            float b;
            int aoffset;
            int mc;
            if (pointVectors.size(1) != 2) {
              if ((pointVectors.size(0) == 1) && (pointVectors.size(1) == 1)) {
                k_rtErrorWithMessageID(i_emlrtRTEI.fName, i_emlrtRTEI.lineNo);
              } else {
                l_rtErrorWithMessageID(j_emlrtRTEI.fName, j_emlrtRTEI.lineNo);
              }
            }

            mc = pointVectors.size(0);
            angleCosines.set_size(pointVectors.size(0));
            if (pointVectors.size(0) > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int i{0}; i < mc; i++) {
              angleCosines[i] = 0.0F;
            }

            for (int k{0}; k < 2; k++) {
              aoffset = k * pointVectors.size(0);
              for (int i{0}; i < mc; i++) {
                angleCosines[i] = angleCosines[i] + pointVectors[aoffset + i] *
                  v[k];
              }
            }

            b = rt_hypotf_snf(v[0], v[1]);
            dists.set_size(euclideanDists.size(0));
            mc = euclideanDists.size(0);
            for (aoffset = 0; aoffset < mc; aoffset++) {
              dists[aoffset] = euclideanDists[aoffset] * b;
            }

            if ((angleCosines.size(0) != 1) && (dists.size(0) != 1) &&
                (angleCosines.size(0) != dists.size(0))) {
              j_rtErrorWithMessageID(h_emlrtRTEI.fName, h_emlrtRTEI.lineNo);
            }

            if (angleCosines.size(0) == dists.size(0)) {
              mc = angleCosines.size(0);
              for (aoffset = 0; aoffset < mc; aoffset++) {
                angleCosines[aoffset] = angleCosines[aoffset] / dists[aoffset];
              }
            } else {
              rdivide(angleCosines, dists);
            }

            dists.set_size(euclideanDists.size(0));
            mc = euclideanDists.size(0);
            for (aoffset = 0; aoffset < mc; aoffset++) {
              dists[aoffset] = 1.5F * euclideanDists[aoffset];
            }

            if ((dists.size(0) != angleCosines.size(0)) && ((dists.size(0) != 1)
                 && (angleCosines.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(dists.size(0), angleCosines.size(0),
                s_emlrtECI);
            }

            if (dists.size(0) == angleCosines.size(0)) {
              mc = dists.size(0);
              for (aoffset = 0; aoffset < mc; aoffset++) {
                dists[aoffset] = dists[aoffset] * (1.0F - angleCosines[aoffset]);
              }
            } else {
              binary_expand_op(dists, angleCosines);
            }

            if ((euclideanDists.size(0) != dists.size(0)) &&
                ((euclideanDists.size(0) != 1) && (dists.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(euclideanDists.size(0), dists.size(0),
                r_emlrtECI);
            }

            if (euclideanDists.size(0) == dists.size(0)) {
              dists.set_size(euclideanDists.size(0));
              mc = euclideanDists.size(0);
              for (aoffset = 0; aoffset < mc; aoffset++) {
                dists[aoffset] = euclideanDists[aoffset] + dists[aoffset];
              }
            } else {
              plus(dists, euclideanDists);
            }

            aoffset = BoardIdx.size(0) * BoardIdx.size(1) - 1;
            mc = 0;
            for (int i{0}; i <= aoffset; i++) {
              if (BoardIdx[i] > 0.0) {
                mc++;
              }
            }

            r.set_size(mc);
            mc = 0;
            for (int i{0}; i <= aoffset; i++) {
              if (BoardIdx[i] > 0.0) {
                double d;
                if (i > aoffset) {
                  rtDynamicBoundsError(i, 0, aoffset, r_emlrtBCI);
                }

                d = BoardIdx[i];
                if (d != static_cast<int>(std::floor(d))) {
                  rtIntegerError(d, emlrtDCI);
                }

                if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                     dists.size(0))) {
                  rtDynamicBoundsError(static_cast<int>(d), 1, dists.size(0),
                                       q_emlrtBCI);
                }

                r[mc] = static_cast<int>(d);
                mc++;
              }
            }

            mc = r.size(0);
            for (aoffset = 0; aoffset < mc; aoffset++) {
              dists[r[aoffset] - 1] = rtInfF;
            }

            mc = angleCosines.size(0) - 1;
            for (int i{0}; i <= mc; i++) {
              if (angleCosines[i] < 0.0F) {
                if (i > dists.size(0) - 1) {
                  rtDynamicBoundsError(i, 0, dists.size(0) - 1, s_emlrtBCI);
                }

                dists[i] = rtInfF;
              }
            }

            b = ::coder::internal::minimum(dists, mc);
            neighborIdx = mc;
            if (std::isinf(b)) {
              neighborIdx = -1.0;
            }

            return neighborIdx;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                const ::coder::array<double, 1U> &validIdx
          //                double currIdx
          //                const double coordsToUse[2]
          //                double &moveMultiplier
          //                double &firstValidIdx
          // Return Type  : double
          //
          double Checkerboard::findSearchParams(const ::coder::array<double, 2U>
            &idx, const ::coder::array<double, 1U> &validIdx, double currIdx,
            const double coordsToUse[2], double &moveMultiplier, double
            &firstValidIdx) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              535,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              536,                     // lineNo
              51,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              549,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              549,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              549,                     // lineNo
              64,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              535,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              549,                     // lineNo
              72,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              550,                     // lineNo
              51,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              550,                     // lineNo
              42,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            double coordDist;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), pf_emlrtBCI);
            }

            if (idx[0] == 1.0) {
              int i;
              if (validIdx.size(0) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(0), vf_emlrtBCI);
              }

              if (validIdx.size(0) < 2) {
                rtDynamicBoundsError(2, 1, validIdx.size(0), rf_emlrtBCI);
              }

              i = BoardCoords.size(0);
              if ((static_cast<int>(validIdx[0]) < 1) || (static_cast<int>
                   (validIdx[0]) > i)) {
                rtDynamicBoundsError(static_cast<int>(validIdx[0]), 1, i,
                                     tb_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if ((static_cast<int>(currIdx) < 1) || (static_cast<int>(currIdx) >
                   i)) {
                rtDynamicBoundsError(static_cast<int>(currIdx), 1, i,
                                     sb_emlrtBCI);
              }

              i = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i,
                                     qf_emlrtBCI);
              }

              i = BoardCoords.size(0);
              if ((static_cast<int>(validIdx[1]) < 1) || (static_cast<int>
                   (validIdx[1]) > i)) {
                rtDynamicBoundsError(static_cast<int>(validIdx[1]), 1, i,
                                     rb_emlrtBCI);
              }

              if (validIdx.size(0) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(0), of_emlrtBCI);
              }

              moveMultiplier = validIdx[0];
              firstValidIdx = validIdx[0];
              if (validIdx.size(0) < 2) {
                rtDynamicBoundsError(2, 1, validIdx.size(0), nf_emlrtBCI);
              }

              if (validIdx.size(0) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(0), mf_emlrtBCI);
              }

              coordDist = (BoardCoords[((static_cast<int>(validIdx[0]) +
                BoardCoords.size(0) * (static_cast<int>(currIdx) - 1)) +
                BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                (coordsToUse[0]) - 1)) - 1] - BoardCoords[((static_cast<int>
                (validIdx[1]) + BoardCoords.size(0) * (static_cast<int>(currIdx)
                - 1)) + BoardCoords.size(0) * BoardCoords.size(1) * (
                static_cast<int>(coordsToUse[0]) - 1)) - 1]) / (validIdx[1] -
                validIdx[0]);
            } else {
              double d;
              int i;
              bool b;
              i = BoardCoords.size(0);
              b = (validIdx.size(0) < 1);
              if (b) {
                rtDynamicBoundsError(validIdx.size(0), 1, validIdx.size(0),
                                     sf_emlrtBCI);
              }

              firstValidIdx = validIdx[validIdx.size(0) - 1];
              if ((static_cast<int>(firstValidIdx) < 1) || (static_cast<int>
                   (firstValidIdx) > i)) {
                rtDynamicBoundsError(static_cast<int>(firstValidIdx), 1, i,
                                     tf_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if ((static_cast<int>(currIdx) < 1) || (static_cast<int>(currIdx) >
                   i)) {
                rtDynamicBoundsError(static_cast<int>(currIdx), 1, i,
                                     uf_emlrtBCI);
              }

              i = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i,
                                     wf_emlrtBCI);
              }

              i = BoardCoords.size(0);
              b = ((validIdx.size(0) - 1 < 1) || (validIdx.size(0) - 1 >
                    validIdx.size(0)));
              if (b) {
                rtDynamicBoundsError(validIdx.size(0) - 1, 1, validIdx.size(0),
                                     xf_emlrtBCI);
              }

              d = validIdx[validIdx.size(0) - 2];
              if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > i)) {
                rtDynamicBoundsError(static_cast<int>(d), 1, i, yf_emlrtBCI);
              }

              moveMultiplier = (static_cast<double>(BoardCoords.size(0)) -
                                firstValidIdx) + 1.0;
              coordDist = (BoardCoords[((static_cast<int>(firstValidIdx) +
                BoardCoords.size(0) * (static_cast<int>(currIdx) - 1)) +
                BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                (coordsToUse[0]) - 1)) - 1] - BoardCoords[((static_cast<int>
                (validIdx[validIdx.size(0) - 2]) + BoardCoords.size(0) * (
                static_cast<int>(currIdx) - 1)) + BoardCoords.size(0) *
                BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1)) -
                           1]) / (firstValidIdx - d);
            }

            return coordDist;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                const ::coder::array<double, 2U> &validIdx
          //                double currIdx
          //                const double coordsToUse[2]
          //                double &moveMultiplier
          //                double &firstValidIdx
          // Return Type  : double
          //
          double Checkerboard::findSearchParams(const ::coder::array<double, 2U>
            &idx, const ::coder::array<double, 2U> &validIdx, double currIdx,
            const double coordsToUse[2], double &moveMultiplier, double
            &firstValidIdx) const
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              539,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              538,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              555,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              555,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              554,                     // lineNo
              72,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              554,                     // lineNo
              58,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              554,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              554,                     // lineNo
              50,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              538,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/findSearchParams",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            double coordDist;
            if (idx.size(1) < 1) {
              rtDynamicBoundsError(1, 1, idx.size(1), pf_emlrtBCI);
            }

            if (idx[0] == 1.0) {
              int i;
              int i1;
              int i2;
              if (validIdx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(1), yf_emlrtBCI);
              }

              if (validIdx.size(1) < 2) {
                rtDynamicBoundsError(2, 1, validIdx.size(1), qf_emlrtBCI);
              }

              i = BoardCoords.size(0);
              if ((static_cast<int>(currIdx) < 1) || (static_cast<int>(currIdx) >
                   i)) {
                rtDynamicBoundsError(static_cast<int>(currIdx), 1, i,
                                     yd_emlrtBCI);
              }

              i = BoardCoords.size(1);
              i1 = static_cast<int>(validIdx[0]);
              if ((i1 < 1) || (i1 > i)) {
                rtDynamicBoundsError(i1, 1, i, xd_emlrtBCI);
              }

              i = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i,
                                     rf_emlrtBCI);
              }

              i = BoardCoords.size(1);
              i2 = static_cast<int>(validIdx[1]);
              if ((i2 < 1) || (i2 > i)) {
                rtDynamicBoundsError(i2, 1, i, vd_emlrtBCI);
              }

              if (validIdx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(1), of_emlrtBCI);
              }

              moveMultiplier = validIdx[0];
              firstValidIdx = validIdx[0];
              if (validIdx.size(1) < 2) {
                rtDynamicBoundsError(2, 1, validIdx.size(1), nf_emlrtBCI);
              }

              if (validIdx.size(1) < 1) {
                rtDynamicBoundsError(1, 1, validIdx.size(1), mf_emlrtBCI);
              }

              coordDist = (BoardCoords[((static_cast<int>(currIdx) +
                BoardCoords.size(0) * (i1 - 1)) + BoardCoords.size(0) *
                BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1)) -
                           1] - BoardCoords[((static_cast<int>(currIdx) +
                BoardCoords.size(0) * (i2 - 1)) + BoardCoords.size(0) *
                BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1)) -
                           1]) / (validIdx[1] - validIdx[0]);
            } else {
              double d;
              int i;
              bool b;
              i = BoardCoords.size(0);
              if ((static_cast<int>(currIdx) < 1) || (static_cast<int>(currIdx) >
                   i)) {
                rtDynamicBoundsError(static_cast<int>(currIdx), 1, i,
                                     xf_emlrtBCI);
              }

              i = BoardCoords.size(1);
              b = (validIdx.size(1) < 1);
              if (b) {
                rtDynamicBoundsError(validIdx.size(1), 1, validIdx.size(1),
                                     wf_emlrtBCI);
              }

              firstValidIdx = validIdx[validIdx.size(1) - 1];
              if ((static_cast<int>(firstValidIdx) < 1) || (static_cast<int>
                   (firstValidIdx) > i)) {
                rtDynamicBoundsError(static_cast<int>(firstValidIdx), 1, i,
                                     vf_emlrtBCI);
              }

              i = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i,
                                     uf_emlrtBCI);
              }

              i = BoardCoords.size(1);
              b = ((validIdx.size(1) - 1 < 1) || (validIdx.size(1) - 1 >
                    validIdx.size(1)));
              if (b) {
                rtDynamicBoundsError(validIdx.size(1) - 1, 1, validIdx.size(1),
                                     tf_emlrtBCI);
              }

              d = validIdx[validIdx.size(1) - 2];
              if ((static_cast<int>(d) < 1) || (static_cast<int>(d) > i)) {
                rtDynamicBoundsError(static_cast<int>(d), 1, i, sf_emlrtBCI);
              }

              moveMultiplier = (static_cast<double>(BoardCoords.size(1)) -
                                firstValidIdx) + 1.0;
              coordDist = (BoardCoords[((static_cast<int>(currIdx) +
                BoardCoords.size(0) * (static_cast<int>(firstValidIdx) - 1)) +
                BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                (coordsToUse[0]) - 1)) - 1] - BoardCoords[((static_cast<int>
                (currIdx) + BoardCoords.size(0) * (static_cast<int>
                (validIdx[validIdx.size(1) - 2]) - 1)) + BoardCoords.size(0) *
                BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1)) -
                           1]) / (firstValidIdx - d);
            }

            return coordDist;
          }

          //
          // Arguments    : const ::coder::array<double, 2U> &idx
          //                ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::fitPolynomialIndices(const ::coder::array<double,
            2U> &idx, ::coder::array<double, 2U> &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> removedIdx;
            array<double, 1U> b_this;
            array<double, 1U> e_this;
            array<double, 1U> validIdx;
            array<int, 1U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            double moveDistMultiplier;
            double refCoordValue;
            int i;
            int loop_ub;
            findIndependentVar(idx, coordsToUse);
            newIndices.set_size(1, BoardCoords.size(1));
            loop_ub = BoardCoords.size(1);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(1);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(1);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ob_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     pb_emlrtBCI);
              }

              b_this.set_size(BoardCoords.size(0));
              loop_ub = BoardCoords.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_this[i1] = BoardCoords[(i1 + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(b_this, ii);
              validIdx.set_size(ii.size(0));
              loop_ub = ii.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                validIdx[i1] = ii[i1];
              }

              if (validIdx.size(0) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                int currCurve_size[2];
                int c_this;
                int d_this;
                int i2;
                int n;
                bool exitg1;
                coordDist = findSearchParams(idx, validIdx, static_cast<double>
                  (j) + 1.0, coordsToUse, moveDistMultiplier, refCoordValue);
                n = 0;
                i1 = validIdx.size(0);
                for (loop_ub = 0; loop_ub < i1; loop_ub++) {
                  if (validIdx[loop_ub] != 0.0) {
                    n++;
                  }
                }

                c_this = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, ub_emlrtBCI);
                }

                d_this = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, vb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       wb_emlrtBCI);
                }

                b_this.set_size(validIdx.size(0));
                loop_ub = validIdx.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  i2 = static_cast<int>(validIdx[i1]);
                  if ((i2 < 1) || (i2 > c_this)) {
                    rtDynamicBoundsError(i2, 1, c_this, xb_emlrtBCI);
                  }

                  b_this[i1] = BoardCoords[((i2 + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[0]) - 1)) - 1];
                }

                e_this.set_size(validIdx.size(0));
                loop_ub = validIdx.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  i2 = static_cast<int>(validIdx[i1]);
                  if ((i2 < 1) || (i2 > d_this)) {
                    rtDynamicBoundsError(i2, 1, d_this, yb_emlrtBCI);
                  }

                  e_this[i1] = BoardCoords[((i2 + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[1]) - 1)) - 1];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(b_this, e_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(0);
                if ((static_cast<int>(refCoordValue) < 1) || (static_cast<int>
                     (refCoordValue) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(refCoordValue), 1, i1,
                                       ac_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, bc_emlrtBCI);
                }

                refCoordValue = BoardCoords[((static_cast<int>(refCoordValue) +
                  BoardCoords.size(0) * j) + BoardCoords.size(0) *
                  BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1))
                  - 1];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     moveDistMultiplier * 1.5 * std::abs
                                     (coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  bool p;
                  p = true;
                  loop_ub = 0;
                  exitg2 = false;
                  while ((!exitg2) && (loop_ub < 2)) {
                    if (!(coordsToUse[loop_ub] == static_cast<double>(loop_ub) +
                          1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      loop_ub++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (loop_ub = 0; loop_ub <= i1 - 2; loop_ub++) {
                      y = currCoord * y + currCurve_data[loop_ub + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (loop_ub = 0; loop_ub <= i1 - 2; loop_ub++) {
                      y = currCoord * y + currCurve_data[loop_ub + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (i2 = 0; i2 < loop_ub; i2++) {
                      removedIdx[i1 + i2] = b_index[i2];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }
          }

          //
          // Arguments    : ::coder::array<double, 2U> &newIndices
          // Return Type  : void
          //
          void Checkerboard::fitPolynomialIndices(::coder::array<double, 2U>
            &newIndices) const
          {
            array<double, 2U> b_index;
            array<double, 2U> removedIdx;
            array<double, 1U> b_this;
            array<double, 1U> d_this;
            array<int, 1U> ii;
            double currCurve_data[5];
            double coordsToUse[2];
            int i;
            int loop_ub;
            findIndependentVar(coordsToUse);
            newIndices.set_size(1, BoardCoords.size(1));
            loop_ub = BoardCoords.size(1);
            for (i = 0; i < loop_ub; i++) {
              newIndices[i] = 0.0;
            }

            removedIdx.set_size(1, 0);
            i = BoardCoords.size(1);
            for (int j{0}; j < i; j++) {
              int i1;
              i1 = BoardCoords.size(1);
              if (j + 1 > i1) {
                rtDynamicBoundsError(j + 1, 1, i1, ob_emlrtBCI);
              }

              i1 = BoardCoords.size(2);
              if ((static_cast<int>(coordsToUse[0]) < 1) || (static_cast<int>
                   (coordsToUse[0]) > i1)) {
                rtDynamicBoundsError(static_cast<int>(coordsToUse[0]), 1, i1,
                                     pb_emlrtBCI);
              }

              b_this.set_size(BoardCoords.size(0));
              loop_ub = BoardCoords.size(0);
              for (i1 = 0; i1 < loop_ub; i1++) {
                b_this[i1] = BoardCoords[(i1 + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)];
              }

              eml_find(b_this, ii);
              if (ii.size(0) >= 2) {
                double coordDist;
                double currCoord;
                double currRad;
                double refCoordValue;
                int currCurve_size[2];
                int c_this;
                int k;
                int n;
                bool exitg1;
                bool p;
                i1 = BoardCoords.size(0);
                p = ((ii[0] < 1) || (ii[0] > i1));
                if (p) {
                  rtDynamicBoundsError(ii[0], 1, i1, tb_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, sb_emlrtBCI);
                }

                i1 = BoardCoords.size(0);
                if ((ii[1] < 1) || (ii[1] > i1)) {
                  rtDynamicBoundsError(ii[1], 1, i1, rb_emlrtBCI);
                }

                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, qb_emlrtBCI);
                }

                currRad = coordsToUse[0];
                coordDist = (BoardCoords[((ii[0] + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)) - 1] - BoardCoords[((ii[1] +
                  BoardCoords.size(0) * j) + BoardCoords.size(0) *
                  BoardCoords.size(1) * (static_cast<int>(coordsToUse[0]) - 1))
                             - 1]) / (static_cast<double>(ii[1]) - static_cast<
                                      double>(ii[0]));
                n = 0;
                i1 = ii.size(0);
                for (k = 0; k < i1; k++) {
                  if (ii[k] != 0) {
                    n++;
                  }
                }

                k = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, ub_emlrtBCI);
                }

                c_this = BoardCoords.size(0);
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, vb_emlrtBCI);
                }

                i1 = BoardCoords.size(2);
                if ((static_cast<int>(coordsToUse[1]) < 1) || (static_cast<int>
                     (coordsToUse[1]) > i1)) {
                  rtDynamicBoundsError(static_cast<int>(coordsToUse[1]), 1, i1,
                                       wb_emlrtBCI);
                }

                b_this.set_size(ii.size(0));
                loop_ub = ii.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > k)) {
                    rtDynamicBoundsError(ii[i1], 1, k, xb_emlrtBCI);
                  }

                  b_this[i1] = BoardCoords[((ii[i1] + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (currRad) - 1)) - 1];
                }

                d_this.set_size(ii.size(0));
                loop_ub = ii.size(0);
                for (i1 = 0; i1 < loop_ub; i1++) {
                  if ((ii[i1] < 1) || (ii[i1] > c_this)) {
                    rtDynamicBoundsError(ii[i1], 1, c_this, yb_emlrtBCI);
                  }

                  d_this[i1] = BoardCoords[((ii[i1] + BoardCoords.size(0) * j) +
                    BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                    (coordsToUse[1]) - 1)) - 1];
                }

                if (n > 5) {
                  i1 = 4;
                } else {
                  i1 = 2;
                }

                polyfit(b_this, d_this, static_cast<double>(i1), currCurve_data,
                        currCurve_size);
                currRad = coordDist / 4.0;
                i1 = BoardCoords.size(1);
                if (j + 1 > i1) {
                  rtDynamicBoundsError(j + 1, 1, i1, bc_emlrtBCI);
                }

                refCoordValue = BoardCoords[((ii[0] + BoardCoords.size(0) * j) +
                  BoardCoords.size(0) * BoardCoords.size(1) * (static_cast<int>
                  (coordsToUse[0]) - 1)) - 1];
                currCoord = currRad + refCoordValue;
                exitg1 = false;
                while ((!exitg1) && (std::abs(currCoord - refCoordValue) <
                                     static_cast<double>(ii[0]) * 1.5 * std::abs
                                     (coordDist))) {
                  double currPt[2];
                  bool exitg2;
                  p = true;
                  k = 0;
                  exitg2 = false;
                  while ((!exitg2) && (k < 2)) {
                    if (!(coordsToUse[k] == static_cast<double>(k) + 1.0)) {
                      p = false;
                      exitg2 = true;
                    } else {
                      k++;
                    }
                  }

                  if (p) {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = currCoord;
                    currPt[1] = y;
                  } else {
                    double y;
                    y = currCurve_data[0];
                    i1 = currCurve_size[1];
                    for (k = 0; k <= i1 - 2; k++) {
                      y = currCoord * y + currCurve_data[k + 1];
                    }

                    currPt[0] = y;
                    currPt[1] = currCoord;
                  }

                  findClosestOnCurve(currPt, std::abs(currRad), currCurve_data,
                                     currCurve_size, coordsToUse, removedIdx,
                                     b_index);
                  if (b_index.size(1) != 0) {
                    if (b_index.size(1) != 1) {
                      rtSizeEq1DError(1, b_index.size(1), x_emlrtECI);
                    }

                    if (j + 1 > newIndices.size(1)) {
                      rtDynamicBoundsError(j + 1, 1, newIndices.size(1),
                                           nb_emlrtBCI);
                    }

                    newIndices[j] = b_index[0];
                    i1 = removedIdx.size(1);
                    loop_ub = b_index.size(1);
                    removedIdx.set_size(removedIdx.size(0), removedIdx.size(1) +
                                        b_index.size(1));
                    for (k = 0; k < loop_ub; k++) {
                      removedIdx[i1 + k] = b_index[k];
                    }

                    exitg1 = true;
                  } else {
                    currCoord += currRad;
                  }
                }
              }
            }
          }

          //
          // Arguments    : double seedIdx
          //                const ::coder::array<float, 2U> &points
          //                const float v1[2]
          //                const float v2[2]
          // Return Type  : void
          //
          void Checkerboard::initialize(double seedIdx, const ::coder::array<
            float, 2U> &points, const float v1[2], const float v2[2])
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              82,                      // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ah_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              98,                      // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ai_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              118,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              82,                      // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              106,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bi_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              118,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              83,                      // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ch_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              106,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ci_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              118,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              83,                      // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              107,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo di_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              118,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              84,                      // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              107,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              84,                      // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              108,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              91,                      // lineNo
              43,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              108,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo hg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              91,                      // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo hh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              109,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ig_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              91,                      // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ih_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              109,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo jg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              92,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo jh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              115,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo kg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              92,                      // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo kh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              115,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo lg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              93,                      // lineNo
              43,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo lh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              115,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo mg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              93,                      // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo mh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              115,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ng_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              93,                      // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo nh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              115,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo og_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              94,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo oh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              116,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo pg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              94,                      // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ph_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              116,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              69,                      // lineNo
              34,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              95,                      // lineNo
              43,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              116,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              70,                      // lineNo
              27,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              95,                      // lineNo
              46,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              116,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              70,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              95,                      // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              116,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              71,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              96,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo th_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              117,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              71,                      // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ug_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              96,                      // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              117,                     // lineNo
              33,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              78,                      // lineNo
              52,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              97,                      // lineNo
              43,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              117,                     // lineNo
              67,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              78,                      // lineNo
              72,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              97,                      // lineNo
              45,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              117,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              81,                      // lineNo
              28,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              97,                      // lineNo
              29,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              117,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              81,                      // lineNo
              31,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              98,                      // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              118,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 91,// lineNo
              29,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 93,// lineNo
              29,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 95,// lineNo
              29,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 97,// lineNo
              29,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo k_emlrtDCI{ 115,// lineNo
              53,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo l_emlrtDCI{ 116,// lineNo
              53,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo m_emlrtDCI{ 117,// lineNo
              53,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo n_emlrtDCI{ 118,// lineNo
              53,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo ac_emlrtECI{ -1,// nDims
              116,                     // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo bc_emlrtECI{ -1,// nDims
              117,                     // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo cc_emlrtECI{ -1,// nDims
              118,                     // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              71,                      // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              92,                      // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo nb_emlrtECI{ -1,// nDims
              94,                      // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
              96,                      // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo pb_emlrtECI{ -1,// nDims
              98,                      // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo qb_emlrtECI{ 2,// nDims
              101,                     // lineNo
              21,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo rb_emlrtECI{ 2,// nDims
              102,                     // lineNo
              21,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo sb_emlrtECI{ 2,// nDims
              103,                     // lineNo
              21,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo tb_emlrtECI{ 2,// nDims
              104,                     // lineNo
              21,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo ub_emlrtECI{ 2,// nDims
              106,                     // lineNo
              86,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo vb_emlrtECI{ 2,// nDims
              107,                     // lineNo
              86,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo wb_emlrtECI{ 2,// nDims
              108,                     // lineNo
              86,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo xb_emlrtECI{ 2,// nDims
              109,                     // lineNo
              86,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            static rtEqualityCheckInfo yb_emlrtECI{ -1,// nDims
              115,                     // lineNo
              13,                      // colNo
              "Checkerboard/initialize",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m"// pName
            };

            array<double, 2U> b_r;
            array<float, 2U> b_u;
            array<float, 2U> d;
            array<float, 2U> l;
            array<float, 2U> pointVectors;
            array<float, 2U> r;
            array<float, 2U> u;
            array<float, 1U> b_pointVectors;
            array<float, 1U> c_pointVectors;
            array<float, 1U> euclideanDists;
            array<bool, 1U> b_this;
            float b_v1[2];
            int iv[3];
            int iv1[2];
            int csz_idx_1;
            int i;
            int i1;
            int varargin_2;
            BoardIdx.set_size(3, 3);
            for (i = 0; i < 9; i++) {
              BoardIdx[i] = 0.0;
            }

            IsDirectionBad[0] = false;
            IsDirectionBad[1] = false;
            IsDirectionBad[2] = false;
            IsDirectionBad[3] = false;
            BoardCoords.set_size(3, 3, 2);
            for (i = 0; i < 18; i++) {
              BoardCoords[i] = 0.0;
            }

            Points.set_size(points.size(0), 2);
            csz_idx_1 = points.size(0) << 1;
            for (i = 0; i < csz_idx_1; i++) {
              Points[i] = points[i];
            }

            i = Points.size(0);
            if ((static_cast<int>(seedIdx) < 1) || (static_cast<int>(seedIdx) >
                 i)) {
              rtDynamicBoundsError(static_cast<int>(seedIdx), 1, i, qf_emlrtBCI);
            }

            i = BoardIdx.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, rf_emlrtBCI);
            }

            i = BoardIdx.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, sf_emlrtBCI);
            }

            BoardIdx[BoardIdx.size(0) + 1] = seedIdx;
            i = BoardCoords.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, tf_emlrtBCI);
            }

            i = BoardCoords.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, uf_emlrtBCI);
            }

            iv[0] = 1;
            iv[1] = 1;
            iv[2] = BoardCoords.size(2);
            iv1[0] = 1;
            iv1[1] = Points.size(1);
            rtSubAssignSizeCheck(&iv[0], 3, &iv1[0], 2, lb_emlrtECI);
            csz_idx_1 = BoardCoords.size(2);
            for (i = 0; i < csz_idx_1; i++) {
              BoardCoords[(BoardCoords.size(0) + BoardCoords.size(0) *
                           BoardCoords.size(1) * i) + 1] = Points[(static_cast<
                int>(seedIdx) + Points.size(0) * i) - 1];
            }

            LastExpandDirection = 1.0;
            PreviousEnergy = rtInfF;
            isValid = false;
            csz_idx_1 = Points.size(1);
            pointVectors.set_size(Points.size(0), Points.size(1));
            if ((Points.size(0) != 0) && (csz_idx_1 != 0)) {
              int acoef;
              int bcoef;
              acoef = (Points.size(1) != 1);
              bcoef = (Points.size(1) != 1);
              i = csz_idx_1 - 1;
              csz_idx_1 = (Points.size(0) != 1);
              for (int k{0}; k <= i; k++) {
                int varargin_3;
                varargin_2 = acoef * k;
                varargin_3 = bcoef * k;
                i1 = pointVectors.size(0) - 1;
                for (int b_k{0}; b_k <= i1; b_k++) {
                  pointVectors[b_k + pointVectors.size(0) * k] =
                    Points[csz_idx_1 * b_k + Points.size(0) * varargin_2] -
                    Points[(static_cast<int>(seedIdx) + Points.size(0) *
                            varargin_3) - 1];
                }
              }
            }

            if (pointVectors.size(1) < 1) {
              rtDynamicBoundsError(1, 1, pointVectors.size(1), vf_emlrtBCI);
            }

            if (pointVectors.size(1) < 2) {
              rtDynamicBoundsError(2, 1, pointVectors.size(1), wf_emlrtBCI);
            }

            b_pointVectors.set_size(pointVectors.size(0));
            csz_idx_1 = pointVectors.size(0);
            c_pointVectors.set_size(pointVectors.size(0));
            for (i = 0; i < csz_idx_1; i++) {
              b_pointVectors[i] = pointVectors[i];
              c_pointVectors[i] = pointVectors[i + pointVectors.size(0)];
            }

            b_hypot(b_pointVectors, c_pointVectors, euclideanDists);
            i = BoardIdx.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, xf_emlrtBCI);
            }

            i = BoardIdx.size(1);
            if (i < 3) {
              rtDynamicBoundsError(3, 1, i, yf_emlrtBCI);
            }

            BoardIdx[BoardIdx.size(0) * 2 + 1] = findNeighbor(pointVectors,
              euclideanDists, v1);
            i = BoardIdx.size(0);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, ag_emlrtBCI);
            }

            i = BoardIdx.size(1);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, bg_emlrtBCI);
            }

            b_v1[0] = -v1[0];
            b_v1[1] = -v1[1];
            BoardIdx[1] = findNeighbor(pointVectors, euclideanDists, b_v1);
            i = BoardIdx.size(0);
            if (i < 3) {
              rtDynamicBoundsError(3, 1, i, cg_emlrtBCI);
            }

            i = BoardIdx.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, dg_emlrtBCI);
            }

            BoardIdx[BoardIdx.size(0) + 2] = findNeighbor(pointVectors,
              euclideanDists, v2);
            i = BoardIdx.size(0);
            if (i < 1) {
              rtDynamicBoundsError(1, 1, i, eg_emlrtBCI);
            }

            i = BoardIdx.size(1);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, fg_emlrtBCI);
            }

            b_v1[0] = -v2[0];
            b_v1[1] = -v2[1];
            BoardIdx[BoardIdx.size(0)] = findNeighbor(pointVectors,
              euclideanDists, b_v1);
            csz_idx_1 = BoardIdx.size(0) * BoardIdx.size(1);
            b_this.set_size(csz_idx_1);
            for (i = 0; i < csz_idx_1; i++) {
              b_this[i] = (BoardIdx[i] < 0.0);
            }

            if (any(b_this)) {
              isValid = false;
            } else {
              bool exitg1;
              i = BoardIdx.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, gg_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, hg_emlrtBCI);
              }

              if (BoardIdx[BoardIdx.size(0) * 2 + 1] != static_cast<int>(std::
                   floor(BoardIdx[BoardIdx.size(0) * 2 + 1]))) {
                rtIntegerError(BoardIdx[BoardIdx.size(0) * 2 + 1], g_emlrtDCI);
              }

              i = Points.size(0);
              varargin_2 = static_cast<int>(BoardIdx[BoardIdx.size(0) * 2 + 1]);
              if ((varargin_2 < 1) || (varargin_2 > i)) {
                rtDynamicBoundsError(static_cast<int>(BoardIdx[BoardIdx.size(0) *
                  2 + 1]), 1, i, ig_emlrtBCI);
              }

              r.set_size(1, Points.size(1));
              csz_idx_1 = Points.size(1);
              for (i = 0; i < csz_idx_1; i++) {
                r[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
              }

              i = BoardCoords.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, jg_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, kg_emlrtBCI);
              }

              iv[0] = 1;
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = Points.size(1);
              rtSubAssignSizeCheck(&iv[0], 3, &iv1[0], 2, mb_emlrtECI);
              csz_idx_1 = BoardCoords.size(2);
              for (i = 0; i < csz_idx_1; i++) {
                BoardCoords[(BoardCoords.size(0) * 2 + BoardCoords.size(0) *
                             BoardCoords.size(1) * i) + 1] = r[i];
              }

              i = BoardIdx.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, lg_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, mg_emlrtBCI);
              }

              if (BoardIdx[1] != static_cast<int>(std::floor(BoardIdx[1]))) {
                rtIntegerError(BoardIdx[1], h_emlrtDCI);
              }

              i = Points.size(0);
              varargin_2 = static_cast<int>(BoardIdx[1]);
              if ((varargin_2 < 1) || (varargin_2 > i)) {
                rtDynamicBoundsError(static_cast<int>(BoardIdx[1]), 1, i,
                                     ng_emlrtBCI);
              }

              l.set_size(1, Points.size(1));
              csz_idx_1 = Points.size(1);
              for (i = 0; i < csz_idx_1; i++) {
                l[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
              }

              i = BoardCoords.size(0);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, og_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, pg_emlrtBCI);
              }

              iv[0] = 1;
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = Points.size(1);
              rtSubAssignSizeCheck(&iv[0], 3, &iv1[0], 2, nb_emlrtECI);
              csz_idx_1 = BoardCoords.size(2);
              for (i = 0; i < csz_idx_1; i++) {
                BoardCoords[BoardCoords.size(0) * BoardCoords.size(1) * i + 1] =
                  l[i];
              }

              i = BoardIdx.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, qg_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, rg_emlrtBCI);
              }

              if (BoardIdx[BoardIdx.size(0) + 2] != static_cast<int>(std::floor
                   (BoardIdx[BoardIdx.size(0) + 2]))) {
                rtIntegerError(BoardIdx[BoardIdx.size(0) + 2], i_emlrtDCI);
              }

              i = Points.size(0);
              varargin_2 = static_cast<int>(BoardIdx[BoardIdx.size(0) + 2]);
              if ((varargin_2 < 1) || (varargin_2 > i)) {
                rtDynamicBoundsError(static_cast<int>(BoardIdx[BoardIdx.size(0)
                  + 2]), 1, i, sg_emlrtBCI);
              }

              d.set_size(1, Points.size(1));
              csz_idx_1 = Points.size(1);
              for (i = 0; i < csz_idx_1; i++) {
                d[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
              }

              i = BoardCoords.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, tg_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, ug_emlrtBCI);
              }

              iv[0] = 1;
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = Points.size(1);
              rtSubAssignSizeCheck(&iv[0], 3, &iv1[0], 2, ob_emlrtECI);
              csz_idx_1 = BoardCoords.size(2);
              for (i = 0; i < csz_idx_1; i++) {
                BoardCoords[(BoardCoords.size(0) + BoardCoords.size(0) *
                             BoardCoords.size(1) * i) + 2] = d[i];
              }

              i = BoardIdx.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, vg_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, wg_emlrtBCI);
              }

              if (BoardIdx[BoardIdx.size(0)] != static_cast<int>(std::floor
                   (BoardIdx[BoardIdx.size(0)]))) {
                rtIntegerError(BoardIdx[BoardIdx.size(0)], j_emlrtDCI);
              }

              i = Points.size(0);
              varargin_2 = static_cast<int>(BoardIdx[BoardIdx.size(0)]);
              if ((varargin_2 < 1) || (varargin_2 > i)) {
                rtDynamicBoundsError(static_cast<int>(BoardIdx[BoardIdx.size(0)]),
                                     1, i, xg_emlrtBCI);
              }

              u.set_size(1, Points.size(1));
              csz_idx_1 = Points.size(1);
              for (i = 0; i < csz_idx_1; i++) {
                u[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
              }

              i = BoardCoords.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, yg_emlrtBCI);
              }

              i = BoardCoords.size(1);
              if (i < 2) {
                rtDynamicBoundsError(2, 1, i, ah_emlrtBCI);
              }

              iv[0] = 1;
              iv[1] = 1;
              iv[2] = BoardCoords.size(2);
              iv1[0] = 1;
              iv1[1] = Points.size(1);
              rtSubAssignSizeCheck(&iv[0], 3, &iv1[0], 2, pb_emlrtECI);
              csz_idx_1 = BoardCoords.size(2);
              for (i = 0; i < csz_idx_1; i++) {
                BoardCoords[BoardCoords.size(0) + BoardCoords.size(0) *
                  BoardCoords.size(1) * i] = u[i];
              }

              i = Points.size(1);
              i1 = Points.size(1);
              if ((i != i1) && ((i != 1) && (i1 != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, i1, qb_emlrtECI);
              }

              if (u.size(1) == Points.size(1)) {
                u.set_size(1, u.size(1));
                csz_idx_1 = u.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  u[i] = u[i] - Points[(static_cast<int>(seedIdx) + Points.size
                                        (0) * i) - 1];
                }
              } else {
                binary_expand_op(u, this, seedIdx);
              }

              i = Points.size(1);
              i1 = Points.size(1);
              if ((i != i1) && ((i != 1) && (i1 != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, i1, rb_emlrtECI);
              }

              if (d.size(1) == Points.size(1)) {
                d.set_size(1, d.size(1));
                csz_idx_1 = d.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  d[i] = d[i] - Points[(static_cast<int>(seedIdx) + Points.size
                                        (0) * i) - 1];
                }
              } else {
                binary_expand_op(d, this, seedIdx);
              }

              i = Points.size(1);
              i1 = Points.size(1);
              if ((i != i1) && ((i != 1) && (i1 != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, i1, sb_emlrtECI);
              }

              if (r.size(1) == Points.size(1)) {
                r.set_size(1, r.size(1));
                csz_idx_1 = r.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  r[i] = r[i] - Points[(static_cast<int>(seedIdx) + Points.size
                                        (0) * i) - 1];
                }
              } else {
                binary_expand_op(r, this, seedIdx);
              }

              i = Points.size(1);
              i1 = Points.size(1);
              if ((i != i1) && ((i != 1) && (i1 != 1))) {
                emlrtDimSizeImpxCheckR2021b(i, i1, tb_emlrtECI);
              }

              if (l.size(1) == Points.size(1)) {
                l.set_size(1, l.size(1));
                csz_idx_1 = l.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  l[i] = l[i] - Points[(static_cast<int>(seedIdx) + Points.size
                                        (0) * i) - 1];
                }
              } else {
                binary_expand_op(l, this, seedIdx);
              }

              if ((u.size(1) != l.size(1)) && ((u.size(1) != 1) && (l.size(1) !=
                    1))) {
                emlrtDimSizeImpxCheckR2021b(u.size(1), l.size(1), ub_emlrtECI);
              }

              i = BoardIdx.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, bh_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, ch_emlrtBCI);
              }

              if (u.size(1) == l.size(1)) {
                b_u.set_size(1, u.size(1));
                csz_idx_1 = u.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_u[i] = u[i] + l[i];
                }

                BoardIdx[0] = findNeighbor(pointVectors, euclideanDists, b_u);
              } else {
                d_binary_expand_op(this, pointVectors, euclideanDists, u, l);
              }

              if ((d.size(1) != l.size(1)) && ((d.size(1) != 1) && (l.size(1) !=
                    1))) {
                emlrtDimSizeImpxCheckR2021b(d.size(1), l.size(1), vb_emlrtECI);
              }

              i = BoardIdx.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, dh_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, eh_emlrtBCI);
              }

              if (d.size(1) == l.size(1)) {
                b_u.set_size(1, d.size(1));
                csz_idx_1 = d.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_u[i] = d[i] + l[i];
                }

                BoardIdx[2] = findNeighbor(pointVectors, euclideanDists, b_u);
              } else {
                c_binary_expand_op(this, pointVectors, euclideanDists, d, l);
              }

              if ((d.size(1) != r.size(1)) && ((d.size(1) != 1) && (r.size(1) !=
                    1))) {
                emlrtDimSizeImpxCheckR2021b(d.size(1), r.size(1), wb_emlrtECI);
              }

              i = BoardIdx.size(0);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, fh_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, gh_emlrtBCI);
              }

              if (d.size(1) == r.size(1)) {
                b_u.set_size(1, d.size(1));
                csz_idx_1 = d.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_u[i] = d[i] + r[i];
                }

                BoardIdx[BoardIdx.size(0) * 2 + 2] = findNeighbor(pointVectors,
                  euclideanDists, b_u);
              } else {
                b_binary_expand_op(this, pointVectors, euclideanDists, d, r);
              }

              if ((u.size(1) != r.size(1)) && ((u.size(1) != 1) && (r.size(1) !=
                    1))) {
                emlrtDimSizeImpxCheckR2021b(u.size(1), r.size(1), xb_emlrtECI);
              }

              i = BoardIdx.size(0);
              if (i < 1) {
                rtDynamicBoundsError(1, 1, i, hh_emlrtBCI);
              }

              i = BoardIdx.size(1);
              if (i < 3) {
                rtDynamicBoundsError(3, 1, i, ih_emlrtBCI);
              }

              if (u.size(1) == r.size(1)) {
                b_u.set_size(1, u.size(1));
                csz_idx_1 = u.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_u[i] = u[i] + r[i];
                }

                BoardIdx[BoardIdx.size(0) * 2] = findNeighbor(pointVectors,
                  euclideanDists, b_u);
              } else {
                binary_expand_op(this, pointVectors, euclideanDists, u, r);
              }

              b_this.set_size(BoardIdx.size(0) * BoardIdx.size(1));
              csz_idx_1 = BoardIdx.size(0) * BoardIdx.size(1);
              for (i = 0; i < csz_idx_1; i++) {
                b_this[i] = (BoardIdx[i] > 0.0);
              }

              isValid = true;
              if (b_this.size(0) > 2147483646) {
                check_forloop_overflow_error();
              }

              csz_idx_1 = 1;
              exitg1 = false;
              while ((!exitg1) && (csz_idx_1 <= b_this.size(0))) {
                if (!b_this[csz_idx_1 - 1]) {
                  isValid = false;
                  exitg1 = true;
                } else {
                  csz_idx_1++;
                }
              }

              if (isValid) {
                i = BoardCoords.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, jh_emlrtBCI);
                }

                i = BoardCoords.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, kh_emlrtBCI);
                }

                i = BoardIdx.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, lh_emlrtBCI);
                }

                i = BoardIdx.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, mh_emlrtBCI);
                }

                if (BoardIdx[0] != static_cast<int>(std::floor(BoardIdx[0]))) {
                  rtIntegerError(BoardIdx[0], k_emlrtDCI);
                }

                i = Points.size(0);
                varargin_2 = static_cast<int>(BoardIdx[0]);
                if ((varargin_2 < 1) || (varargin_2 > i)) {
                  rtDynamicBoundsError(static_cast<int>(BoardIdx[0]), 1, i,
                                       nh_emlrtBCI);
                }

                b_r.set_size(1, Points.size(1));
                csz_idx_1 = Points.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_r[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
                }

                iv[0] = 1;
                iv[1] = 1;
                iv[2] = BoardCoords.size(2);
                rtSubAssignSizeCheck(&iv[0], 3, b_r.size(), 2, yb_emlrtECI);
                csz_idx_1 = BoardCoords.size(2);
                for (i = 0; i < csz_idx_1; i++) {
                  BoardCoords[BoardCoords.size(0) * BoardCoords.size(1) * i] =
                    b_r[i];
                }

                i = BoardCoords.size(0);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, oh_emlrtBCI);
                }

                i = BoardCoords.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, ph_emlrtBCI);
                }

                i = BoardIdx.size(0);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, qh_emlrtBCI);
                }

                i = BoardIdx.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, rh_emlrtBCI);
                }

                if (BoardIdx[2] != static_cast<int>(std::floor(BoardIdx[2]))) {
                  rtIntegerError(BoardIdx[2], l_emlrtDCI);
                }

                i = Points.size(0);
                varargin_2 = static_cast<int>(BoardIdx[2]);
                if ((varargin_2 < 1) || (varargin_2 > i)) {
                  rtDynamicBoundsError(static_cast<int>(BoardIdx[2]), 1, i,
                                       sh_emlrtBCI);
                }

                b_r.set_size(1, Points.size(1));
                csz_idx_1 = Points.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_r[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
                }

                iv[0] = 1;
                iv[1] = 1;
                iv[2] = BoardCoords.size(2);
                rtSubAssignSizeCheck(&iv[0], 3, b_r.size(), 2, ac_emlrtECI);
                csz_idx_1 = BoardCoords.size(2);
                for (i = 0; i < csz_idx_1; i++) {
                  BoardCoords[BoardCoords.size(0) * BoardCoords.size(1) * i + 2]
                    = b_r[i];
                }

                i = BoardCoords.size(0);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, th_emlrtBCI);
                }

                i = BoardCoords.size(1);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, uh_emlrtBCI);
                }

                i = BoardIdx.size(0);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, vh_emlrtBCI);
                }

                i = BoardIdx.size(1);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, wh_emlrtBCI);
                }

                if (BoardIdx[BoardIdx.size(0) * 2 + 2] != static_cast<int>(std::
                     floor(BoardIdx[BoardIdx.size(0) * 2 + 2]))) {
                  rtIntegerError(BoardIdx[BoardIdx.size(0) * 2 + 2], m_emlrtDCI);
                }

                i = Points.size(0);
                varargin_2 = static_cast<int>(BoardIdx[BoardIdx.size(0) * 2 + 2]);
                if ((varargin_2 < 1) || (varargin_2 > i)) {
                  rtDynamicBoundsError(static_cast<int>(BoardIdx[BoardIdx.size(0)
                    * 2 + 2]), 1, i, xh_emlrtBCI);
                }

                b_r.set_size(1, Points.size(1));
                csz_idx_1 = Points.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_r[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
                }

                iv[0] = 1;
                iv[1] = 1;
                iv[2] = BoardCoords.size(2);
                rtSubAssignSizeCheck(&iv[0], 3, b_r.size(), 2, bc_emlrtECI);
                csz_idx_1 = BoardCoords.size(2);
                for (i = 0; i < csz_idx_1; i++) {
                  BoardCoords[(BoardCoords.size(0) * 2 + BoardCoords.size(0) *
                               BoardCoords.size(1) * i) + 2] = b_r[i];
                }

                i = BoardCoords.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, yh_emlrtBCI);
                }

                i = BoardCoords.size(1);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, ai_emlrtBCI);
                }

                i = BoardIdx.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, bi_emlrtBCI);
                }

                i = BoardIdx.size(1);
                if (i < 3) {
                  rtDynamicBoundsError(3, 1, i, ci_emlrtBCI);
                }

                if (BoardIdx[BoardIdx.size(0) * 2] != static_cast<int>(std::
                     floor(BoardIdx[BoardIdx.size(0) * 2]))) {
                  rtIntegerError(BoardIdx[BoardIdx.size(0) * 2], n_emlrtDCI);
                }

                i = Points.size(0);
                varargin_2 = static_cast<int>(BoardIdx[BoardIdx.size(0) * 2]);
                if ((varargin_2 < 1) || (varargin_2 > i)) {
                  rtDynamicBoundsError(static_cast<int>(BoardIdx[BoardIdx.size(0)
                    * 2]), 1, i, di_emlrtBCI);
                }

                b_r.set_size(1, Points.size(1));
                csz_idx_1 = Points.size(1);
                for (i = 0; i < csz_idx_1; i++) {
                  b_r[i] = Points[(varargin_2 + Points.size(0) * i) - 1];
                }

                iv[0] = 1;
                iv[1] = 1;
                iv[2] = BoardCoords.size(2);
                rtSubAssignSizeCheck(&iv[0], 3, b_r.size(), 2, cc_emlrtECI);
                csz_idx_1 = BoardCoords.size(2);
                for (i = 0; i < csz_idx_1; i++) {
                  BoardCoords[BoardCoords.size(0) * 2 + BoardCoords.size(0) *
                    BoardCoords.size(1) * i] = b_r[i];
                }

                Energy = computeInitialEnergy();
                if (IsDistortionHigh) {
                  i = -5;
                } else {
                  i = -7;
                }

                isValid = (static_cast<double>(Energy) < i);
              }
            }
          }

          //
          // Arguments    : void
          // Return Type  : void
          //
          void Checkerboard::undoLastExpansion()
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              292,                     // lineNo
              51,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              292,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              289,                     // lineNo
              57,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              289,                     // lineNo
              59,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              288,                     // lineNo
              51,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              288,                     // lineNo
              53,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              300,                     // lineNo
              56,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              300,                     // lineNo
              54,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              301,                     // lineNo
              62,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              301,                     // lineNo
              60,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              297,                     // lineNo
              60,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              297,                     // lineNo
              62,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              296,                     // lineNo
              54,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              296,                     // lineNo
              56,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              57,                      // colNo
              "",                      // aName
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 286,// lineNo
              20,                      // colNo
              "Checkerboard/undoLastExpansion",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/Checkerboard.m",// pName
              1                        // checkKind
            };

            Energy = PreviousEnergy;
            if (LastExpandDirection != static_cast<int>(std::floor
                 (LastExpandDirection))) {
              rtIntegerError(LastExpandDirection, g_emlrtDCI);
            }

            switch (static_cast<int>(LastExpandDirection)) {
             case 1:
              {
                int b_this;
                int c_this;
                int i;
                int i1;
                int i2;
                int loop_ub_tmp;
                i = BoardIdx.size(0);
                if (i < 2) {
                  i1 = -1;
                  i = -1;
                } else {
                  i1 = BoardIdx.size(0);
                  if (i1 < 2) {
                    rtDynamicBoundsError(2, 1, i1, fg_emlrtBCI);
                  }

                  i1 = 0;
                  i2 = BoardIdx.size(0);
                  if (i > i2) {
                    rtDynamicBoundsError(i, 1, i2, gg_emlrtBCI);
                  }

                  i--;
                }

                b_this = BoardIdx.size(1);
                for (i2 = 0; i2 < b_this; i2++) {
                  loop_ub_tmp = i - i1;
                  for (int i3{0}; i3 < loop_ub_tmp; i3++) {
                    BoardIdx[i3 + loop_ub_tmp * i2] = BoardIdx[((i1 + i3) +
                      BoardIdx.size(0) * i2) + 1];
                  }
                }

                BoardIdx.set_size(i - i1, b_this);
                i = BoardCoords.size(0);
                if (i < 2) {
                  i1 = -1;
                  i = -1;
                } else {
                  i1 = BoardCoords.size(0);
                  if (i1 < 2) {
                    rtDynamicBoundsError(2, 1, i1, dg_emlrtBCI);
                  }

                  i1 = 0;
                  i2 = BoardCoords.size(0);
                  if (i > i2) {
                    rtDynamicBoundsError(i, 1, i2, eg_emlrtBCI);
                  }

                  i--;
                }

                b_this = BoardCoords.size(1);
                c_this = BoardCoords.size(2);
                for (i2 = 0; i2 < c_this; i2++) {
                  for (int i3{0}; i3 < b_this; i3++) {
                    loop_ub_tmp = i - i1;
                    for (int i4{0}; i4 < loop_ub_tmp; i4++) {
                      BoardCoords[(i4 + loop_ub_tmp * i3) + loop_ub_tmp * b_this
                        * i2] = BoardCoords[(((i1 + i4) + BoardCoords.size(0) *
                        i3) + BoardCoords.size(0) * BoardCoords.size(1) * i2) +
                        1];
                    }
                  }
                }

                BoardCoords.set_size(i - i1, b_this, c_this);
              }
              break;

             case 2:
              {
                int b_this;
                int c_this;
                int i;
                int loop_ub_tmp;
                loop_ub_tmp = BoardIdx.size(0) - 1;
                if (loop_ub_tmp < 1) {
                  loop_ub_tmp = 0;
                } else {
                  i = BoardIdx.size(0);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, bg_emlrtBCI);
                  }

                  i = BoardIdx.size(0);
                  if (loop_ub_tmp > i) {
                    rtDynamicBoundsError(loop_ub_tmp, 1, i, cg_emlrtBCI);
                  }
                }

                b_this = BoardIdx.size(1);
                for (i = 0; i < b_this; i++) {
                  for (int i1{0}; i1 < loop_ub_tmp; i1++) {
                    BoardIdx[i1 + loop_ub_tmp * i] = BoardIdx[i1 + BoardIdx.size
                      (0) * i];
                  }
                }

                BoardIdx.set_size(loop_ub_tmp, b_this);
                loop_ub_tmp = BoardCoords.size(0) - 1;
                if (loop_ub_tmp < 1) {
                  loop_ub_tmp = 0;
                } else {
                  i = BoardCoords.size(0);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, yf_emlrtBCI);
                  }

                  i = BoardCoords.size(0);
                  if (loop_ub_tmp > i) {
                    rtDynamicBoundsError(loop_ub_tmp, 1, i, ag_emlrtBCI);
                  }
                }

                b_this = BoardCoords.size(1);
                c_this = BoardCoords.size(2);
                for (i = 0; i < c_this; i++) {
                  for (int i1{0}; i1 < b_this; i1++) {
                    for (int i2{0}; i2 < loop_ub_tmp; i2++) {
                      BoardCoords[(i2 + loop_ub_tmp * i1) + loop_ub_tmp * b_this
                        * i] = BoardCoords[(i2 + BoardCoords.size(0) * i1) +
                        BoardCoords.size(0) * BoardCoords.size(1) * i];
                    }
                  }
                }

                BoardCoords.set_size(loop_ub_tmp, b_this, c_this);
              }
              break;

             case 3:
              {
                int b_this;
                int c_this;
                int i;
                int i1;
                int i2;
                int loop_ub_tmp;
                i = BoardIdx.size(1);
                if (i < 2) {
                  i1 = 0;
                  i = 0;
                } else {
                  i1 = BoardIdx.size(1);
                  if (i1 < 2) {
                    rtDynamicBoundsError(2, 1, i1, wf_emlrtBCI);
                  }

                  i1 = 1;
                  i2 = BoardIdx.size(1);
                  if (i > i2) {
                    rtDynamicBoundsError(i, 1, i2, xf_emlrtBCI);
                  }
                }

                b_this = BoardIdx.size(0);
                loop_ub_tmp = i - i1;
                for (i = 0; i < loop_ub_tmp; i++) {
                  for (i2 = 0; i2 < b_this; i2++) {
                    BoardIdx[i2 + b_this * i] = BoardIdx[i2 + BoardIdx.size(0) *
                      (i1 + i)];
                  }
                }

                BoardIdx.set_size(b_this, loop_ub_tmp);
                i = BoardCoords.size(1);
                if (i < 2) {
                  i1 = -1;
                  i = -1;
                } else {
                  i1 = BoardCoords.size(1);
                  if (i1 < 2) {
                    rtDynamicBoundsError(2, 1, i1, uf_emlrtBCI);
                  }

                  i1 = 0;
                  i2 = BoardCoords.size(1);
                  if (i > i2) {
                    rtDynamicBoundsError(i, 1, i2, vf_emlrtBCI);
                  }

                  i--;
                }

                b_this = BoardCoords.size(0);
                c_this = BoardCoords.size(2);
                for (i2 = 0; i2 < c_this; i2++) {
                  loop_ub_tmp = i - i1;
                  for (int i3{0}; i3 < loop_ub_tmp; i3++) {
                    for (int i4{0}; i4 < b_this; i4++) {
                      BoardCoords[(i4 + b_this * i3) + b_this * loop_ub_tmp * i2]
                        = BoardCoords[(i4 + BoardCoords.size(0) * ((i1 + i3) + 1))
                        + BoardCoords.size(0) * BoardCoords.size(1) * i2];
                    }
                  }
                }

                BoardCoords.set_size(b_this, i - i1, c_this);
              }
              break;

             case 4:
              {
                int b_this;
                int c_this;
                int i;
                int loop_ub_tmp;
                loop_ub_tmp = BoardIdx.size(1) - 1;
                if (loop_ub_tmp < 1) {
                  loop_ub_tmp = 0;
                } else {
                  i = BoardIdx.size(1);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
                  }

                  i = BoardIdx.size(1);
                  if (loop_ub_tmp > i) {
                    rtDynamicBoundsError(loop_ub_tmp, 1, i, qf_emlrtBCI);
                  }
                }

                b_this = BoardIdx.size(0);
                for (i = 0; i < loop_ub_tmp; i++) {
                  for (int i1{0}; i1 < b_this; i1++) {
                    BoardIdx[i1 + b_this * i] = BoardIdx[i1 + BoardIdx.size(0) *
                      i];
                  }
                }

                BoardIdx.set_size(b_this, loop_ub_tmp);
                loop_ub_tmp = BoardCoords.size(1) - 1;
                if (loop_ub_tmp < 1) {
                  loop_ub_tmp = 0;
                } else {
                  i = BoardCoords.size(1);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, tf_emlrtBCI);
                  }

                  i = BoardCoords.size(1);
                  if (loop_ub_tmp > i) {
                    rtDynamicBoundsError(loop_ub_tmp, 1, i, sf_emlrtBCI);
                  }
                }

                b_this = BoardCoords.size(0);
                c_this = BoardCoords.size(2);
                for (i = 0; i < c_this; i++) {
                  for (int i1{0}; i1 < loop_ub_tmp; i1++) {
                    for (int i2{0}; i2 < b_this; i2++) {
                      BoardCoords[(i2 + b_this * i1) + b_this * loop_ub_tmp * i]
                        = BoardCoords[(i2 + BoardCoords.size(0) * i1) +
                        BoardCoords.size(0) * BoardCoords.size(1) * i];
                    }
                  }
                }

                BoardCoords.set_size(b_this, loop_ub_tmp, c_this);
              }
              break;
            }
          }

          //
          // Arguments    : const char *aFcnName
          //                int aLineNum
          // Return Type  : void
          //
        }
      }
    }
  }
}

static void ab_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Dimension argument must be a positive integer scalar within indexing range.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<bool, 2U> &in1
//                const coder::array<bool, 2U> &in2
// Return Type  : void
//
static void b_and(coder::array<bool, 2U> &in1, const coder::array<bool, 2U> &in2)
{
  coder::array<bool, 2U> b_in1;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in2.size(1) == 1) {
    loop_ub = in1.size(1);
  } else {
    loop_ub = in2.size(1);
  }

  b_in1.set_size(1, loop_ub);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_1 = (in2.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = (in1[i * stride_0_1] && in2[i * stride_1_1]);
  }

  in1.set_size(1, b_in1.size(1));
  loop_ub = b_in1.size(1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : coder::array<double, 3U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<double, 2U> &in3
//                int in4
// Return Type  : void
//
static void b_binary_expand_op(coder::array<double, 3U> &in1, const coder::
  vision::internal::calibration::checkerboard::Checkerboard *in2, const coder::
  array<double, 2U> &in3, int in4)
{
  coder::array<double, 3U> b_in2;
  int b_in3;
  int c_in3;
  int loop_ub;
  int stride_0_2;
  int stride_1_2;
  b_in3 = static_cast<int>(in3[in4]);
  c_in3 = static_cast<int>(in3[in4] + 2.0);
  if (in1.size(2) == 1) {
    loop_ub = in2->BoardCoords.size(2);
  } else {
    loop_ub = in1.size(2);
  }

  b_in2.set_size(1, 1, loop_ub);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_2 = (in1.size(2) != 1);
  for (int i{0}; i < loop_ub; i++) {
    int in2_tmp;
    in2_tmp = i * stride_0_2;
    b_in2[i] = (in2->BoardCoords[(b_in3 + in2->BoardCoords.size(0) *
      in2->BoardCoords.size(1) * in2_tmp) - 1] + in2->BoardCoords[(c_in3 +
      in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp) - 1]) -
      in1[i * stride_1_2];
  }

  in1.set_size(1, 1, b_in2.size(2));
  loop_ub = b_in2.size(2);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::vision::internal::calibration::checkerboard::Checkerboard *in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 1U> &in3
//                const coder::array<float, 2U> &in4
//                const coder::array<float, 2U> &in5
// Return Type  : void
//
static void b_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5)
{
  coder::array<float, 2U> b_in4;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in5.size(1) == 1) {
    loop_ub = in4.size(1);
  } else {
    loop_ub = in5.size(1);
  }

  b_in4.set_size(1, loop_ub);
  stride_0_1 = (in4.size(1) != 1);
  stride_1_1 = (in5.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in4[i] = in4[i * stride_0_1] + in5[i * stride_1_1];
  }

  in1->BoardIdx[in1->BoardIdx.size(0) * 2 + 2] = in1->findNeighbor(in2, in3,
    b_in4);
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void b_binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  float, 2U> &in2)
{
  coder::array<float, 2U> r;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  r.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      r[i1 + r.size(0) * i] = 6.0F * (in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] + in2[i1 * stride_1_0 + in2.size(0) * aux_1_1]);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(r.size(0), r.size(1));
  loop_ub = r.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = r.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = r[i1 + r.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void b_minus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                    &in2)
{
  coder::array<float, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in2.size(1) == 1) {
    loop_ub = in1.size(1);
  } else {
    loop_ub = in2.size(1);
  }

  b_in1.set_size(3, loop_ub);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < loop_ub; i++) {
    b_in1[3 * i] = in1[3 * aux_0_1] - in2[3 * aux_1_1];
    b_in1[3 * i + 1] = in1[3 * aux_0_1 + 1] - in2[3 * aux_1_1 + 1];
    b_in1[3 * i + 2] = in1[3 * aux_0_1 + 2] - in2[3 * aux_1_1 + 2];
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(3, b_in1.size(1));
  loop_ub = b_in1.size(1);
  for (int i{0}; i < loop_ub; i++) {
    in1[3 * i] = b_in1[3 * i];
    in1[3 * i + 1] = b_in1[3 * i + 1];
    in1[3 * i + 2] = b_in1[3 * i + 2];
  }
}

//
// Arguments    : coder::array<bool, 1U> &in1
//                const coder::array<bool, 1U> &in2
//                const coder::array<bool, 1U> &in3
// Return Type  : void
//
static void b_or(coder::array<bool, 1U> &in1, const coder::array<bool, 1U> &in2,
                 const coder::array<bool, 1U> &in3)
{
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  in1.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = (in2[i * stride_0_0] || in3[i * stride_1_0]);
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void b_plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                   &in2)
{
  coder::array<float, 2U> b_in2;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  if (in1.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in1.size(1);
  }

  b_in2.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0 = (in1.size(0) != 1);
  stride_1_1 = (in1.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in2[i1 + b_in2.size(0) * i] = in2[i1 * stride_0_0 + in2.size(0) *
        aux_0_1] + in1[i1 * stride_1_0 + in1.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(b_in2.size(0), b_in2.size(1));
  loop_ub = b_in2.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = b_in2.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in2[i1 + b_in2.size(0) * i];
    }
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void b_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Out of range subscript.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *r
//                const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void b_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Expected ") << r) << " to be non-NaN.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void bb_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((((outStream <<
      "Size vector must be a row vector with finite integer elements in the range: ")
     << MIN_int32_T) << " to ") << MAX_int32_T) << ".";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
//                const coder::array<double, 2U> &in3
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 2U> &in3)
{
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in3.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  in1.set_size(loop_ub, in1.size(1));
  if (in3.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in3.size(1);
  }

  in1.set_size(in1.size(0), b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0 = (in3.size(0) != 1);
  stride_1_1 = (in3.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      double d;
      d = in2[i1 * stride_0_0 + in2.size(0) * aux_0_1];
      in1[i1 + in1.size(0) * i] = (d + d) - in3[i1 * stride_1_0 + in3.size(0) *
        aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                double in3
// Return Type  : void
//
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, double in3)
{
  coder::array<float, 2U> b_in1;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in2->Points.size(1) == 1) {
    loop_ub = in1.size(1);
  } else {
    loop_ub = in2->Points.size(1);
  }

  b_in1.set_size(1, loop_ub);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_1 = (in2->Points.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_1] - in2->Points[(static_cast<int>(in3) +
      in2->Points.size(0) * (i * stride_1_1)) - 1];
  }

  in1.set_size(1, b_in1.size(1));
  loop_ub = b_in1.size(1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const coder::array<double, 2U> &in2
//                int in3
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 1U> &in1, const coder::array<
  double, 2U> &in2, int in3)
{
  coder::array<double, 1U> b_in2;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  b_in2.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in1.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = in2[i * stride_0_0 + in2.size(0) * in3] + in1[i * stride_1_0];
  }

  in1.set_size(b_in2.size(0));
  loop_ub = b_in2.size(0);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<double, 2U> &in3
//                const coder::array<float, 2U> &in4
// Return Type  : void
//
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  double, 2U> &in3, const coder::array<float, 2U> &in4)
{
  coder::array<float, 2U> b_in3;
  int aux_1_1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  int stride_1_1;
  if (in4.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in4.size(0);
  }

  b_in3.set_size(loop_ub, 2);
  stride_0_0 = (in3.size(0) != 1);
  stride_1_0 = (in4.size(0) != 1);
  stride_1_1 = (in4.size(1) != 1);
  aux_1_1 = 0;
  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in3[i1 + b_in3.size(0) * i] = static_cast<float>(in3[i1 * stride_0_0 +
        in3.size(0) * i]) - in4[i1 * stride_1_0 + in4.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
  }

  in1.set_size(b_in3.size(0), 2);
  loop_ub = b_in3.size(0);
  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      float varargin_1;
      varargin_1 = b_in3[i1 + b_in3.size(0) * i];
      in1[i1 + in1.size(0) * i] = varargin_1 * varargin_1;
    }
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<int, 1U> &in3
//                const coder::array<double, 3U> &in4
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<int,
  1U> &in3, const coder::array<double, 3U> &in4)
{
  coder::array<double, 3U> b_in2;
  int aux_0_2;
  int aux_1_2;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_2;
  int stride_1_0;
  int stride_1_2;
  if (in4.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in4.size(0);
  }

  if (in4.size(2) == 1) {
    b_loop_ub = in2->BoardCoords.size(2);
  } else {
    b_loop_ub = in4.size(2);
  }

  b_in2.set_size(loop_ub, 1, b_loop_ub);
  stride_0_0 = (in3.size(0) != 1);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_0 = (in4.size(0) != 1);
  stride_1_2 = (in4.size(2) != 1);
  aux_0_2 = 0;
  aux_1_2 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      int in2_tmp;
      in2_tmp = in3[i1 * stride_0_0];
      b_in2[i1 + b_in2.size(0) * i] = (in2->BoardCoords[in2_tmp +
        in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * aux_0_2] +
        in2->BoardCoords[(in2_tmp + in2->BoardCoords.size(0) * 2) +
        in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * aux_0_2]) - in4[i1
        * stride_1_0 + in4.size(0) * aux_1_2];
    }

    aux_1_2 += stride_1_2;
    aux_0_2 += stride_0_2;
  }

  coder::b_squeeze(b_in2, in1);
}

//
// Arguments    : coder::vision::internal::calibration::checkerboard::Checkerboard *in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 1U> &in3
//                const coder::array<float, 2U> &in4
//                const coder::array<float, 2U> &in5
// Return Type  : void
//
static void binary_expand_op(coder::vision::internal::calibration::checkerboard::
  Checkerboard *in1, const coder::array<float, 2U> &in2, const coder::array<
  float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::array<float,
  2U> &in5)
{
  coder::array<float, 2U> b_in4;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in5.size(1) == 1) {
    loop_ub = in4.size(1);
  } else {
    loop_ub = in5.size(1);
  }

  b_in4.set_size(1, loop_ub);
  stride_0_1 = (in4.size(1) != 1);
  stride_1_1 = (in5.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in4[i] = in4[i * stride_0_1] + in5[i * stride_1_1];
  }

  in1->BoardIdx[in1->BoardIdx.size(0) * 2] = in1->findNeighbor(in2, in3, b_in4);
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
//                const double in3_data[]
//                int in4
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const double in3_data[], int in4)
{
  coder::array<double, 2U> b_in2;
  double in3;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  in3 = in3_data[in4 + 1];
  if (in1.size(1) == 1) {
    loop_ub = in2.size(1);
  } else {
    loop_ub = in1.size(1);
  }

  b_in2.set_size(1, loop_ub);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_1 = (in1.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = in2[i * stride_0_1] * in1[i * stride_1_1] + in3;
  }

  in1.set_size(1, b_in2.size(1));
  loop_ub = b_in2.size(1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<int, 1U> &in3
//                const coder::array<double, 2U> &in4
//                const coder::array<double, 3U> &in5
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<int,
  1U> &in3, const coder::array<double, 2U> &in4, const coder::array<double, 3U>
  &in5)
{
  coder::array<double, 3U> b_in2;
  int aux_0_2;
  int aux_1_2;
  int b_in4;
  int b_loop_ub;
  int c_in4;
  int loop_ub;
  int stride_0_0;
  int stride_0_2;
  int stride_1_0;
  int stride_1_2;
  b_in4 = static_cast<int>(in4[0]);
  c_in4 = static_cast<int>(in4[2]);
  if (in5.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in5.size(0);
  }

  if (in5.size(2) == 1) {
    b_loop_ub = in2->BoardCoords.size(2);
  } else {
    b_loop_ub = in5.size(2);
  }

  b_in2.set_size(loop_ub, 1, b_loop_ub);
  stride_0_0 = (in3.size(0) != 1);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_0 = (in5.size(0) != 1);
  stride_1_2 = (in5.size(2) != 1);
  aux_0_2 = 0;
  aux_1_2 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      int in2_tmp;
      in2_tmp = in3[i1 * stride_0_0];
      b_in2[i1 + b_in2.size(0) * i] = (in2->BoardCoords[(in2_tmp +
        in2->BoardCoords.size(0) * (b_in4 - 1)) + in2->BoardCoords.size(0) *
        in2->BoardCoords.size(1) * aux_0_2] + in2->BoardCoords[(in2_tmp +
        in2->BoardCoords.size(0) * (c_in4 - 1)) + in2->BoardCoords.size(0) *
        in2->BoardCoords.size(1) * aux_0_2]) - in5[i1 * stride_1_0 + in5.size(0)
        * aux_1_2];
    }

    aux_1_2 += stride_1_2;
    aux_0_2 += stride_0_2;
  }

  coder::b_squeeze(b_in2, in1);
}

//
// Arguments    : coder::array<double, 3U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<double, 2U> &in3
//                int in4
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, int in4)
{
  coder::array<double, 3U> b_in2;
  int b_in3;
  int c_in3;
  int loop_ub;
  int stride_0_2;
  int stride_1_2;
  b_in3 = static_cast<int>(in3[in4]);
  c_in3 = static_cast<int>(in3[in4] + 2.0);
  if (in1.size(2) == 1) {
    loop_ub = in2->BoardCoords.size(2);
  } else {
    loop_ub = in1.size(2);
  }

  b_in2.set_size(1, 1, loop_ub);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_2 = (in1.size(2) != 1);
  for (int i{0}; i < loop_ub; i++) {
    int in2_tmp;
    in2_tmp = i * stride_0_2;
    b_in2[i] = (in2->BoardCoords[in2->BoardCoords.size(0) * (b_in3 - 1) +
                in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp] +
                in2->BoardCoords[in2->BoardCoords.size(0) * (c_in3 - 1) +
                in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp])
      - in1[i * stride_1_2];
  }

  in1.set_size(1, 1, b_in2.size(2));
  loop_ub = b_in2.size(2);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void binary_expand_op(coder::array<float, 2U> &in1, const coder::array<
  float, 2U> &in2)
{
  coder::array<float, 2U> r;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  r.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      r[i1 + r.size(0) * i] = 3.0F * (in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] + in2[i1 * stride_1_0 + in2.size(0) * aux_1_1]);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(r.size(0), r.size(1));
  loop_ub = r.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = r.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = r[i1 + r.size(0) * i];
    }
  }
}

//
// Arguments    : const coder::array<double, 1U> &in1
//                const coder::array<double, 1U> &in2
// Return Type  : double
//
static double binary_expand_op(const coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2)
{
  coder::array<double, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] / in2[i * stride_1_0];
  }

  return coder::internal::maximum(b_in1);
}

//
// Arguments    : coder::array<float, 1U> &in1
//                const coder::array<float, 1U> &in2
// Return Type  : void
//
static void binary_expand_op(coder::array<float, 1U> &in1, const coder::array<
  float, 1U> &in2)
{
  coder::array<float, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] * (1.0F - in2[i * stride_1_0]);
  }

  in1.set_size(b_in1.size(0));
  loop_ub = b_in1.size(0);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : coder::array<double, 3U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<double, 2U> &in3
//                const coder::array<double, 2U> &in4
//                int in5
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, const coder::array<double, 2U> &in4, int in5)
{
  coder::array<double, 3U> b_in2;
  int b_in4;
  int c_in4;
  int in3_tmp;
  int loop_ub;
  int stride_0_2;
  int stride_1_2;
  in3_tmp = static_cast<int>(in3[0]);
  b_in4 = static_cast<int>(in4[in5]);
  c_in4 = static_cast<int>(in4[in5] + 2.0);
  if (in1.size(2) == 1) {
    loop_ub = in2->BoardCoords.size(2);
  } else {
    loop_ub = in1.size(2);
  }

  b_in2.set_size(1, 1, loop_ub);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_2 = (in1.size(2) != 1);
  for (int i{0}; i < loop_ub; i++) {
    int in2_tmp;
    in2_tmp = i * stride_0_2;
    b_in2[i] = (in2->BoardCoords[((in3_tmp + in2->BoardCoords.size(0) * (b_in4 -
      1)) + in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp) - 1]
                + in2->BoardCoords[((in3_tmp + in2->BoardCoords.size(0) * (c_in4
      - 1)) + in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp) - 1])
      - in1[i * stride_1_2];
  }

  in1.set_size(1, 1, b_in2.size(2));
  loop_ub = b_in2.size(2);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<double, 2U> &in3
//                const coder::array<double, 2U> &in4
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, const coder::array<double, 2U> &in4)
{
  coder::array<double, 2U> b_in3;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in4.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in4.size(0);
  }

  if (in4.size(1) == 1) {
    b_loop_ub = in3.size(1);
  } else {
    b_loop_ub = in4.size(1);
  }

  b_in3.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in3.size(0) != 1);
  stride_0_1 = (in3.size(1) != 1);
  stride_1_0 = (in4.size(0) != 1);
  stride_1_1 = (in4.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      double in3_tmp;
      in3_tmp = in3[i1 * stride_0_0 + in3.size(0) * aux_0_1];
      b_in3[i1 + b_in3.size(0) * i] = (in3_tmp + in3_tmp) - in4[i1 * stride_1_0
        + in4.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in2->findClosestIndices(b_in3, in1);
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 3U> &in2
//                const coder::array<double, 3U> &in3
//                const coder::array<double, 3U> &in4
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 2U> &in1, const coder::array<
  double, 3U> &in2, const coder::array<double, 3U> &in3, const coder::array<
  double, 3U> &in4)
{
  coder::array<double, 3U> b_in2;
  int aux_0_2;
  int aux_1_2;
  int b_loop_ub;
  int loop_ub;
  int stride_0_1;
  int stride_0_2;
  int stride_1_1;
  int stride_1_2;
  if (in4.size(1) == 1) {
    loop_ub = in2.size(1);
  } else {
    loop_ub = in4.size(1);
  }

  if (in4.size(2) == 1) {
    b_loop_ub = in2.size(2);
  } else {
    b_loop_ub = in4.size(2);
  }

  b_in2.set_size(1, loop_ub, b_loop_ub);
  stride_0_1 = (in2.size(1) != 1);
  stride_0_2 = (in2.size(2) != 1);
  stride_1_1 = (in4.size(1) != 1);
  stride_1_2 = (in4.size(2) != 1);
  aux_0_2 = 0;
  aux_1_2 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      int in2_tmp;
      in2_tmp = i1 * stride_0_1;
      b_in2[i1 + b_in2.size(1) * i] = (in2[in2_tmp + in2.size(1) * aux_0_2] +
        in3[in2_tmp + in3.size(1) * aux_0_2]) - in4[i1 * stride_1_1 + in4.size(1)
        * aux_1_2];
    }

    aux_1_2 += stride_1_2;
    aux_0_2 += stride_0_2;
  }

  coder::squeeze(b_in2, in1);
}

//
// Arguments    : coder::array<double, 3U> &in1
//                const coder::vision::internal::calibration::checkerboard::Checkerboard *in2
//                const coder::array<double, 2U> &in3
//                int in4
//                const coder::array<double, 2U> &in5
// Return Type  : void
//
static void binary_expand_op(coder::array<double, 3U> &in1, const coder::vision::
  internal::calibration::checkerboard::Checkerboard *in2, const coder::array<
  double, 2U> &in3, int in4, const coder::array<double, 2U> &in5)
{
  coder::array<double, 3U> b_in2;
  int b_in3;
  int c_in3;
  int in5_tmp;
  int loop_ub;
  int stride_0_2;
  int stride_1_2;
  b_in3 = static_cast<int>(in3[in4]);
  in5_tmp = static_cast<int>(in5[0]);
  c_in3 = static_cast<int>(in3[in4] + 2.0);
  if (in1.size(2) == 1) {
    loop_ub = in2->BoardCoords.size(2);
  } else {
    loop_ub = in1.size(2);
  }

  b_in2.set_size(1, 1, loop_ub);
  stride_0_2 = (in2->BoardCoords.size(2) != 1);
  stride_1_2 = (in1.size(2) != 1);
  for (int i{0}; i < loop_ub; i++) {
    int in2_tmp;
    in2_tmp = i * stride_0_2;
    b_in2[i] = (in2->BoardCoords[((b_in3 + in2->BoardCoords.size(0) * (in5_tmp -
      1)) + in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp) - 1]
                + in2->BoardCoords[((c_in3 + in2->BoardCoords.size(0) * (in5_tmp
      - 1)) + in2->BoardCoords.size(0) * in2->BoardCoords.size(1) * in2_tmp) - 1])
      - in1[i * stride_1_2];
  }

  in1.set_size(1, 1, b_in2.size(2));
  loop_ub = b_in2.size(2);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<bool, 1U> &in1
//                const coder::array<bool, 1U> &in2
// Return Type  : void
//
static void c_and(coder::array<bool, 1U> &in1, const coder::array<bool, 1U> &in2)
{
  coder::array<bool, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = (in1[i * stride_0_0] && in2[i * stride_1_0]);
  }

  in1.set_size(b_in1.size(0));
  loop_ub = b_in1.size(0);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : coder::vision::internal::calibration::checkerboard::Checkerboard *in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 1U> &in3
//                const coder::array<float, 2U> &in4
//                const coder::array<float, 2U> &in5
// Return Type  : void
//
static void c_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5)
{
  coder::array<float, 2U> b_in4;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in5.size(1) == 1) {
    loop_ub = in4.size(1);
  } else {
    loop_ub = in5.size(1);
  }

  b_in4.set_size(1, loop_ub);
  stride_0_1 = (in4.size(1) != 1);
  stride_1_1 = (in5.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in4[i] = in4[i * stride_0_1] + in5[i * stride_1_1];
  }

  in1->BoardIdx[2] = in1->findNeighbor(in2, in3, b_in4);
}

//
// Arguments    : const char *r
//                const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void c_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Expected ") << r) << " to be integer-valued.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void c_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Assertion failed.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const ::coder::array<double, 2U> &x
// Return Type  : bool
//
namespace coder
{
  static bool all(const ::coder::array<double, 2U> &x)
  {
    int ix;
    bool exitg1;
    bool y;
    y = true;
    if (x.size(1) > 2147483646) {
      check_forloop_overflow_error();
    }

    ix = 1;
    exitg1 = false;
    while ((!exitg1) && (ix <= x.size(1))) {
      if (x[ix - 1] == 0.0) {
        y = false;
        exitg1 = true;
      } else {
        ix++;
      }
    }

    return y;
  }

  //
  // Arguments    : const ::coder::array<bool, 1U> &x
  // Return Type  : bool
  //
  static bool any(const ::coder::array<bool, 1U> &x)
  {
    int ix;
    bool exitg1;
    bool y;
    y = false;
    if (x.size(0) > 2147483646) {
      check_forloop_overflow_error();
    }

    ix = 1;
    exitg1 = false;
    while ((!exitg1) && (ix <= x.size(0))) {
      if (x[ix - 1]) {
        y = true;
        exitg1 = true;
      } else {
        ix++;
      }
    }

    return y;
  }

  //
  // Arguments    : const ::coder::array<bool, 2U> &x
  // Return Type  : bool
  //
  static bool b_any(const ::coder::array<bool, 2U> &x)
  {
    int ix;
    bool exitg1;
    bool y;
    y = false;
    if (x.size(1) > 2147483646) {
      check_forloop_overflow_error();
    }

    ix = 1;
    exitg1 = false;
    while ((!exitg1) && (ix <= x.size(1))) {
      if (x[ix - 1]) {
        y = true;
        exitg1 = true;
      } else {
        ix++;
      }
    }

    return y;
  }

  //
  // Arguments    : const double hCol[29]
  //                const double hRow[29]
  //                const ::coder::array<double, 2U> &inImg
  //                const double finalSize[2]
  //                ::coder::array<double, 2U> &outImg
  // Return Type  : void
  //
  static void b_conv2_separable_valid(const double hCol[29], const double hRow
    [29], const ::coder::array<double, 2U> &inImg, const double finalSize[2], ::
    coder::array<double, 2U> &outImg)
  {
    static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      1107,                            // lineNo
      28,                              // colNo
      "",                              // aName
      "conv2_separable_valid",         // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      1118,                            // lineNo
      58,                              // colNo
      "",                              // aName
      "conv2_separable_valid",         // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/imfilter.m",// pName
      0                                // checkKind
    };

    array<double, 2U> temp;
    array<double, 1U> r;
    int b_i;
    int i;
    int i1;
    int iy;
    int loop_ub;
    int tempRows;
    int ub_loop;
    int ub_loop_tmp;
    bool b;
    tempRows = inImg.size(0);
    ub_loop = static_cast<int>(finalSize[0]);
    i = static_cast<int>(finalSize[0]);
    outImg.set_size(ub_loop, static_cast<int>(finalSize[1]));
    temp.set_size(inImg.size(0), static_cast<int>(finalSize[1]));
    ub_loop_tmp = static_cast<int>(finalSize[1]) - 1;
    ub_loop = static_cast<int>(finalSize[1]) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(r,i1,loop_ub,b_i,b,iy)

    for (int ix = 0; ix <= ub_loop; ix++) {
      if ((ix + 1 < 1) || (ix + 1 > temp.size(1))) {
        rtDynamicBoundsError(ix + 1, 1, temp.size(1), l_emlrtBCI);
      }

      rtSubAssignSizeCheck(temp.size(), 1, &tempRows, 1, o_emlrtECI);
      for (i1 = 0; i1 < tempRows; i1++) {
        temp[i1 + temp.size(0) * ix] = 0.0;
      }

      loop_ub = inImg.size(0);
      for (b_i = 0; b_i < 29; b_i++) {
        b = ((ix + 1 < 1) || (ix + 1 > temp.size(1)));
        if (b) {
          rtDynamicBoundsError(ix + 1, 1, temp.size(1), qf_emlrtBCI);
        }

        iy = static_cast<int>((static_cast<unsigned int>(ix) + static_cast<
          unsigned int>(b_i)) + 1U);
        if ((iy < 1) || (iy > inImg.size(1))) {
          rtDynamicBoundsError(iy, 1, inImg.size(1), m_emlrtBCI);
        }

        r.set_size(inImg.size(0));
        for (i1 = 0; i1 < loop_ub; i1++) {
          r[i1] = inImg[i1 + inImg.size(0) * (iy - 1)] * hRow[b_i];
        }

        iy = temp.size(0);
        if ((temp.size(0) != r.size(0)) && ((temp.size(0) != 1) && (r.size(0) !=
              1))) {
          emlrtDimSizeImpxCheckR2021b(temp.size(0), r.size(0), p_emlrtECI);
        }

        if (temp.size(0) == r.size(0)) {
          r.set_size(temp.size(0));
          for (i1 = 0; i1 < iy; i1++) {
            r[i1] = temp[i1 + temp.size(0) * ix] + r[i1];
          }
        } else {
          binary_expand_op(r, temp, ix);
        }

        rtSubAssignSizeCheck(temp.size(), 1, r.size(), 1, q_emlrtECI);
        iy = r.size(0);
        for (i1 = 0; i1 < iy; i1++) {
          temp[i1 + temp.size(0) * ix] = r[i1];
        }
      }
    }

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(iy,b,b_i,i1)

    for (int ix = 0; ix <= ub_loop_tmp; ix++) {
      for (iy = 0; iy < i; iy++) {
        b = ((static_cast<int>(static_cast<unsigned int>(iy) + 1U) < 1) || (
              static_cast<int>(static_cast<unsigned int>(iy) + 1U) > outImg.size
              (0)));
        if (b) {
          rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(iy) +
            1U), 1, outImg.size(0), n_emlrtBCI);
        }

        b = ((static_cast<int>(static_cast<unsigned int>(ix) + 1U) < 1) || (
              static_cast<int>(static_cast<unsigned int>(ix) + 1U) > outImg.size
              (1)));
        if (b) {
          rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(ix) +
            1U), 1, outImg.size(1), o_emlrtBCI);
        }

        outImg[iy + outImg.size(0) * ix] = 0.0;
        for (b_i = 0; b_i < 29; b_i++) {
          i1 = static_cast<int>((static_cast<unsigned int>(iy) + static_cast<
            unsigned int>(b_i)) + 1U);
          if ((i1 < 1) || (i1 > temp.size(0))) {
            rtDynamicBoundsError(i1, 1, temp.size(0), p_emlrtBCI);
          }

          if ((static_cast<int>(static_cast<unsigned int>(ix) + 1U) < 1) || (
               static_cast<int>(static_cast<unsigned int>(ix) + 1U) > temp.size
               (1))) {
            rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(ix)
              + 1U), 1, temp.size(1), rf_emlrtBCI);
          }

          outImg[iy + outImg.size(0) * ix] = outImg[iy + outImg.size(0) * ix] +
            temp[(i1 + temp.size(0) * ix) - 1] * hCol[b_i];
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<bool, 1U> &x
  //                double kin
  //                ::coder::array<int, 1U> &i
  // Return Type  : void
  //
  static void b_eml_find(const ::coder::array<bool, 1U> &x, double kin, ::coder::
    array<int, 1U> &i)
  {
    static rtRunTimeErrorInfo s_emlrtRTEI{ 81,// lineNo
      1,                               // colNo
      "eml_find",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elmat/find.m"// pName
    };

    static rtRunTimeErrorInfo t_emlrtRTEI{ 66,// lineNo
      27,                              // colNo
      "eml_find",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elmat/find.m"// pName
    };

    int idx;
    int ii;
    int k;
    bool exitg1;
    if (!(std::floor(kin) == kin)) {
      p_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
    }

    if (kin <= x.size(0)) {
      k = static_cast<int>(kin);
    } else {
      k = x.size(0);
    }

    if (k > x.size(0)) {
      c_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
    }

    idx = 0;
    i.set_size(k);
    if (x.size(0) > 2147483646) {
      check_forloop_overflow_error();
    }

    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= x.size(0) - 1)) {
      if (x[ii]) {
        idx++;
        i[idx - 1] = ii + 1;
        if (idx >= k) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (idx > k) {
      c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
    }

    if (k == 1) {
      if (idx == 0) {
        i.set_size(0);
      }
    } else {
      int iv[2];
      if (idx < 1) {
        k = 0;
      } else {
        k = idx;
      }

      iv[0] = 1;
      iv[1] = k;
      internal::indexShapeCheck(i.size(0), iv);
      i.set_size(k);
    }
  }

  //
  // Arguments    : const ::coder::array<double, 1U> &x
  //                const ::coder::array<double, 1U> &y
  //                ::coder::array<double, 1U> &r
  // Return Type  : void
  //
  static void b_hypot(const ::coder::array<double, 1U> &x, const ::coder::array<
                      double, 1U> &y, ::coder::array<double, 1U> &r)
  {
    int u0;
    int u1;
    bool p;
    u0 = x.size(0);
    u1 = y.size(0);
    if (u0 <= u1) {
      u1 = u0;
    }

    p = true;
    if (u1 == x.size(0)) {
      if (u1 != y.size(0)) {
        p = false;
      }
    } else {
      p = false;
    }

    if (!p) {
      i_rtErrorWithMessageID(g_emlrtRTEI.fName, g_emlrtRTEI.lineNo);
    }

    r.set_size(u1);
    if (u1 > 2147483646) {
      check_forloop_overflow_error();
    }

    for (u0 = 0; u0 < u1; u0++) {
      r[u0] = rt_hypotd_snf(x[u0], y[u0]);
    }
  }

  //
  // Arguments    : const ::coder::array<float, 1U> &x
  //                const ::coder::array<float, 1U> &y
  //                ::coder::array<float, 1U> &r
  // Return Type  : void
  //
  static void b_hypot(const ::coder::array<float, 1U> &x, const ::coder::array<
                      float, 1U> &y, ::coder::array<float, 1U> &r)
  {
    int u0;
    int u1;
    bool p;
    u0 = x.size(0);
    u1 = y.size(0);
    if (u0 <= u1) {
      u1 = u0;
    }

    p = true;
    if (u1 == x.size(0)) {
      if (u1 != y.size(0)) {
        p = false;
      }
    } else {
      p = false;
    }

    if (!p) {
      i_rtErrorWithMessageID(g_emlrtRTEI.fName, g_emlrtRTEI.lineNo);
    }

    r.set_size(u1);
    if (u1 > 2147483646) {
      check_forloop_overflow_error();
    }

    for (u0 = 0; u0 < u1; u0++) {
      r[u0] = rt_hypotf_snf(x[u0], y[u0]);
    }
  }

  //
  // Arguments    : const double varargin_1_data[]
  //                const int varargin_1_size[2]
  //                double varargin_2
  // Return Type  : bool
  //
  static bool b_isequal(const double varargin_1_data[], const int
                        varargin_1_size[2], double varargin_2)
  {
    bool p;
    p = (varargin_1_size[1] == 1);
    if (p && (varargin_1_size[1] != 0) && (!(varargin_1_data[0] == varargin_2)))
    {
      p = false;
    }

    return p;
  }

  //
  // Arguments    : const ::coder::array<double, 1U> &x
  // Return Type  : double
  //
  static double b_norm(const ::coder::array<double, 1U> &x)
  {
    double y;
    if (x.size(0) == 0) {
      y = 0.0;
    } else {
      y = 0.0;
      if (x.size(0) == 1) {
        y = std::abs(x[0]);
      } else {
        double scale;
        int kend;
        scale = 3.3121686421112381E-170;
        kend = x.size(0);
        if (x.size(0) > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int k{0}; k < kend; k++) {
          double absxk;
          absxk = std::abs(x[k]);
          if (absxk > scale) {
            double t;
            t = scale / absxk;
            y = y * t * t + 1.0;
            scale = absxk;
          } else {
            double t;
            t = absxk / scale;
            y += t * t;
          }
        }

        y = scale * std::sqrt(y);
      }
    }

    return y;
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &A
  //                ::coder::array<double, 2U> &B
  // Return Type  : void
  //
  static void b_rot90(const ::coder::array<double, 2U> &A, ::coder::array<double,
                      2U> &B)
  {
    int b_i;
    int m;
    int n;
    m = A.size(0);
    n = A.size(1);
    B.set_size(A.size(0), A.size(1));
    if (A.size(0) * A.size(1) >= 8192) {
      int j;
      if (A.size(1) > 2147483646) {
        check_forloop_overflow_error();
      }

      j = A.size(1) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(b_i)

      for (int b_j = 0; b_j <= j; b_j++) {
        if (m > 2147483646) {
          check_forloop_overflow_error();
        }

        for (b_i = 0; b_i < m; b_i++) {
          B[b_i + B.size(0) * b_j] = A[((m - b_i) + A.size(0) * ((n - b_j) - 1))
            - 1];
        }
      }
    } else {
      if (A.size(1) > 2147483646) {
        check_forloop_overflow_error();
      }

      for (int j{0}; j < n; j++) {
        if (m > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int i{0}; i < m; i++) {
          B[i + B.size(0) * j] = A[((m - i) + A.size(0) * ((n - j) - 1)) - 1];
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<double, 3U> &a
  //                ::coder::array<double, 2U> &b
  // Return Type  : void
  //
  static void b_squeeze(const ::coder::array<double, 3U> &a, ::coder::array<
                        double, 2U> &b)
  {
    int szb[2];
    int j;
    int nx;
    szb[0] = a.size(0);
    szb[1] = 1;
    if (a.size(2) != 1) {
      j = 0;
      if (a.size(0) != 1) {
        j = 1;
        szb[0] = a.size(0);
      }

      if (a.size(2) != 1) {
        szb[j] = a.size(2);
      }
    }

    nx = a.size(0) * a.size(2);
    j = a.size(0);
    if (a.size(0) < 1) {
      j = 1;
    }

    if (a.size(2) > j) {
      j = a.size(2);
    }

    if (nx >= j) {
      j = nx;
    }

    if (szb[0] > j) {
      q_rtErrorWithMessageID(p_emlrtRTEI.fName, p_emlrtRTEI.lineNo);
    }

    if (szb[1] > j) {
      q_rtErrorWithMessageID(p_emlrtRTEI.fName, p_emlrtRTEI.lineNo);
    }

    j = szb[0] * szb[1];
    if (j != nx) {
      r_rtErrorWithMessageID(q_emlrtRTEI.fName, q_emlrtRTEI.lineNo);
    }

    b.set_size(szb[0], szb[1]);
    for (nx = 0; nx < j; nx++) {
      b[nx] = a[nx];
    }
  }

  //
  // Arguments    : int k
  //                const ::coder::array<double, 2U> &x
  //                const ::coder::array<double, 1U> &s
  // Return Type  : int
  //
  static int bsearchni(int k, const ::coder::array<double, 2U> &x, const ::coder::
                       array<double, 1U> &s)
  {
    double b_x;
    int idx;
    int ihi;
    int ilo;
    bool exitg1;
    b_x = x[k - 1];
    ihi = s.size(0);
    idx = 0;
    ilo = 1;
    exitg1 = false;
    while ((!exitg1) && (ihi >= ilo)) {
      int imid;
      imid = ((ilo >> 1) + (ihi >> 1)) - 1;
      if (((ilo & 1) == 1) && ((ihi & 1) == 1)) {
        imid++;
      }

      if (b_x == s[imid]) {
        idx = imid + 1;
        exitg1 = true;
      } else {
        bool p;
        if (std::isnan(s[imid])) {
          p = !std::isnan(b_x);
        } else if (std::isnan(b_x)) {
          p = false;
        } else {
          p = (b_x < s[imid]);
        }

        if (p) {
          ihi = imid;
        } else {
          ilo = imid + 2;
        }
      }
    }

    if (idx > 0) {
      idx--;
      while ((idx > 0) && (b_x == s[idx - 1])) {
        idx--;
      }

      idx++;
    }

    return idx;
  }

  //
  // Arguments    : int k
  //                const ::coder::array<double, 2U> &x
  //                const ::coder::array<double, 2U> &s
  // Return Type  : int
  //
  static int bsearchni(int k, const ::coder::array<double, 2U> &x, const ::coder::
                       array<double, 2U> &s)
  {
    double b_x;
    int idx;
    int ihi;
    int ilo;
    bool exitg1;
    b_x = x[k - 1];
    ihi = s.size(1);
    idx = 0;
    ilo = 1;
    exitg1 = false;
    while ((!exitg1) && (ihi >= ilo)) {
      int imid;
      imid = ((ilo >> 1) + (ihi >> 1)) - 1;
      if (((ilo & 1) == 1) && ((ihi & 1) == 1)) {
        imid++;
      }

      if (b_x == s[imid]) {
        idx = imid + 1;
        exitg1 = true;
      } else {
        bool p;
        if (std::isnan(s[imid])) {
          p = !std::isnan(b_x);
        } else if (std::isnan(b_x)) {
          p = false;
        } else {
          p = (b_x < s[imid]);
        }

        if (p) {
          ihi = imid;
        } else {
          ilo = imid + 2;
        }
      }
    }

    if (idx > 0) {
      idx--;
      while ((idx > 0) && (b_x == s[idx - 1])) {
        idx--;
      }

      idx++;
    }

    return idx;
  }

  //
  // Arguments    : const ::coder::array<float, 2U> &a
  //                const ::coder::array<double, 2U> &b
  //                ::coder::array<float, 2U> &c
  // Return Type  : void
  //
  static void bsxfun(const ::coder::array<float, 2U> &a, const ::coder::array<
                     double, 2U> &b, ::coder::array<float, 2U> &c)
  {
    int csz_idx_1;
    if (b.size(1) == 1) {
      csz_idx_1 = a.size(1);
    } else if (a.size(1) == 1) {
      csz_idx_1 = b.size(1);
    } else if (a.size(1) == b.size(1)) {
      csz_idx_1 = a.size(1);
    } else {
      n_rtErrorWithMessageID(m_emlrtRTEI.fName, m_emlrtRTEI.lineNo);
    }

    c.set_size(a.size(0), csz_idx_1);
    if ((a.size(0) != 0) && (csz_idx_1 != 0)) {
      int acoef;
      int b_acoef;
      int bcoef;
      acoef = (a.size(1) != 1);
      bcoef = (b.size(1) != 1);
      csz_idx_1--;
      b_acoef = (a.size(0) != 1);
      for (int k{0}; k <= csz_idx_1; k++) {
        int i;
        int varargin_2;
        int varargin_3;
        varargin_2 = acoef * k;
        varargin_3 = bcoef * k;
        i = c.size(0) - 1;
        for (int b_k{0}; b_k <= i; b_k++) {
          c[b_k + c.size(0) * k] = a[b_acoef * b_k + a.size(0) * varargin_2] -
            static_cast<float>(b[varargin_3]);
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<bool, 2U> &bwin
  //                ::coder::array<bool, 2U> &B
  // Return Type  : void
  //
  static void bwlookup(const ::coder::array<bool, 2U> &bwin, ::coder::array<bool,
                       2U> &B)
  {
    static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      222,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ah_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      252,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ai_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      291,                             // lineNo
      7,                               // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo aj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      344,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      223,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      253,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      291,                             // lineNo
      14,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      345,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      224,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ch_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      253,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ci_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      296,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo cj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      346,                             // lineNo
      23,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      225,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo dh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      254,                             // lineNo
      15,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo di_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      297,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo dj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      346,                             // lineNo
      15,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      226,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo eh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      254,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ei_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      298,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ej_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      351,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      226,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo fh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      262,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo fi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      299,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo fj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      353,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      234,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo gh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      261,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo gi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      299,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo gj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      353,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo hg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      232,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo hh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      263,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo hi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      300,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo hj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      362,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ig_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      236,                             // lineNo
      15,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ih_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      265,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ii_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      300,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ij_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      363,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo jg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      236,                             // lineNo
      7,                               // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo jh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      267,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ji_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      301,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo jj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      363,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo kg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      245,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo kh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      267,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ki_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      301,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo kj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      367,                             // lineNo
      27,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo lg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      245,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo lh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      272,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo li_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      302,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo lj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      368,                             // lineNo
      27,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo mg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      246,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo mh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      273,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo mi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      302,                             // lineNo
      18,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo mj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      369,                             // lineNo
      27,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ng_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      246,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo nh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      273,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ni_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      309,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo nj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      370,                             // lineNo
      15,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo og_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo oh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      274,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo oi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      310,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo oj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      370,                             // lineNo
      23,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo pg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ph_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      275,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo pi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      311,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo pj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      375,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      212,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      248,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      275,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      311,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      377,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      213,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      248,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      276,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ri_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      312,                             // lineNo
      7,                               // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rj_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      377,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      214,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo sg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      249,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo sh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      277,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo si_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      312,                             // lineNo
      14,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      214,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo tg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      249,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo th_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      277,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ti_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      328,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      215,                             // lineNo
      7,                               // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ug_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      250,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo uh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      278,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo ui_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      328,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      215,                             // lineNo
      15,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      250,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      278,                             // lineNo
      18,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      338,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      223,                             // lineNo
      26,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      251,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      288,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      339,                             // lineNo
      11,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      220,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      251,                             // lineNo
      30,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      287,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      339,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      221,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      252,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yh_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      289,                             // lineNo
      22,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yi_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      343,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwlookup",                      // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/bwlookup.m",// pName
      0                                // checkKind
    };

    static const bool lut[512]{ false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false, true,
      true, true, true, false, true, true, true, true, true, true, false, false,
      true, true, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, true, false, true, true,
      true, false, true, true, false, false, true, true, false, false, true,
      true, false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, false, false, false,
      false, false, false, true, true, true, true, false, false, true, true,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, true, false, false, true,
      true, false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, false, false, false,
      false, false, false, true, true, true, true, false, false, true, true,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, true, true, true,
      false, true, true, true, true, false, false, true, true, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, false, false, false,
      false, false, false, true, true, true, true, false, false, true, true,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, true, true, true,
      false, true, true, true, true, false, false, true, true, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, true, false, true, true,
      true, false, true, true, false, false, true, true, false, false, true,
      true, false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, true, true, false,
      false, true, true, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, false, true, false, false,
      false, false, false, false, false, true, true, true, true, false, false,
      true, true, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, true, false, true, true,
      true, false, true, true, true, true, false, false, true, true, false,
      false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, false, true, false, false, false,
      false, false, false, false, true, true, true, true, false, false, true,
      true, false, false, false, false, false, false, false, false, false, false,
      false, false, false, false, false, false, true, false, true, true, true,
      false, true, true, true, true, false, false, true, true, false, false };

    int lookUpInd;
    int rowInd;
    B.set_size(bwin.size(0), bwin.size(1));
    if ((bwin.size(0) != 0) && (bwin.size(1) != 0)) {
      unsigned int inDims_idx_0;
      unsigned int inDims_idx_1;
      inDims_idx_0 = static_cast<unsigned int>(bwin.size(0));
      inDims_idx_1 = static_cast<unsigned int>(bwin.size(1));
      if ((bwin.size(0) >= 2) && (bwin.size(1) >= 2)) {
        int colInd;
        int i;
        int i1;
        int lookUpInd_tmp;
        int rowMax;
        bool b;

        //  Process a 3x3 neighborhood centered around the pixel being processed.
        //  process the first column first row element
        if (bwin.size(0) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(0), qf_emlrtBCI);
        }

        if (bwin.size(1) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(1), rf_emlrtBCI);
        }

        if (bwin.size(0) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(0), sf_emlrtBCI);
        }

        if (bwin.size(1) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(1), tf_emlrtBCI);
        }

        if (bwin.size(0) < 1) {
          rtDynamicBoundsError(1, 1, bwin.size(0), uf_emlrtBCI);
        }

        if (bwin.size(1) < 1) {
          rtDynamicBoundsError(1, 1, bwin.size(1), vf_emlrtBCI);
        }

        B[0] = lut[(((bwin[0] << 4) + (bwin[1] << 5)) + (bwin[bwin.size(0)] << 7))
          + (bwin[bwin.size(0) + 1] << 8)];

        //  process the first column interior elements
        i = bwin.size(0);
        for (rowMax = 0; rowMax <= i - 3; rowMax++) {
          if (bwin.size(1) < 2) {
            rtDynamicBoundsError(2, 1, bwin.size(1), wf_emlrtBCI);
          }

          if (rowMax + 1 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 1, 1, bwin.size(0), xf_emlrtBCI);
          }

          if (rowMax + 2 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, bwin.size(0), yf_emlrtBCI);
          }

          if (rowMax + 3 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 3, 1, bwin.size(0), ag_emlrtBCI);
          }

          if (rowMax + 1 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 1, 1, bwin.size(0), bg_emlrtBCI);
          }

          if (rowMax + 2 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, bwin.size(0), cg_emlrtBCI);
          }

          if (rowMax + 3 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 3, 1, bwin.size(0), dg_emlrtBCI);
          }

          if (B.size(1) < 1) {
            rtDynamicBoundsError(1, 1, B.size(1), eg_emlrtBCI);
          }

          if (rowMax + 2 > B.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, B.size(0), fg_emlrtBCI);
          }

          B[rowMax + 1] = lut[(((((bwin[rowMax] << 3) + (bwin[rowMax + 1] << 4))
            + (bwin[rowMax + 2] << 5)) + (bwin[rowMax + bwin.size(0)] << 6)) +
                               (bwin[(rowMax + bwin.size(0)) + 1] << 7)) +
            (bwin[(rowMax + bwin.size(0)) + 2] << 8)];
        }

        //  process the first column last row element
        if (bwin.size(1) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(1), gg_emlrtBCI);
        }

        i1 = bwin.size(0) - 1;
        b = ((bwin.size(0) - 1 < 1) || (bwin.size(0) - 1 > bwin.size(0)));
        if (b) {
          rtDynamicBoundsError(bwin.size(0) - 1, 1, bwin.size(0), hg_emlrtBCI);
        }

        lookUpInd_tmp = bwin.size(0) - 2;
        lookUpInd = ((((bwin[bwin.size(0) - 2] << 3) + (bwin[bwin.size(0) - 1] <<
          4)) + (bwin[(bwin.size(0) + bwin.size(0)) - 2] << 6)) + (bwin
          [(bwin.size(0) + bwin.size(0)) - 1] << 7)) + 1;
        if (B.size(1) < 1) {
          rtDynamicBoundsError(1, 1, B.size(1), ig_emlrtBCI);
        }

        if (bwin.size(0) > B.size(0)) {
          rtDynamicBoundsError(bwin.size(0), 1, B.size(0), jg_emlrtBCI);
        }

        B[bwin.size(0) - 1] = lut[lookUpInd - 1];

        //  process second column to last but one column-------------------------
        rowMax = bwin.size(0) - 1;
        colInd = bwin.size(1) - 3;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(lookUpInd,rowInd)

        for (int b_colInd = 0; b_colInd <= colInd; b_colInd++) {
          //  process second to last but one row for this column
          for (rowInd = 0; rowInd <= rowMax - 2; rowInd++) {
            if (rowInd + 1 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 1, 1, bwin.size(0), kg_emlrtBCI);
            }

            if (b_colInd + 1 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 1, 1, bwin.size(1), lg_emlrtBCI);
            }

            if (rowInd + 2 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 2, 1, bwin.size(0), mg_emlrtBCI);
            }

            if (b_colInd + 1 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 1, 1, bwin.size(1), ng_emlrtBCI);
            }

            if (rowInd + 3 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 3, 1, bwin.size(0), og_emlrtBCI);
            }

            if (b_colInd + 1 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 1, 1, bwin.size(1), pg_emlrtBCI);
            }

            if (rowInd + 1 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 1, 1, bwin.size(0), qg_emlrtBCI);
            }

            if (b_colInd + 2 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 2, 1, bwin.size(1), rg_emlrtBCI);
            }

            if (rowInd + 2 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 2, 1, bwin.size(0), sg_emlrtBCI);
            }

            if (b_colInd + 2 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 2, 1, bwin.size(1), tg_emlrtBCI);
            }

            if (rowInd + 3 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 3, 1, bwin.size(0), ug_emlrtBCI);
            }

            if (b_colInd + 2 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 2, 1, bwin.size(1), vg_emlrtBCI);
            }

            if (rowInd + 1 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 1, 1, bwin.size(0), wg_emlrtBCI);
            }

            if (b_colInd + 3 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 3, 1, bwin.size(1), xg_emlrtBCI);
            }

            if (rowInd + 2 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 2, 1, bwin.size(0), yg_emlrtBCI);
            }

            if (b_colInd + 3 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 3, 1, bwin.size(1), ah_emlrtBCI);
            }

            if (rowInd + 3 > bwin.size(0)) {
              rtDynamicBoundsError(rowInd + 3, 1, bwin.size(0), bh_emlrtBCI);
            }

            if (b_colInd + 3 > bwin.size(1)) {
              rtDynamicBoundsError(b_colInd + 3, 1, bwin.size(1), ch_emlrtBCI);
            }

            lookUpInd = ((((((((bwin[rowInd + bwin.size(0) * b_colInd] + (bwin
              [(rowInd + bwin.size(0) * b_colInd) + 1] << 1)) + (bwin[(rowInd +
              bwin.size(0) * b_colInd) + 2] << 2)) + (bwin[rowInd + bwin.size(0)
              * (b_colInd + 1)] << 3)) + (bwin[(rowInd + bwin.size(0) *
              (b_colInd + 1)) + 1] << 4)) + (bwin[(rowInd + bwin.size(0) *
              (b_colInd + 1)) + 2] << 5)) + (bwin[rowInd + bwin.size(0) *
              (b_colInd + 2)] << 6)) + (bwin[(rowInd + bwin.size(0) * (b_colInd
              + 2)) + 1] << 7)) + (bwin[(rowInd + bwin.size(0) * (b_colInd + 2))
              + 2] << 8)) + 1;
            if (rowInd + 2 > B.size(0)) {
              rtDynamicBoundsError(rowInd + 2, 1, B.size(0), dh_emlrtBCI);
            }

            if (b_colInd + 2 > B.size(1)) {
              rtDynamicBoundsError(b_colInd + 2, 1, B.size(1), eh_emlrtBCI);
            }

            B[(rowInd + B.size(0) * (b_colInd + 1)) + 1] = lut[lookUpInd - 1];
          }
        }

        rowMax = static_cast<int>(inDims_idx_1);
        for (colInd = 0; colInd <= rowMax - 3; colInd++) {
          //  process first row element
          if (bwin.size(0) < 2) {
            rtDynamicBoundsError(2, 1, bwin.size(0), fh_emlrtBCI);
          }

          if (colInd + 1 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 1, 1, bwin.size(1), gh_emlrtBCI);
          }

          if (colInd + 2 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 2, 1, bwin.size(1), hh_emlrtBCI);
          }

          if (colInd + 3 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 3, 1, bwin.size(1), ih_emlrtBCI);
          }

          if (B.size(0) < 1) {
            rtDynamicBoundsError(1, 1, B.size(0), jh_emlrtBCI);
          }

          if (colInd + 2 > B.size(1)) {
            rtDynamicBoundsError(colInd + 2, 1, B.size(1), kh_emlrtBCI);
          }

          B[B.size(0) * (colInd + 1)] = lut[(((((bwin[bwin.size(0) * colInd] <<
            1) + (bwin[bwin.size(0) * colInd + 1] << 2)) + (bwin[bwin.size(0) *
            (colInd + 1)] << 4)) + (bwin[bwin.size(0) * (colInd + 1) + 1] << 5))
            + (bwin[bwin.size(0) * (colInd + 2)] << 7)) + (bwin[bwin.size(0) *
            (colInd + 2) + 1] << 8)];

          //  process the last row element
          if (colInd + 1 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 1, 1, bwin.size(1), lh_emlrtBCI);
          }

          if (i > bwin.size(0)) {
            rtDynamicBoundsError(i, 1, bwin.size(0), mh_emlrtBCI);
          }

          if (colInd + 1 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 1, 1, bwin.size(1), nh_emlrtBCI);
          }

          if (colInd + 2 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 2, 1, bwin.size(1), oh_emlrtBCI);
          }

          if (i > bwin.size(0)) {
            rtDynamicBoundsError(i, 1, bwin.size(0), ph_emlrtBCI);
          }

          if (colInd + 2 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 2, 1, bwin.size(1), qh_emlrtBCI);
          }

          if (colInd + 3 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 3, 1, bwin.size(1), rh_emlrtBCI);
          }

          if (i > bwin.size(0)) {
            rtDynamicBoundsError(i, 1, bwin.size(0), sh_emlrtBCI);
          }

          if (colInd + 3 > bwin.size(1)) {
            rtDynamicBoundsError(colInd + 3, 1, bwin.size(1), th_emlrtBCI);
          }

          if (static_cast<int>(inDims_idx_0) > B.size(0)) {
            rtDynamicBoundsError(static_cast<int>(inDims_idx_0), 1, B.size(0),
                                 uh_emlrtBCI);
          }

          if (colInd + 2 > B.size(1)) {
            rtDynamicBoundsError(colInd + 2, 1, B.size(1), vh_emlrtBCI);
          }

          B[i1 + B.size(0) * (colInd + 1)] = lut[((((bwin[lookUpInd_tmp +
            bwin.size(0) * colInd] + (bwin[i1 + bwin.size(0) * colInd] << 1)) +
            (bwin[lookUpInd_tmp + bwin.size(0) * (colInd + 1)] << 3)) + (bwin[i1
            + bwin.size(0) * (colInd + 1)] << 4)) + (bwin[lookUpInd_tmp +
            bwin.size(0) * (colInd + 2)] << 6)) + (bwin[i1 + bwin.size(0) *
            (colInd + 2)] << 7)];
        }

        //  end process second column to last but one column---------------------
        //  process last column first row element
        if (bwin.size(0) < 2) {
          rtDynamicBoundsError(2, 1, bwin.size(0), wh_emlrtBCI);
        }

        b = ((static_cast<int>(inDims_idx_1) - 1 < 1) || (static_cast<int>
              (inDims_idx_1) - 1 > bwin.size(1)));
        if (b) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1) - 1, 1, bwin.size
                               (1), xh_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                               yh_emlrtBCI);
        }

        if (B.size(0) < 1) {
          rtDynamicBoundsError(1, 1, B.size(0), ai_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_1) > B.size(1)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, B.size(1),
                               bi_emlrtBCI);
        }

        B[B.size(0) * (static_cast<int>(inDims_idx_1) - 1)] = lut
          [(((bwin[bwin.size(0) * (static_cast<int>(inDims_idx_1) - 2)] << 1) +
             (bwin[bwin.size(0) * (static_cast<int>(inDims_idx_1) - 2) + 1] << 2))
            + (bwin[bwin.size(0) * (static_cast<int>(inDims_idx_1) - 1)] << 4))
          + (bwin[bwin.size(0) * (static_cast<int>(inDims_idx_1) - 1) + 1] << 5)];

        //  process last column second to last but one element
        for (rowMax = 0; rowMax <= i - 3; rowMax++) {
          if (rowMax + 1 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 1, 1, bwin.size(0), ci_emlrtBCI);
          }

          if (rowMax + 2 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, bwin.size(0), di_emlrtBCI);
          }

          if (rowMax + 3 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 3, 1, bwin.size(0), ei_emlrtBCI);
          }

          if (rowMax + 1 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 1, 1, bwin.size(0), fi_emlrtBCI);
          }

          if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
            rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                                 gi_emlrtBCI);
          }

          if (rowMax + 2 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, bwin.size(0), hi_emlrtBCI);
          }

          if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
            rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                                 ii_emlrtBCI);
          }

          if (rowMax + 3 > bwin.size(0)) {
            rtDynamicBoundsError(rowMax + 3, 1, bwin.size(0), ji_emlrtBCI);
          }

          if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
            rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                                 ki_emlrtBCI);
          }

          if (rowMax + 2 > B.size(0)) {
            rtDynamicBoundsError(rowMax + 2, 1, B.size(0), li_emlrtBCI);
          }

          if (static_cast<int>(inDims_idx_1) > B.size(1)) {
            rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, B.size(1),
                                 mi_emlrtBCI);
          }

          B[(rowMax + B.size(0) * (static_cast<int>(inDims_idx_1) - 1)) + 1] =
            lut[((((bwin[rowMax + bwin.size(0) * (static_cast<int>(inDims_idx_1)
                     - 2)] + (bwin[(rowMax + bwin.size(0) * (static_cast<int>
            (inDims_idx_1) - 2)) + 1] << 1)) + (bwin[(rowMax + bwin.size(0) * (
                      static_cast<int>(inDims_idx_1) - 2)) + 2] << 2)) +
                  (bwin[rowMax + bwin.size(0) * (static_cast<int>(inDims_idx_1)
                    - 1)] << 3)) + (bwin[(rowMax + bwin.size(0) * (static_cast<
                    int>(inDims_idx_1) - 1)) + 1] << 4)) + (bwin[(rowMax +
            bwin.size(0) * (static_cast<int>(inDims_idx_1) - 1)) + 2] << 5)];
        }

        //  process the last column last row element
        if (i > bwin.size(0)) {
          rtDynamicBoundsError(i, 1, bwin.size(0), ni_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                               oi_emlrtBCI);
        }

        if (i > bwin.size(0)) {
          rtDynamicBoundsError(i, 1, bwin.size(0), pi_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_1) > bwin.size(1)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, bwin.size(1),
                               qi_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_0) > B.size(0)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_0), 1, B.size(0),
                               ri_emlrtBCI);
        }

        if (static_cast<int>(inDims_idx_1) > B.size(1)) {
          rtDynamicBoundsError(static_cast<int>(inDims_idx_1), 1, B.size(1),
                               si_emlrtBCI);
        }

        B[i1 + B.size(0) * (static_cast<int>(inDims_idx_1) - 1)] = lut
          [((bwin[lookUpInd_tmp + bwin.size(0) * (static_cast<int>(inDims_idx_1)
              - 2)] + (bwin[i1 + bwin.size(0) * (static_cast<int>(inDims_idx_1)
               - 2)] << 1)) + (bwin[lookUpInd_tmp + bwin.size(0) * (static_cast<
              int>(inDims_idx_1) - 1)] << 3)) + (bwin[i1 + bwin.size(0) * (
          static_cast<int>(inDims_idx_1) - 1)] << 4)];
      } else {
        int i;

        //  input is either 1x1, 1xN or Nx1
        if (bwin.size(0) == bwin.size(1)) {
          //  input size is 1x1
          if (bwin.size(0) < 1) {
            rtDynamicBoundsError(1, 1, bwin.size(0), ti_emlrtBCI);
          }

          if (bwin.size(1) < 1) {
            rtDynamicBoundsError(1, 1, bwin.size(1), ui_emlrtBCI);
          }

          B[0] = lut[bwin[0] << 4];
        }

        if (bwin.size(0) > 1) {
          //  input size is Nx1
          if (bwin.size(0) < 2) {
            rtDynamicBoundsError(2, 1, bwin.size(0), vi_emlrtBCI);
          }

          if (B.size(0) < 1) {
            rtDynamicBoundsError(1, 1, B.size(0), wi_emlrtBCI);
          }

          if (B.size(1) < 1) {
            rtDynamicBoundsError(1, 1, B.size(1), xi_emlrtBCI);
          }

          B[0] = lut[(bwin[0] << 4) + (bwin[1] << 5)];
          i = bwin.size(0);
          for (int rowMax{0}; rowMax <= i - 3; rowMax++) {
            if (rowMax + 1 > bwin.size(0)) {
              rtDynamicBoundsError(rowMax + 1, 1, bwin.size(0), yi_emlrtBCI);
            }

            if (rowMax + 2 > bwin.size(0)) {
              rtDynamicBoundsError(rowMax + 2, 1, bwin.size(0), aj_emlrtBCI);
            }

            if (rowMax + 3 > bwin.size(0)) {
              rtDynamicBoundsError(rowMax + 3, 1, bwin.size(0), bj_emlrtBCI);
            }

            if (B.size(1) < 1) {
              rtDynamicBoundsError(1, 1, B.size(1), cj_emlrtBCI);
            }

            if (rowMax + 2 > B.size(0)) {
              rtDynamicBoundsError(rowMax + 2, 1, B.size(0), dj_emlrtBCI);
            }

            B[rowMax + 1] = lut[((bwin[rowMax] << 3) + (bwin[rowMax + 1] << 4))
              + (bwin[rowMax + 2] << 5)];
          }

          if ((bwin.size(0) - 1 < 1) || (bwin.size(0) - 1 > bwin.size(0))) {
            rtDynamicBoundsError(bwin.size(0) - 1, 1, bwin.size(0), ej_emlrtBCI);
          }

          if (B.size(1) < 1) {
            rtDynamicBoundsError(1, 1, B.size(1), fj_emlrtBCI);
          }

          if (bwin.size(0) > B.size(0)) {
            rtDynamicBoundsError(bwin.size(0), 1, B.size(0), gj_emlrtBCI);
          }

          B[bwin.size(0) - 1] = lut[(bwin[bwin.size(0) - 2] << 3) +
            (bwin[bwin.size(0) - 1] << 4)];
        }

        if (bwin.size(1) > 1) {
          //  input size is 1xN
          if (bwin.size(1) < 2) {
            rtDynamicBoundsError(2, 1, bwin.size(1), hj_emlrtBCI);
          }

          if (B.size(0) < 1) {
            rtDynamicBoundsError(1, 1, B.size(0), ij_emlrtBCI);
          }

          if (B.size(1) < 1) {
            rtDynamicBoundsError(1, 1, B.size(1), jj_emlrtBCI);
          }

          B[0] = lut[(bwin[0] << 4) + (bwin[bwin.size(0)] << 7)];
          i = bwin.size(1);
          for (int colInd{0}; colInd <= i - 3; colInd++) {
            if (colInd + 1 > bwin.size(1)) {
              rtDynamicBoundsError(colInd + 1, 1, bwin.size(1), kj_emlrtBCI);
            }

            if (colInd + 2 > bwin.size(1)) {
              rtDynamicBoundsError(colInd + 2, 1, bwin.size(1), lj_emlrtBCI);
            }

            if (colInd + 3 > bwin.size(1)) {
              rtDynamicBoundsError(colInd + 3, 1, bwin.size(1), mj_emlrtBCI);
            }

            if (B.size(0) < 1) {
              rtDynamicBoundsError(1, 1, B.size(0), nj_emlrtBCI);
            }

            if (colInd + 2 > B.size(1)) {
              rtDynamicBoundsError(colInd + 2, 1, B.size(1), oj_emlrtBCI);
            }

            B[B.size(0) * (colInd + 1)] = lut[((bwin[bwin.size(0) * colInd] << 1)
              + (bwin[bwin.size(0) * (colInd + 1)] << 4)) + (bwin[bwin.size(0) *
              (colInd + 2)] << 7)];
          }

          if ((bwin.size(1) - 1 < 1) || (bwin.size(1) - 1 > bwin.size(1))) {
            rtDynamicBoundsError(bwin.size(1) - 1, 1, bwin.size(1), pj_emlrtBCI);
          }

          if (B.size(0) < 1) {
            rtDynamicBoundsError(1, 1, B.size(0), qj_emlrtBCI);
          }

          if (bwin.size(1) > B.size(1)) {
            rtDynamicBoundsError(bwin.size(1), 1, B.size(1), rj_emlrtBCI);
          }

          B[B.size(0) * (bwin.size(1) - 1)] = lut[(bwin[bwin.size(0) *
            (bwin.size(1) - 2)] << 1) + (bwin[bwin.size(0) * (bwin.size(1) - 1)]
            << 4)];
        }
      }
    }
  }

  //
  // Arguments    : ::coder::array<bool, 2U> &bwin
  // Return Type  : void
  //
  static void bwmorph(::coder::array<bool, 2U> &bwin)
  {
    static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      242,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      242,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      242,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      247,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      232,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      232,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      232,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      232,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      237,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      237,                             // lineNo
      12,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      237,                             // lineNo
      24,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      237,                             // lineNo
      20,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      242,                             // lineNo
      16,                              // colNo
      "",                              // aName
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m",// pName
      0                                // checkKind
    };

    static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
      247,                             // lineNo
      9,                               // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo mb_emlrtECI{ 2,// nDims
      246,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo nb_emlrtECI{ 1,// nDims
      246,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo ob_emlrtECI{ -1,// nDims
      242,                             // lineNo
      9,                               // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo pb_emlrtECI{ 2,// nDims
      241,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo qb_emlrtECI{ 1,// nDims
      241,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo rb_emlrtECI{ -1,// nDims
      237,                             // lineNo
      9,                               // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo sb_emlrtECI{ 2,// nDims
      236,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo tb_emlrtECI{ 1,// nDims
      236,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo ub_emlrtECI{ -1,// nDims
      232,                             // lineNo
      9,                               // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo vb_emlrtECI{ 2,// nDims
      231,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    static rtEqualityCheckInfo wb_emlrtECI{ 1,// nDims
      231,                             // lineNo
      15,                              // colNo
      "bwmorphApplyOnce",              // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/+images/+internal/algbwmorph.m"// pName
    };

    array<bool, 2U> last_aout;
    array<bool, 2U> m;
    int iv[2];
    int iv1[2];
    if ((bwin.size(0) != 0) && (bwin.size(1) != 0)) {
      int loop_ub_tmp;
      do {
        int b_loop_ub_tmp;
        int i;
        int i1;
        int i10;
        int i2;
        int i3;
        int i4;
        int i5;
        int i6;
        int i7;
        int i8;
        int i9;
        last_aout.set_size(bwin.size(0), bwin.size(1));
        loop_ub_tmp = bwin.size(0) * bwin.size(1);
        for (i = 0; i < loop_ub_tmp; i++) {
          last_aout[i] = bwin[i];
        }

        bwlookup(bwin, m);
        b_loop_ub_tmp = m.size(0) * m.size(1);
        for (i = 0; i < b_loop_ub_tmp; i++) {
          m[i] = !m[i];
        }

        i = bwin.size(0);
        if ((i != m.size(0)) && ((i != 1) && (m.size(0) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(0), wb_emlrtECI);
        }

        i = bwin.size(1);
        if ((i != m.size(1)) && ((i != 1) && (m.size(1) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(1), vb_emlrtECI);
        }

        if ((bwin.size(0) == m.size(0)) && (bwin.size(1) == m.size(1))) {
          m.set_size(bwin.size(0), bwin.size(1));
          for (i = 0; i < loop_ub_tmp; i++) {
            m[i] = (bwin[i] && m[i]);
          }
        } else {
          d_and(m, bwin);
        }

        if (m.size(0) < 1) {
          i = 1;
          i1 = -1;
        } else {
          i = 2;
          i1 = m.size(0) - 1;
        }

        if (m.size(1) < 1) {
          i2 = 1;
          i3 = -1;
        } else {
          i2 = 2;
          i3 = m.size(1) - 1;
        }

        if (bwin.size(0) < 1) {
          i4 = 1;
          i5 = 0;
        } else {
          i4 = bwin.size(0);
          if (i4 < 1) {
            rtDynamicBoundsError(1, 1, i4, rf_emlrtBCI);
          }

          i4 = 2;
          i6 = bwin.size(0);
          i5 = bwin.size(0);
          if ((i5 < 1) || (i5 > i6)) {
            rtDynamicBoundsError(i5, 1, i6, qf_emlrtBCI);
          }
        }

        if (bwin.size(1) < 1) {
          i6 = 1;
          i7 = 0;
        } else {
          i6 = bwin.size(1);
          if (i6 < 1) {
            rtDynamicBoundsError(1, 1, i6, tf_emlrtBCI);
          }

          i6 = 2;
          i8 = bwin.size(1);
          i7 = bwin.size(1);
          if ((i7 < 1) || (i7 > i8)) {
            rtDynamicBoundsError(i7, 1, i8, sf_emlrtBCI);
          }
        }

        iv[0] = div_s32(i5 - 1, i4) + 1;
        iv[1] = div_s32(i7 - 1, i6) + 1;
        loop_ub_tmp = div_s32(i1, i);
        iv1[0] = loop_ub_tmp + 1;
        b_loop_ub_tmp = div_s32(i3, i2);
        iv1[1] = b_loop_ub_tmp + 1;
        rtSubAssignSizeCheck(&iv[0], 2, &iv1[0], 2, ub_emlrtECI);
        for (i1 = 0; i1 <= b_loop_ub_tmp; i1++) {
          for (i3 = 0; i3 <= loop_ub_tmp; i3++) {
            bwin[i4 * i3 + bwin.size(0) * (i6 * i1)] = m[i * i3 + m.size(0) *
              (i2 * i1)];
          }
        }

        bwlookup(bwin, m);
        loop_ub_tmp = m.size(0) * m.size(1);
        for (i = 0; i < loop_ub_tmp; i++) {
          m[i] = !m[i];
        }

        i = bwin.size(0);
        if ((i != m.size(0)) && ((i != 1) && (m.size(0) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(0), tb_emlrtECI);
        }

        i = bwin.size(1);
        if ((i != m.size(1)) && ((i != 1) && (m.size(1) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(1), sb_emlrtECI);
        }

        if ((bwin.size(0) == m.size(0)) && (bwin.size(1) == m.size(1))) {
          loop_ub_tmp = bwin.size(0) * bwin.size(1);
          m.set_size(bwin.size(0), bwin.size(1));
          for (i = 0; i < loop_ub_tmp; i++) {
            m[i] = (bwin[i] && m[i]);
          }
        } else {
          d_and(m, bwin);
        }

        if (m.size(0) < 2) {
          i = 1;
          i1 = 1;
          i2 = 0;
        } else {
          i = 2;
          i1 = 2;
          i2 = m.size(0);
        }

        if (m.size(1) < 2) {
          i3 = 1;
          i4 = 1;
          i6 = 0;
        } else {
          i3 = 2;
          i4 = 2;
          i6 = m.size(1);
        }

        if (bwin.size(0) < 2) {
          i5 = 1;
          i8 = 1;
          loop_ub_tmp = 0;
        } else {
          i5 = bwin.size(0);
          if (i5 < 2) {
            rtDynamicBoundsError(2, 1, i5, vf_emlrtBCI);
          }

          i5 = 2;
          i8 = 2;
          i7 = bwin.size(0);
          loop_ub_tmp = bwin.size(0);
          if ((loop_ub_tmp < 1) || (loop_ub_tmp > i7)) {
            rtDynamicBoundsError(loop_ub_tmp, 1, i7, uf_emlrtBCI);
          }
        }

        if (bwin.size(1) < 2) {
          i7 = 1;
          i9 = 1;
          i10 = 0;
        } else {
          i7 = bwin.size(1);
          if (i7 < 2) {
            rtDynamicBoundsError(2, 1, i7, xf_emlrtBCI);
          }

          i7 = 2;
          i9 = 2;
          b_loop_ub_tmp = bwin.size(1);
          i10 = bwin.size(1);
          if ((i10 < 1) || (i10 > b_loop_ub_tmp)) {
            rtDynamicBoundsError(i10, 1, b_loop_ub_tmp, wf_emlrtBCI);
          }
        }

        iv[0] = div_s32(loop_ub_tmp - i5, i8) + 1;
        iv[1] = div_s32(i10 - i7, i9) + 1;
        loop_ub_tmp = div_s32(i2 - i, i1);
        iv1[0] = loop_ub_tmp + 1;
        b_loop_ub_tmp = div_s32(i6 - i3, i4);
        iv1[1] = b_loop_ub_tmp + 1;
        rtSubAssignSizeCheck(&iv[0], 2, &iv1[0], 2, rb_emlrtECI);
        for (i2 = 0; i2 <= b_loop_ub_tmp; i2++) {
          for (i6 = 0; i6 <= loop_ub_tmp; i6++) {
            bwin[((i5 + i8 * i6) + bwin.size(0) * ((i7 + i9 * i2) - 1)) - 1] =
              m[((i + i1 * i6) + m.size(0) * ((i3 + i4 * i2) - 1)) - 1];
          }
        }

        bwlookup(bwin, m);
        loop_ub_tmp = m.size(0) * m.size(1);
        for (i = 0; i < loop_ub_tmp; i++) {
          m[i] = !m[i];
        }

        i = bwin.size(0);
        if ((i != m.size(0)) && ((i != 1) && (m.size(0) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(0), qb_emlrtECI);
        }

        i = bwin.size(1);
        if ((i != m.size(1)) && ((i != 1) && (m.size(1) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(1), pb_emlrtECI);
        }

        if ((bwin.size(0) == m.size(0)) && (bwin.size(1) == m.size(1))) {
          loop_ub_tmp = bwin.size(0) * bwin.size(1);
          m.set_size(bwin.size(0), bwin.size(1));
          for (i = 0; i < loop_ub_tmp; i++) {
            m[i] = (bwin[i] && m[i]);
          }
        } else {
          d_and(m, bwin);
        }

        if (m.size(0) < 1) {
          i = 1;
          i1 = -1;
        } else {
          i = 2;
          i1 = m.size(0) - 1;
        }

        if (m.size(1) < 2) {
          i2 = 1;
          i3 = 1;
          i4 = 0;
        } else {
          i2 = 2;
          i3 = 2;
          i4 = m.size(1);
        }

        if (bwin.size(0) < 1) {
          i6 = 1;
          i8 = 0;
        } else {
          i6 = bwin.size(0);
          if (i6 < 1) {
            rtDynamicBoundsError(1, 1, i6, ag_emlrtBCI);
          }

          i6 = 2;
          i5 = bwin.size(0);
          i8 = bwin.size(0);
          if ((i8 < 1) || (i8 > i5)) {
            rtDynamicBoundsError(i8, 1, i5, yf_emlrtBCI);
          }
        }

        if (bwin.size(1) < 2) {
          i5 = 1;
          i7 = 1;
          i9 = 0;
        } else {
          i5 = bwin.size(1);
          if (i5 < 2) {
            rtDynamicBoundsError(2, 1, i5, cg_emlrtBCI);
          }

          i5 = 2;
          i7 = 2;
          loop_ub_tmp = bwin.size(1);
          i9 = bwin.size(1);
          if ((i9 < 1) || (i9 > loop_ub_tmp)) {
            rtDynamicBoundsError(i9, 1, loop_ub_tmp, bg_emlrtBCI);
          }
        }

        iv[0] = div_s32(i8 - 1, i6) + 1;
        iv[1] = div_s32(i9 - i5, i7) + 1;
        loop_ub_tmp = div_s32(i1, i);
        iv1[0] = loop_ub_tmp + 1;
        b_loop_ub_tmp = div_s32(i4 - i2, i3);
        iv1[1] = b_loop_ub_tmp + 1;
        rtSubAssignSizeCheck(&iv[0], 2, &iv1[0], 2, ob_emlrtECI);
        for (i1 = 0; i1 <= b_loop_ub_tmp; i1++) {
          for (i4 = 0; i4 <= loop_ub_tmp; i4++) {
            bwin[i6 * i4 + bwin.size(0) * ((i5 + i7 * i1) - 1)] = m[i * i4 +
              m.size(0) * ((i2 + i3 * i1) - 1)];
          }
        }

        bwlookup(bwin, m);
        loop_ub_tmp = m.size(0) * m.size(1);
        for (i = 0; i < loop_ub_tmp; i++) {
          m[i] = !m[i];
        }

        i = bwin.size(0);
        if ((i != m.size(0)) && ((i != 1) && (m.size(0) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(0), nb_emlrtECI);
        }

        i = bwin.size(1);
        if ((i != m.size(1)) && ((i != 1) && (m.size(1) != 1))) {
          emlrtDimSizeImpxCheckR2021b(i, m.size(1), mb_emlrtECI);
        }

        if ((bwin.size(0) == m.size(0)) && (bwin.size(1) == m.size(1))) {
          loop_ub_tmp = bwin.size(0) * bwin.size(1);
          m.set_size(bwin.size(0), bwin.size(1));
          for (i = 0; i < loop_ub_tmp; i++) {
            m[i] = (bwin[i] && m[i]);
          }
        } else {
          d_and(m, bwin);
        }

        if (m.size(0) < 2) {
          i = 1;
          i1 = 1;
          i2 = 0;
        } else {
          i = 2;
          i1 = 2;
          i2 = m.size(0);
        }

        if (m.size(1) < 1) {
          i3 = 1;
          i4 = -1;
        } else {
          i3 = 2;
          i4 = m.size(1) - 1;
        }

        if (bwin.size(0) < 2) {
          i6 = 1;
          i5 = 1;
          i7 = 0;
        } else {
          i6 = bwin.size(0);
          if (i6 < 2) {
            rtDynamicBoundsError(2, 1, i6, eg_emlrtBCI);
          }

          i6 = 2;
          i5 = 2;
          i8 = bwin.size(0);
          i7 = bwin.size(0);
          if ((i7 < 1) || (i7 > i8)) {
            rtDynamicBoundsError(i7, 1, i8, dg_emlrtBCI);
          }
        }

        if (bwin.size(1) < 1) {
          i8 = 1;
          i9 = 0;
        } else {
          i8 = bwin.size(1);
          if (i8 < 1) {
            rtDynamicBoundsError(1, 1, i8, gg_emlrtBCI);
          }

          i8 = 2;
          loop_ub_tmp = bwin.size(1);
          i9 = bwin.size(1);
          if ((i9 < 1) || (i9 > loop_ub_tmp)) {
            rtDynamicBoundsError(i9, 1, loop_ub_tmp, fg_emlrtBCI);
          }
        }

        iv[0] = div_s32(i7 - i6, i5) + 1;
        iv[1] = div_s32(i9 - 1, i8) + 1;
        loop_ub_tmp = div_s32(i2 - i, i1);
        iv1[0] = loop_ub_tmp + 1;
        b_loop_ub_tmp = div_s32(i4, i3);
        iv1[1] = b_loop_ub_tmp + 1;
        rtSubAssignSizeCheck(&iv[0], 2, &iv1[0], 2, lb_emlrtECI);
        for (i2 = 0; i2 <= b_loop_ub_tmp; i2++) {
          for (i4 = 0; i4 <= loop_ub_tmp; i4++) {
            bwin[((i6 + i5 * i4) + bwin.size(0) * (i8 * i2)) - 1] = m[((i + i1 *
              i4) + m.size(0) * (i3 * i2)) - 1];
          }
        }
      } while (!isequal(last_aout, bwin));

      //  the output is not changing anymore
    }
  }

  //
  // Arguments    : const ::coder::array<bool, 1U> &x
  //                ::coder::array<int, 1U> &i
  // Return Type  : void
  //
  static void c_eml_find(const ::coder::array<bool, 1U> &x, ::coder::array<int,
    1U> &i)
  {
    int idx;
    int ii;
    int nx;
    bool exitg1;
    nx = x.size(0);
    idx = 0;
    i.set_size(x.size(0));
    if (x.size(0) > 2147483646) {
      check_forloop_overflow_error();
    }

    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= nx - 1)) {
      if (x[ii]) {
        idx++;
        i[idx - 1] = ii + 1;
        if (idx >= nx) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (idx > x.size(0)) {
      c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
    }

    if (x.size(0) == 1) {
      if (idx == 0) {
        i.set_size(0);
      }
    } else {
      int iv[2];
      if (idx < 1) {
        nx = 0;
      } else {
        nx = idx;
      }

      iv[0] = 1;
      iv[1] = nx;
      internal::indexShapeCheck(i.size(0), iv);
      i.set_size(nx);
    }
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &varargin_1
  //                const ::coder::array<double, 2U> &varargin_2
  //                ::coder::array<double, 3U> &y
  // Return Type  : void
  //
  static void cat(const ::coder::array<double, 2U> &varargin_1, const ::coder::
                  array<double, 2U> &varargin_2, ::coder::array<double, 3U> &y)
  {
    static rtRunTimeErrorInfo s_emlrtRTEI{ 91,// lineNo
      27,                              // colNo
      "cat",                           // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/elmat/cat.m"// pName
    };

    int ysize[3];
    int b;
    int b_b;
    int j;
    bool exitg1;
    ysize[0] = varargin_1.size(0);
    ysize[1] = varargin_1.size(1);
    ysize[2] = 2;
    j = 0;
    exitg1 = false;
    while ((!exitg1) && (j < 2)) {
      if (ysize[j] != varargin_1.size(j)) {
        u_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
      } else {
        j++;
      }
    }

    j = 0;
    exitg1 = false;
    while ((!exitg1) && (j < 2)) {
      if (ysize[j] != varargin_2.size(j)) {
        u_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
      } else {
        j++;
      }
    }

    y.set_size(varargin_1.size(0), varargin_1.size(1), 2);
    b = varargin_1.size(0) * varargin_1.size(1);
    if (b > 2147483646) {
      check_forloop_overflow_error();
    }

    for (j = 0; j < b; j++) {
      y[j] = varargin_1[j];
    }

    b_b = varargin_2.size(0) * varargin_2.size(1);
    if (b_b > 2147483646) {
      check_forloop_overflow_error();
    }

    for (j = 0; j < b_b; j++) {
      y[b + j] = varargin_2[j];
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  static void check_forloop_overflow_error()
  {
    static rtRunTimeErrorInfo s_emlrtRTEI{ 87,// lineNo
      33,                              // colNo
      "check_forloop_overflow_error",  // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/eml/eml_int_forloop_overflow_check.m"// pName
    };

    e_rtErrorWithMessageID("int32", s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
  }

  //
  // Arguments    : const double hCol[15]
  //                const double hRow[15]
  //                const ::coder::array<double, 2U> &inImg
  //                const double finalSize[2]
  //                ::coder::array<double, 2U> &outImg
  // Return Type  : void
  //
  static void conv2_separable_valid(const double hCol[15], const double hRow[15],
    const ::coder::array<double, 2U> &inImg, const double finalSize[2], ::coder::
    array<double, 2U> &outImg)
  {
    array<double, 2U> temp;
    array<double, 1U> r;
    int b_i;
    int i;
    int i1;
    int iy;
    int loop_ub;
    int tempRows;
    int ub_loop;
    int ub_loop_tmp;
    bool b;
    tempRows = inImg.size(0);
    ub_loop = static_cast<int>(finalSize[0]);
    i = static_cast<int>(finalSize[0]);
    outImg.set_size(ub_loop, static_cast<int>(finalSize[1]));
    temp.set_size(inImg.size(0), static_cast<int>(finalSize[1]));
    ub_loop_tmp = static_cast<int>(finalSize[1]) - 1;
    ub_loop = static_cast<int>(finalSize[1]) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(r,b,i1,loop_ub,b_i,iy)

    for (int ix = 0; ix <= ub_loop; ix++) {
      b = ((ix + 1 < 1) || (ix + 1 > temp.size(1)));
      if (b) {
        rtDynamicBoundsError(ix + 1, 1, temp.size(1), l_emlrtBCI);
      }

      rtSubAssignSizeCheck(temp.size(), 1, &tempRows, 1, o_emlrtECI);
      for (i1 = 0; i1 < tempRows; i1++) {
        temp[i1 + temp.size(0) * ix] = 0.0;
      }

      loop_ub = inImg.size(0);
      for (b_i = 0; b_i < 15; b_i++) {
        iy = static_cast<int>((static_cast<unsigned int>(ix) + static_cast<
          unsigned int>(b_i)) + 1U);
        if ((iy < 1) || (iy > inImg.size(1))) {
          rtDynamicBoundsError(iy, 1, inImg.size(1), m_emlrtBCI);
        }

        r.set_size(inImg.size(0));
        for (i1 = 0; i1 < loop_ub; i1++) {
          r[i1] = inImg[i1 + inImg.size(0) * (iy - 1)] * hRow[b_i];
        }

        iy = temp.size(0);
        if ((temp.size(0) != r.size(0)) && ((temp.size(0) != 1) && (r.size(0) !=
              1))) {
          emlrtDimSizeImpxCheckR2021b(temp.size(0), r.size(0), p_emlrtECI);
        }

        r.set_size(temp.size(0));
        for (i1 = 0; i1 < iy; i1++) {
          r[i1] = temp[i1 + temp.size(0) * ix] + r[i1];
        }

        rtSubAssignSizeCheck(temp.size(), 1, r.size(), 1, q_emlrtECI);
        iy = r.size(0);
        for (i1 = 0; i1 < iy; i1++) {
          temp[i1 + temp.size(0) * ix] = r[i1];
        }
      }
    }

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(iy,b,b_i,i1)

    for (int ix = 0; ix <= ub_loop_tmp; ix++) {
      for (iy = 0; iy < i; iy++) {
        b = ((static_cast<int>(static_cast<unsigned int>(iy) + 1U) < 1) || (
              static_cast<int>(static_cast<unsigned int>(iy) + 1U) > outImg.size
              (0)));
        if (b) {
          rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(iy) +
            1U), 1, outImg.size(0), n_emlrtBCI);
        }

        b = ((static_cast<int>(static_cast<unsigned int>(ix) + 1U) < 1) || (
              static_cast<int>(static_cast<unsigned int>(ix) + 1U) > outImg.size
              (1)));
        if (b) {
          rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(ix) +
            1U), 1, outImg.size(1), o_emlrtBCI);
        }

        outImg[iy + outImg.size(0) * ix] = 0.0;
        for (b_i = 0; b_i < 15; b_i++) {
          i1 = static_cast<int>((static_cast<unsigned int>(iy) + static_cast<
            unsigned int>(b_i)) + 1U);
          if ((i1 < 1) || (i1 > temp.size(0))) {
            rtDynamicBoundsError(i1, 1, temp.size(0), p_emlrtBCI);
          }

          outImg[iy + outImg.size(0) * ix] = outImg[iy + outImg.size(0) * ix] +
            temp[(i1 + temp.size(0) * ix) - 1] * hCol[b_i];
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &a
  //                const ::coder::array<double, 2U> &b
  //                ::coder::array<double, 2U> &c
  //                ::coder::array<int, 1U> &ia
  // Return Type  : int
  //
  static int do_vectors(const ::coder::array<double, 2U> &a, const ::coder::
                        array<double, 2U> &b, ::coder::array<double, 2U> &c, ::
                        coder::array<int, 1U> &ia)
  {
    array<int, 2U> aperm;
    array<int, 2U> bperm;
    array<int, 1U> b_ia;
    int b_ialast;
    int iafirst;
    int ialast;
    int ib_size;
    int iblast;
    int na;
    int nc;
    int nia;
    na = a.size(1);
    c.set_size(1, a.size(1));
    ia.set_size(a.size(1));
    ib_size = 0;
    internal::sortIdx(a, aperm);
    internal::sortIdx(b, bperm);
    nc = 0;
    nia = 0;
    iafirst = 0;
    ialast = 1;
    iblast = 1;
    while ((ialast <= na) && (iblast <= b.size(1))) {
      double ak;
      double bk;
      b_ialast = ialast;
      ak = a[aperm[ialast - 1] - 1];
      while ((b_ialast < a.size(1)) && (a[aperm[b_ialast] - 1] == ak)) {
        b_ialast++;
      }

      ialast = b_ialast;
      bk = b[bperm[iblast - 1] - 1];
      while ((iblast < b.size(1)) && (b[bperm[iblast] - 1] == bk)) {
        iblast++;
      }

      if (ak == bk) {
        ialast = b_ialast + 1;
        iafirst = b_ialast;
        iblast++;
      } else {
        bool p;
        if (std::isnan(bk)) {
          p = !std::isnan(ak);
        } else if (std::isnan(ak)) {
          p = false;
        } else {
          p = (ak < bk);
        }

        if (p) {
          nia = nc + 1;
          nc++;
          ia[nia - 1] = aperm[iafirst];
          ialast = b_ialast + 1;
          iafirst = b_ialast;
        } else {
          iblast++;
        }
      }
    }

    while (ialast <= na) {
      b_ialast = ialast;
      while ((b_ialast < a.size(1)) && (a[aperm[b_ialast] - 1] == a[aperm[ialast
              - 1] - 1])) {
        b_ialast++;
      }

      nia = nc + 1;
      nc++;
      ia[nia - 1] = aperm[iafirst];
      ialast = b_ialast + 1;
      iafirst = b_ialast;
    }

    if (a.size(1) > 0) {
      if (nia > a.size(1)) {
        c_rtErrorWithMessageID(o_emlrtRTEI.fName, o_emlrtRTEI.lineNo);
      }

      if (nia < 1) {
        iafirst = 0;
      } else {
        iafirst = nia;
      }

      ia.set_size(iafirst);
    }

    internal::sort(ia, b_ia);
    if (nia > 2147483646) {
      check_forloop_overflow_error();
    }

    for (na = 0; na < nia; na++) {
      c[na] = a[ia[na] - 1];
    }

    if (a.size(1) > 0) {
      if (nc > a.size(1)) {
        c_rtErrorWithMessageID(n_emlrtRTEI.fName, n_emlrtRTEI.lineNo);
      }

      if (nc < 1) {
        nc = 0;
      }

      c.set_size(c.size(0), nc);
    }

    return ib_size;
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &a
  //                const ::coder::array<double, 1U> &b
  //                ::coder::array<double, 2U> &c
  //                ::coder::array<int, 1U> &ia
  // Return Type  : int
  //
  static int do_vectors(const ::coder::array<double, 2U> &a, const ::coder::
                        array<double, 1U> &b, ::coder::array<double, 2U> &c, ::
                        coder::array<int, 1U> &ia)
  {
    array<int, 2U> aperm;
    array<int, 1U> b_ia;
    array<int, 1U> bperm;
    array<int, 1U> iwork;
    double ak;
    int b_i;
    int i;
    int ialast;
    int ib_size;
    int iblast;
    int k;
    int n;
    int na;
    int nc;
    int nia;
    int pEnd;
    int qEnd;
    na = a.size(1);
    c.set_size(1, a.size(1));
    ia.set_size(a.size(1));
    ib_size = 0;
    internal::sortIdx(a, aperm);
    n = b.size(0) + 1;
    bperm.set_size(b.size(0));
    i = b.size(0);
    for (b_i = 0; b_i < i; b_i++) {
      bperm[b_i] = 0;
    }

    if (b.size(0) != 0) {
      iwork.set_size(b.size(0));
      i = b.size(0) - 1;
      if (b.size(0) - 1 > 2147483645) {
        check_forloop_overflow_error();
      }

      for (k = 1; k <= i; k += 2) {
        if ((b[k - 1] <= b[k]) || std::isnan(b[k])) {
          bperm[k - 1] = k;
          bperm[k] = k + 1;
        } else {
          bperm[k - 1] = k + 1;
          bperm[k] = k;
        }
      }

      if ((b.size(0) & 1) != 0) {
        bperm[b.size(0) - 1] = b.size(0);
      }

      i = 2;
      while (i < n - 1) {
        ialast = i << 1;
        iblast = 1;
        for (pEnd = i + 1; pEnd < n; pEnd = qEnd + i) {
          int kEnd;
          nc = iblast;
          nia = pEnd - 1;
          qEnd = iblast + ialast;
          if (qEnd > n) {
            qEnd = n;
          }

          k = 0;
          kEnd = qEnd - iblast;
          while (k + 1 <= kEnd) {
            ak = b[bperm[nia] - 1];
            b_i = bperm[nc - 1];
            if ((b[b_i - 1] <= ak) || std::isnan(ak)) {
              iwork[k] = b_i;
              nc++;
              if (nc == pEnd) {
                while (nia + 1 < qEnd) {
                  k++;
                  iwork[k] = bperm[nia];
                  nia++;
                }
              }
            } else {
              iwork[k] = bperm[nia];
              nia++;
              if (nia + 1 == qEnd) {
                while (nc < pEnd) {
                  k++;
                  iwork[k] = bperm[nc - 1];
                  nc++;
                }
              }
            }

            k++;
          }

          for (k = 0; k < kEnd; k++) {
            bperm[(iblast + k) - 1] = iwork[k];
          }

          iblast = qEnd;
        }

        i = ialast;
      }
    }

    nc = 0;
    nia = 0;
    i = 0;
    ialast = 1;
    iblast = 1;
    while ((ialast <= na) && (iblast <= b.size(0))) {
      double bk;
      pEnd = ialast;
      ak = a[aperm[ialast - 1] - 1];
      while ((pEnd < a.size(1)) && (a[aperm[pEnd] - 1] == ak)) {
        pEnd++;
      }

      ialast = pEnd;
      bk = b[bperm[iblast - 1] - 1];
      while ((iblast < b.size(0)) && (b[bperm[iblast] - 1] == bk)) {
        iblast++;
      }

      if (ak == bk) {
        ialast = pEnd + 1;
        i = pEnd;
        iblast++;
      } else {
        bool p;
        if (std::isnan(bk)) {
          p = !std::isnan(ak);
        } else if (std::isnan(ak)) {
          p = false;
        } else {
          p = (ak < bk);
        }

        if (p) {
          nia = nc + 1;
          nc++;
          ia[nia - 1] = aperm[i];
          ialast = pEnd + 1;
          i = pEnd;
        } else {
          iblast++;
        }
      }
    }

    while (ialast <= na) {
      pEnd = ialast;
      while ((pEnd < a.size(1)) && (a[aperm[pEnd] - 1] == a[aperm[ialast - 1] -
              1])) {
        pEnd++;
      }

      nia = nc + 1;
      nc++;
      ia[nia - 1] = aperm[i];
      ialast = pEnd + 1;
      i = pEnd;
    }

    if (a.size(1) > 0) {
      if (nia > a.size(1)) {
        c_rtErrorWithMessageID(o_emlrtRTEI.fName, o_emlrtRTEI.lineNo);
      }

      if (nia < 1) {
        b_i = 0;
      } else {
        b_i = nia;
      }

      ia.set_size(b_i);
    }

    internal::sort(ia, b_ia);
    if (nia > 2147483646) {
      check_forloop_overflow_error();
    }

    for (k = 0; k < nia; k++) {
      c[k] = a[ia[k] - 1];
    }

    if (a.size(1) > 0) {
      if (nc > a.size(1)) {
        c_rtErrorWithMessageID(n_emlrtRTEI.fName, n_emlrtRTEI.lineNo);
      }

      if (nc < 1) {
        nc = 0;
      }

      c.set_size(c.size(0), nc);
    }

    return ib_size;
  }

  //
  // Arguments    : const ::coder::array<double, 1U> &x
  //                ::coder::array<int, 1U> &i
  // Return Type  : void
  //
  static void eml_find(const ::coder::array<double, 1U> &x, ::coder::array<int,
                       1U> &i)
  {
    int idx;
    int ii;
    int nx;
    bool exitg1;
    nx = x.size(0);
    idx = 0;
    i.set_size(x.size(0));
    if (x.size(0) > 2147483646) {
      check_forloop_overflow_error();
    }

    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= nx - 1)) {
      if (x[ii] != 0.0) {
        idx++;
        i[idx - 1] = ii + 1;
        if (idx >= nx) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (idx > x.size(0)) {
      c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
    }

    if (x.size(0) == 1) {
      if (idx == 0) {
        i.set_size(0);
      }
    } else {
      int iv[2];
      if (idx < 1) {
        nx = 0;
      } else {
        nx = idx;
      }

      iv[0] = 1;
      iv[1] = nx;
      internal::indexShapeCheck(i.size(0), iv);
      i.set_size(nx);
    }
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &x
  //                ::coder::array<int, 2U> &i
  // Return Type  : void
  //
  static void eml_find(const ::coder::array<double, 2U> &x, ::coder::array<int,
                       2U> &i)
  {
    int idx;
    int ii;
    int nx;
    bool exitg1;
    nx = x.size(1);
    idx = 0;
    i.set_size(1, x.size(1));
    if (x.size(1) > 2147483646) {
      check_forloop_overflow_error();
    }

    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= nx - 1)) {
      if (x[ii] != 0.0) {
        idx++;
        i[idx - 1] = ii + 1;
        if (idx >= nx) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (idx > x.size(1)) {
      c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
    }

    if (x.size(1) == 1) {
      if (idx == 0) {
        i.set_size(1, 0);
      }
    } else {
      if (idx < 1) {
        idx = 0;
      }

      i.set_size(i.size(0), idx);
    }
  }

  //
  // Arguments    : ::coder::array<double, 2U> &x
  //                double dim
  // Return Type  : void
  //
  static void flip(::coder::array<double, 2U> &x, double dim)
  {
    static rtRunTimeErrorInfo s_emlrtRTEI{ 57,// lineNo
      27,                              // colNo
      "assertValidDim",                // fName
      "/usr/local/MATLAB/R2023a/toolbox/shared/coder/coder/lib/+coder/+internal/assertValidDim.m"// pName
    };

    if (!(dim == std::floor(dim))) {
      ab_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
    }

    if ((x.size(0) != 0) && (x.size(1) != 0)) {
      int i;
      i = x.size(static_cast<int>(dim) - 1);
      if (i > 1) {
        int lowerDim;
        int nd2;
        int npages;
        int pagelen;
        int vstride;
        vstride = 1;
        if (static_cast<int>(dim) - 1 > 2147483646) {
          check_forloop_overflow_error();
        }

        lowerDim = static_cast<unsigned char>(static_cast<int>(dim) - 1);
        for (int k{0}; k < lowerDim; k++) {
          vstride *= x.size(0);
        }

        pagelen = vstride * i;
        npages = 1;
        lowerDim = static_cast<int>(dim) + 1;
        for (int k{lowerDim}; k < 3; k++) {
          npages *= x.size(1);
        }

        nd2 = i >> 1;
        lowerDim = npages - 1;
        for (int j{0}; j <= lowerDim; j++) {
          npages = vstride - 1;
          for (int b_i{0}; b_i <= npages; b_i++) {
            int offset;
            offset = j * pagelen + b_i;
            for (int k{0}; k < nd2; k++) {
              double tmp;
              int i1;
              int tmp_tmp;
              tmp_tmp = offset + k * vstride;
              tmp = x[tmp_tmp];
              i1 = offset + ((i - k) - 1) * vstride;
              x[tmp_tmp] = x[i1];
              x[i1] = tmp;
            }
          }
        }
      }
    }
  }

  //
  // Arguments    : ::coder::array<float, 2U> &varargin_1
  // Return Type  : void
  //
  static void imfilter(::coder::array<float, 2U> &varargin_1)
  {
    array<double, 2U> b;
    array<double, 2U> b_a;
    array<double, 1U> c;
    array<double, 1U> c_a;
    array<float, 2U> a;
    double pad[2];
    pad[0] = 0.0;
    pad[1] = 1.0;
    if ((varargin_1.size(0) != 0) && (varargin_1.size(1) != 0)) {
      int ib;
      int mc;
      padImage_outSize(varargin_1, pad, a);
      b_a.set_size(a.size(0), a.size(1));
      mc = a.size(0) * a.size(1);
      for (int i{0}; i < mc; i++) {
        b_a[i] = a[i];
      }

      if (b_a.size(0) == 1) {
        c_a.set_size(b_a.size(1));
        mc = b_a.size(1);
        for (int i{0}; i < mc; i++) {
          c_a[i] = b_a[b_a.size(0) * i];
        }

        if (c_a.size(0) < 2) {
          mc = -1;
        } else {
          mc = c_a.size(0) - 3;
        }

        c.set_size(mc + 1);
        for (int i{0}; i <= mc; i++) {
          c[i] = 0.0;
        }

        if ((c_a.size(0) != 0) && (mc + 1 != 0)) {
          for (ib = 0; ib < 3; ib++) {
            for (int b_i{0}; b_i <= mc; b_i++) {
              c[b_i] = c[b_i] + ((2.0 - static_cast<double>(ib)) - 1.0) * c_a[ib
                + b_i];
            }
          }
        }

        b.set_size(1, c.size(0));
        mc = c.size(0);
        for (int i{0}; i < mc; i++) {
          b[b.size(0) * i] = c[i];
        }
      } else {
        internal::b_conv2AXPYValidCMP(b_a, b);
      }

      varargin_1.set_size(b.size(0), b.size(1));
      mc = b.size(1);
      for (int i{0}; i < mc; i++) {
        ib = b.size(0);
        for (int b_i{0}; b_i < ib; b_i++) {
          varargin_1[b_i + varargin_1.size(0) * i] = static_cast<float>(b[b_i +
            b.size(0) * i]);
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<float, 1U> &x
  //                int hi
  // Return Type  : bool
  //
  namespace internal
  {
    static bool allinrange(const ::coder::array<float, 1U> &x, int hi)
    {
      int k;
      bool p;
      k = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (k <= x.size(0) - 1) {
          if ((x[k] >= 1.0F) && ((x[k] <= -2.14748365E+9F) || ((x[k] <
                 2.14748365E+9F) && (hi >= static_cast<int>(x[k]))))) {
            k++;
          } else {
            p = false;
            exitg1 = 1;
          }
        } else {
          p = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);

      return p;
    }

    //
    // Arguments    : const ::coder::array<double, 2U> &a
    //                ::coder::array<double, 2U> &c
    // Return Type  : void
    //
    static void b_conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c)
    {
      array<double, 1U> cj;
      int i;
      int jb;
      int mc;
      int nc;
      bool overflow;
      mc = a.size(0);
      if (a.size(1) < 2) {
        nc = 0;
      } else {
        nc = a.size(1) - 2;
      }

      if ((a.size(0) == 0) || (a.size(1) == 0) || (nc == 0)) {
        c.set_size(a.size(0), nc);
        nc *= a.size(0);
        for (mc = 0; mc < nc; mc++) {
          c[mc] = 0.0;
        }
      } else {
        c.set_size(a.size(0), nc);
        nc--;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(cj,i,overflow,jb)

        for (int j = 0; j <= nc; j++) {
          cj.set_size(mc);
          for (i = 0; i < mc; i++) {
            cj[i] = 0.0;
          }

          overflow = (mc > 2147483646);
          for (jb = 0; jb < 3; jb++) {
            if (overflow) {
              check_forloop_overflow_error();
            }

            for (i = 0; i < mc; i++) {
              cj[i] = cj[i] + (1.0 - static_cast<double>(jb)) * a[i + a.size(0) *
                (j + jb)];
            }
          }

          jb = cj.size(0);
          for (i = 0; i < jb; i++) {
            c[i + c.size(0) * j] = cj[i];
          }
        }
      }
    }

    //
    // Arguments    : const int matrixSize[2]
    //                const int indexSize[2]
    // Return Type  : void
    //
    static void b_indexShapeCheck(const int matrixSize[2], const int indexSize[2])
    {
      bool nonSingletonDimFound;
      nonSingletonDimFound = (matrixSize[0] != 1);
      if (matrixSize[1] != 1) {
        if (nonSingletonDimFound) {
          nonSingletonDimFound = false;
        } else {
          nonSingletonDimFound = true;
        }
      }

      if (nonSingletonDimFound) {
        nonSingletonDimFound = (matrixSize[0] == 1);
        if (nonSingletonDimFound || (matrixSize[1] != 1)) {
          nonSingletonDimFound = true;
        }

        if (nonSingletonDimFound) {
          v_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
        }
      } else {
        nonSingletonDimFound = (indexSize[0] != 1);
        if (indexSize[1] != 1) {
          if (nonSingletonDimFound) {
            nonSingletonDimFound = false;
          } else {
            nonSingletonDimFound = true;
          }
        }

        if (nonSingletonDimFound) {
          nonSingletonDimFound = (indexSize[0] == 1);
          if (nonSingletonDimFound || (indexSize[1] != 1)) {
            nonSingletonDimFound = true;
          }

          if (nonSingletonDimFound) {
            w_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
          }
        }
      }
    }

    //
    // Arguments    : const int matrixSize[2]
    //                int indexSize
    // Return Type  : void
    //
    static void b_indexShapeCheck(const int matrixSize[2], int indexSize)
    {
      if ((matrixSize[1] == 1) && (indexSize != 1)) {
        f_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
      }
    }

    //
    // Arguments    : const int matrixSize[2]
    // Return Type  : void
    //
    static void b_indexShapeCheck(const int matrixSize[2])
    {
      bool nonSingletonDimFound;
      nonSingletonDimFound = (matrixSize[0] != 1);
      if (matrixSize[1] != 1) {
        if (nonSingletonDimFound) {
          nonSingletonDimFound = false;
        } else {
          nonSingletonDimFound = true;
        }
      }

      if (nonSingletonDimFound && ((matrixSize[0] == 1) || (matrixSize[1] != 1)))
      {
        e_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
      }
    }

    //
    // Arguments    : int n
    //                const ::coder::array<double, 2U> &x
    //                int ix0
    // Return Type  : double
    //
    namespace blas
    {
      static double xnrm2(int n, const ::coder::array<double, 2U> &x, int ix0)
      {
        double y;
        y = 0.0;
        if (n >= 1) {
          if (n == 1) {
            y = std::abs(x[ix0 - 1]);
          } else {
            double scale;
            int kend;
            scale = 3.3121686421112381E-170;
            kend = (ix0 + n) - 1;
            if ((ix0 <= kend) && (kend > 2147483646)) {
              check_forloop_overflow_error();
            }

            for (int k{ix0}; k <= kend; k++) {
              double absxk;
              absxk = std::abs(x[k - 1]);
              if (absxk > scale) {
                double t;
                t = scale / absxk;
                y = y * t * t + 1.0;
                scale = absxk;
              } else {
                double t;
                t = absxk / scale;
                y += t * t;
              }
            }

            y = scale * std::sqrt(y);
          }
        }

        return y;
      }

      //
      // Arguments    : const ::coder::array<double, 2U> &a
      //                ::coder::array<double, 2U> &c
      // Return Type  : void
      //
    }

    static void c_conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c)
    {
      static const double b[49]{ 0.0013419653598432805, 0.0040765308179236169,
        0.0079399978434782879, 0.0099158573267036573, 0.0079399978434782879,
        0.0040765308179236169, 0.0013419653598432805, 0.0040765308179236169,
        0.012383407207635906, 0.02411958376255428, 0.030121714902657252,
        0.02411958376255428, 0.012383407207635906, 0.0040765308179236169,
        0.0079399978434782879, 0.02411958376255428, 0.046978534350396596,
        0.058669089490849466, 0.046978534350396596, 0.02411958376255428,
        0.0079399978434782879, 0.0099158573267036573, 0.030121714902657252,
        0.058669089490849466, 0.073268826056005834, 0.058669089490849466,
        0.030121714902657252, 0.0099158573267036573, 0.0079399978434782879,
        0.02411958376255428, 0.046978534350396596, 0.058669089490849466,
        0.046978534350396596, 0.02411958376255428, 0.0079399978434782879,
        0.0040765308179236169, 0.012383407207635906, 0.02411958376255428,
        0.030121714902657252, 0.02411958376255428, 0.012383407207635906,
        0.0040765308179236169, 0.0013419653598432805, 0.0040765308179236169,
        0.0079399978434782879, 0.0099158573267036573, 0.0079399978434782879,
        0.0040765308179236169, 0.0013419653598432805 };

      array<double, 1U> cj;
      double bij;
      int i;
      int ib;
      int jb;
      int mc;
      int nc;
      if (a.size(0) < 6) {
        mc = 0;
      } else {
        mc = a.size(0) - 6;
      }

      if (a.size(1) < 6) {
        nc = 0;
      } else {
        nc = a.size(1) - 6;
      }

      if ((a.size(0) == 0) || (a.size(1) == 0) || (mc == 0) || (nc == 0)) {
        c.set_size(mc, nc);
        nc *= mc;
        for (mc = 0; mc < nc; mc++) {
          c[mc] = 0.0;
        }
      } else {
        c.set_size(mc, nc);
        nc--;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(cj,bij,ib,jb,i)

        for (int j = 0; j <= nc; j++) {
          cj.set_size(mc);
          for (ib = 0; ib < mc; ib++) {
            cj[ib] = 0.0;
          }

          for (jb = 0; jb < 7; jb++) {
            for (ib = 0; ib < 7; ib++) {
              bij = b[(7 * (6 - jb) - ib) + 6];
              for (i = 0; i < mc; i++) {
                cj[i] = cj[i] + bij * a[(i + ib) + a.size(0) * (j + jb)];
              }
            }
          }

          jb = cj.size(0);
          for (ib = 0; ib < jb; ib++) {
            c[ib + c.size(0) * j] = cj[ib];
          }
        }
      }
    }

    //
    // Arguments    : const ::coder::array<double, 2U> &a
    //                ::coder::array<double, 2U> &c
    // Return Type  : void
    //
    static void conv2AXPYValidCMP(const ::coder::array<double, 2U> &a, ::coder::
      array<double, 2U> &c)
    {
      array<double, 1U> cj;
      int i;
      int ib;
      int mc;
      mc = a.size(0) - 2;
      if ((a.size(1) == 0) || (a.size(0) - 2 == 0)) {
        c.set_size(a.size(0) - 2, a.size(1));
        mc = (a.size(0) - 2) * a.size(1);
        for (int ub_loop{0}; ub_loop < mc; ub_loop++) {
          c[ub_loop] = 0.0;
        }
      } else {
        int ub_loop;
        c.set_size(a.size(0) - 2, a.size(1));
        if (a.size(1) > 2147483646) {
          check_forloop_overflow_error();
        }

        ub_loop = a.size(1) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(cj,i,ib)

        for (int j = 0; j <= ub_loop; j++) {
          cj.set_size(mc);
          for (i = 0; i < mc; i++) {
            cj[i] = 0.0;
          }

          for (ib = 0; ib < 3; ib++) {
            for (i = 0; i < mc; i++) {
              cj[i] = cj[i] + (1.0 - static_cast<double>(ib)) * a[(i + ib) +
                a.size(0) * j];
            }
          }

          ib = cj.size(0);
          for (i = 0; i < ib; i++) {
            c[i + c.size(0) * j] = cj[i];
          }
        }
      }
    }

    //
    // Arguments    : const ::coder::array<bool, 2U> &x
    // Return Type  : bool
    //
    static bool ifWhileCond(const ::coder::array<bool, 2U> &x)
    {
      bool y;
      y = (x.size(1) != 0);
      if (y) {
        int k;
        bool exitg1;
        if (x.size(1) > 2147483646) {
          check_forloop_overflow_error();
        }

        k = 0;
        exitg1 = false;
        while ((!exitg1) && (k <= x.size(1) - 1)) {
          if (!x[k]) {
            y = false;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      return y;
    }

    //
    // Arguments    : const int matrixSize[2]
    //                int indexSize
    // Return Type  : void
    //
    static void indexShapeCheck(const int matrixSize[2], int indexSize)
    {
      bool nonSingletonDimFound;
      nonSingletonDimFound = (matrixSize[0] != 1);
      if (matrixSize[1] != 1) {
        if (nonSingletonDimFound) {
          nonSingletonDimFound = false;
        } else {
          nonSingletonDimFound = true;
        }
      }

      if (nonSingletonDimFound && (indexSize != 1) && (((matrixSize[0] == 1) !=
            (indexSize == 1)) || (matrixSize[1] != 1))) {
        e_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
      }
    }

    //
    // Arguments    : int matrixSize
    //                const int indexSize[2]
    // Return Type  : void
    //
    static void indexShapeCheck(int matrixSize, const int indexSize[2])
    {
      if (matrixSize == 1) {
        bool nonSingletonDimFound;
        nonSingletonDimFound = (indexSize[0] != 1);
        if (indexSize[1] != 1) {
          if (nonSingletonDimFound) {
            nonSingletonDimFound = false;
          } else {
            nonSingletonDimFound = true;
          }
        }

        if (nonSingletonDimFound) {
          f_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
        }
      }
    }

    //
    // Arguments    : const int matrixSize[2]
    //                const int indexSize[2]
    // Return Type  : void
    //
    static void indexShapeCheck(const int matrixSize[2], const int indexSize[2])
    {
      bool nonSingletonDimFound;
      nonSingletonDimFound = (matrixSize[0] != 1);
      if (matrixSize[1] != 1) {
        if (nonSingletonDimFound) {
          nonSingletonDimFound = false;
        } else {
          nonSingletonDimFound = true;
        }
      }

      if (nonSingletonDimFound) {
        nonSingletonDimFound = (indexSize[0] != 1);
        if (indexSize[1] != 1) {
          if (nonSingletonDimFound) {
            nonSingletonDimFound = false;
          } else {
            nonSingletonDimFound = true;
          }
        }

        if (nonSingletonDimFound) {
          nonSingletonDimFound = (matrixSize[0] != 1);
          if (nonSingletonDimFound || ((matrixSize[1] == 1) != (indexSize[1] ==
                1))) {
            nonSingletonDimFound = true;
          }

          if (nonSingletonDimFound) {
            e_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
          }
        }
      }
    }

    //
    // Arguments    : const int matrixSize[2]
    // Return Type  : void
    //
    static void indexShapeCheck(const int matrixSize[2])
    {
      bool nonSingletonDimFound;
      nonSingletonDimFound = (matrixSize[0] != 1);
      if (matrixSize[1] != 1) {
        if (nonSingletonDimFound) {
          nonSingletonDimFound = false;
        } else {
          nonSingletonDimFound = true;
        }
      }

      if (nonSingletonDimFound) {
        nonSingletonDimFound = (matrixSize[0] != 1);
        if (nonSingletonDimFound || (matrixSize[1] == 1)) {
          nonSingletonDimFound = true;
        }

        if (nonSingletonDimFound) {
          e_rtErrorWithMessageID(e_emlrtRTEI.fName, e_emlrtRTEI.lineNo);
        }
      }
    }

    //
    // Arguments    : const float x[3]
    // Return Type  : float
    //
    static float maximum(const float x[3])
    {
      float ex;
      int idx;
      int k;
      if (!std::isnan(x[0])) {
        idx = 1;
      } else {
        bool exitg1;
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k <= 3)) {
          if (!std::isnan(x[k - 1])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        ex = x[0];
      } else {
        ex = x[idx - 1];
        idx++;
        for (k = idx; k < 4; k++) {
          float f;
          f = x[k - 1];
          if (ex < f) {
            ex = f;
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : const ::coder::array<double, 1U> &x
    // Return Type  : double
    //
    static double maximum(const ::coder::array<double, 1U> &x)
    {
      double ex;
      int last;
      if (x.size(0) < 1) {
        d_rtErrorWithMessageID(c_emlrtRTEI.fName, c_emlrtRTEI.lineNo);
      }

      last = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
        } else if ((x[0] < x[1]) || (std::isnan(x[0]) && (!std::isnan(x[1])))) {
          ex = x[1];
        } else {
          ex = x[0];
        }
      } else {
        int idx;
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          if (x.size(0) > 2147483646) {
            check_forloop_overflow_error();
          }

          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
        } else {
          int a;
          ex = x[idx - 1];
          a = idx + 1;
          if ((idx + 1 <= x.size(0)) && (x.size(0) > 2147483646)) {
            check_forloop_overflow_error();
          }

          for (k = a; k <= last; k++) {
            double d;
            d = x[k - 1];
            if (ex < d) {
              ex = d;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<double, 1U> &x
    //                int offset
    //                int np
    //                int nq
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<double, 1U> &xwork
    // Return Type  : void
    //
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<double, 1U>
                      &x, int offset, int np, int nq, ::coder::array<int, 1U>
                      &iwork, ::coder::array<double, 1U> &xwork)
    {
      if (nq != 0) {
        int iout;
        int n_tmp;
        int p;
        int q;
        n_tmp = np + nq;
        if (n_tmp > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int j{0}; j < n_tmp; j++) {
          iout = offset + j;
          iwork[j] = idx[iout];
          xwork[j] = x[iout];
        }

        p = 0;
        q = np;
        iout = offset - 1;
        int exitg1;
        do {
          exitg1 = 0;
          iout++;
          if (xwork[p] <= xwork[q]) {
            idx[iout] = iwork[p];
            x[iout] = xwork[p];
            if (p + 1 < np) {
              p++;
            } else {
              exitg1 = 1;
            }
          } else {
            idx[iout] = iwork[q];
            x[iout] = xwork[q];
            if (q + 1 < n_tmp) {
              q++;
            } else {
              q = iout - p;
              if ((p + 1 <= np) && (np > 2147483646)) {
                check_forloop_overflow_error();
              }

              for (int j{p + 1}; j <= np; j++) {
                iout = q + j;
                idx[iout] = iwork[j - 1];
                x[iout] = xwork[j - 1];
              }

              exitg1 = 1;
            }
          }
        } while (exitg1 == 0);
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<float, 1U> &x
    //                int offset
    //                int np
    //                int nq
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<float, 1U> &xwork
    // Return Type  : void
    //
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<float, 1U> &x,
                      int offset, int np, int nq, ::coder::array<int, 1U> &iwork,
                      ::coder::array<float, 1U> &xwork)
    {
      if (nq != 0) {
        int iout;
        int n_tmp;
        int p;
        int q;
        n_tmp = np + nq;
        if (n_tmp > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int j{0}; j < n_tmp; j++) {
          iout = offset + j;
          iwork[j] = idx[iout];
          xwork[j] = x[iout];
        }

        p = 0;
        q = np;
        iout = offset - 1;
        int exitg1;
        do {
          exitg1 = 0;
          iout++;
          if (xwork[p] >= xwork[q]) {
            idx[iout] = iwork[p];
            x[iout] = xwork[p];
            if (p + 1 < np) {
              p++;
            } else {
              exitg1 = 1;
            }
          } else {
            idx[iout] = iwork[q];
            x[iout] = xwork[q];
            if (q + 1 < n_tmp) {
              q++;
            } else {
              q = iout - p;
              if ((p + 1 <= np) && (np > 2147483646)) {
                check_forloop_overflow_error();
              }

              for (int j{p + 1}; j <= np; j++) {
                iout = q + j;
                idx[iout] = iwork[j - 1];
                x[iout] = xwork[j - 1];
              }

              exitg1 = 1;
            }
          }
        } while (exitg1 == 0);
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<int, 1U> &x
    //                int offset
    //                int np
    //                int nq
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<int, 1U> &xwork
    // Return Type  : void
    //
    static void merge(::coder::array<int, 1U> &idx, ::coder::array<int, 1U> &x,
                      int offset, int np, int nq, ::coder::array<int, 1U> &iwork,
                      ::coder::array<int, 1U> &xwork)
    {
      if (nq != 0) {
        int iout;
        int n_tmp;
        int p;
        int q;
        n_tmp = np + nq;
        if (n_tmp > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int j{0}; j < n_tmp; j++) {
          iout = offset + j;
          iwork[j] = idx[iout];
          xwork[j] = x[iout];
        }

        p = 0;
        q = np;
        iout = offset - 1;
        int exitg1;
        do {
          exitg1 = 0;
          iout++;
          if (xwork[p] <= xwork[q]) {
            idx[iout] = iwork[p];
            x[iout] = xwork[p];
            if (p + 1 < np) {
              p++;
            } else {
              exitg1 = 1;
            }
          } else {
            idx[iout] = iwork[q];
            x[iout] = xwork[q];
            if (q + 1 < n_tmp) {
              q++;
            } else {
              q = iout - p;
              if ((p + 1 <= np) && (np > 2147483646)) {
                check_forloop_overflow_error();
              }

              for (int j{p + 1}; j <= np; j++) {
                iout = q + j;
                idx[iout] = iwork[j - 1];
                x[iout] = xwork[j - 1];
              }

              exitg1 = 1;
            }
          }
        } while (exitg1 == 0);
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<float, 1U> &x
    //                int offset
    //                int n
    //                int preSortLevel
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<float, 1U> &xwork
    // Return Type  : void
    //
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<float,
      1U> &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U>
      &iwork, ::coder::array<float, 1U> &xwork)
    {
      int bLen;
      int nPairs;
      nPairs = n >> preSortLevel;
      bLen = 1 << preSortLevel;
      while (nPairs > 1) {
        int nTail;
        int tailOffset;
        if ((nPairs & 1) != 0) {
          nPairs--;
          tailOffset = bLen * nPairs;
          nTail = n - tailOffset;
          if (nTail > bLen) {
            merge(idx, x, offset + tailOffset, bLen, nTail - bLen, iwork, xwork);
          }
        }

        tailOffset = bLen << 1;
        nPairs >>= 1;
        for (nTail = 0; nTail < nPairs; nTail++) {
          merge(idx, x, offset + nTail * tailOffset, bLen, bLen, iwork, xwork);
        }

        bLen = tailOffset;
      }

      if (n > bLen) {
        merge(idx, x, offset, bLen, n - bLen, iwork, xwork);
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<double, 1U> &x
    //                int offset
    //                int n
    //                int preSortLevel
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<double, 1U> &xwork
    // Return Type  : void
    //
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<double,
      1U> &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U>
      &iwork, ::coder::array<double, 1U> &xwork)
    {
      int bLen;
      int nPairs;
      nPairs = n >> preSortLevel;
      bLen = 1 << preSortLevel;
      while (nPairs > 1) {
        int nTail;
        int tailOffset;
        if ((nPairs & 1) != 0) {
          nPairs--;
          tailOffset = bLen * nPairs;
          nTail = n - tailOffset;
          if (nTail > bLen) {
            merge(idx, x, offset + tailOffset, bLen, nTail - bLen, iwork, xwork);
          }
        }

        tailOffset = bLen << 1;
        nPairs >>= 1;
        for (nTail = 0; nTail < nPairs; nTail++) {
          merge(idx, x, offset + nTail * tailOffset, bLen, bLen, iwork, xwork);
        }

        bLen = tailOffset;
      }

      if (n > bLen) {
        merge(idx, x, offset, bLen, n - bLen, iwork, xwork);
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &idx
    //                ::coder::array<int, 1U> &x
    //                int offset
    //                int n
    //                int preSortLevel
    //                ::coder::array<int, 1U> &iwork
    //                ::coder::array<int, 1U> &xwork
    // Return Type  : void
    //
    static void merge_block(::coder::array<int, 1U> &idx, ::coder::array<int, 1U>
      &x, int offset, int n, int preSortLevel, ::coder::array<int, 1U> &iwork, ::
      coder::array<int, 1U> &xwork)
    {
      int bLen;
      int nPairs;
      nPairs = n >> preSortLevel;
      bLen = 1 << preSortLevel;
      while (nPairs > 1) {
        int nTail;
        int tailOffset;
        if ((nPairs & 1) != 0) {
          nPairs--;
          tailOffset = bLen * nPairs;
          nTail = n - tailOffset;
          if (nTail > bLen) {
            merge(idx, x, offset + tailOffset, bLen, nTail - bLen, iwork, xwork);
          }
        }

        tailOffset = bLen << 1;
        nPairs >>= 1;
        for (nTail = 0; nTail < nPairs; nTail++) {
          merge(idx, x, offset + nTail * tailOffset, bLen, bLen, iwork, xwork);
        }

        bLen = tailOffset;
      }

      if (n > bLen) {
        merge(idx, x, offset, bLen, n - bLen, iwork, xwork);
      }
    }

    //
    // Arguments    : const ::coder::array<float, 1U> &x
    // Return Type  : float
    //
    static float minimum(const ::coder::array<float, 1U> &x)
    {
      float ex;
      int last;
      if (x.size(0) < 1) {
        d_rtErrorWithMessageID(c_emlrtRTEI.fName, c_emlrtRTEI.lineNo);
      }

      last = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
        } else if ((x[0] > x[1]) || (std::isnan(x[0]) && (!std::isnan(x[1])))) {
          ex = x[1];
        } else {
          ex = x[0];
        }
      } else {
        int idx;
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          if (x.size(0) > 2147483646) {
            check_forloop_overflow_error();
          }

          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
        } else {
          int a;
          ex = x[idx - 1];
          a = idx + 1;
          if ((idx + 1 <= x.size(0)) && (x.size(0) > 2147483646)) {
            check_forloop_overflow_error();
          }

          for (k = a; k <= last; k++) {
            float f;
            f = x[k - 1];
            if (ex > f) {
              ex = f;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : const ::coder::array<double, 1U> &x
    //                int &idx
    // Return Type  : double
    //
    static double minimum(const ::coder::array<double, 1U> &x, int &idx)
    {
      double ex;
      int last;
      if (x.size(0) < 1) {
        d_rtErrorWithMessageID(c_emlrtRTEI.fName, c_emlrtRTEI.lineNo);
      }

      last = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
          idx = 1;
        } else if ((x[0] > x[1]) || (std::isnan(x[0]) && (!std::isnan(x[1])))) {
          ex = x[1];
          idx = 2;
        } else {
          ex = x[0];
          idx = 1;
        }
      } else {
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          if (x.size(0) > 2147483646) {
            check_forloop_overflow_error();
          }

          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
          idx = 1;
        } else {
          int a;
          ex = x[idx - 1];
          a = idx + 1;
          if ((idx + 1 <= x.size(0)) && (x.size(0) > 2147483646)) {
            check_forloop_overflow_error();
          }

          for (k = a; k <= last; k++) {
            double d;
            d = x[k - 1];
            if (ex > d) {
              ex = d;
              idx = k;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : const ::coder::array<float, 1U> &x
    //                int &idx
    // Return Type  : float
    //
    static float minimum(const ::coder::array<float, 1U> &x, int &idx)
    {
      float ex;
      int last;
      if (x.size(0) < 1) {
        d_rtErrorWithMessageID(c_emlrtRTEI.fName, c_emlrtRTEI.lineNo);
      }

      last = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
          idx = 1;
        } else if ((x[0] > x[1]) || (std::isnan(x[0]) && (!std::isnan(x[1])))) {
          ex = x[1];
          idx = 2;
        } else {
          ex = x[0];
          idx = 1;
        }
      } else {
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          if (x.size(0) > 2147483646) {
            check_forloop_overflow_error();
          }

          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
          idx = 1;
        } else {
          int a;
          ex = x[idx - 1];
          a = idx + 1;
          if ((idx + 1 <= x.size(0)) && (x.size(0) > 2147483646)) {
            check_forloop_overflow_error();
          }

          for (k = a; k <= last; k++) {
            float f;
            f = x[k - 1];
            if (ex > f) {
              ex = f;
              idx = k;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : const ::coder::array<double, 2U> &A
    //                const ::coder::array<double, 1U> &B
    //                double Y_data[]
    //                int &rankA
    // Return Type  : int
    //
    static int qrsolve(const ::coder::array<double, 2U> &A, const ::coder::array<
                       double, 1U> &B, double Y_data[], int &rankA)
    {
      array<double, 2U> b_A;
      array<double, 1U> b_B;
      double tau_data[5];
      double smax;
      int Y_size;
      int assumedRank;
      int i;
      int ix;
      int knt;
      int m;
      int n;
      int pvt;
      int u1;
      signed char jpvt_data[5];
      b_A.set_size(A.size(0), A.size(1));
      ix = A.size(0) * A.size(1);
      for (i = 0; i < ix; i++) {
        b_A[i] = A[i];
      }

      m = A.size(0);
      n = A.size(1);
      knt = A.size(0);
      u1 = A.size(1);
      if (knt <= u1) {
        u1 = knt;
      }

      if (u1 - 1 >= 0) {
        std::memset(&tau_data[0], 0, static_cast<unsigned int>(u1) * sizeof
                    (double));
      }

      if ((A.size(0) == 0) || (u1 < 1)) {
        ix = A.size(1);
        for (pvt = 0; pvt < ix; pvt++) {
          jpvt_data[pvt] = static_cast<signed char>(pvt + 1);
        }
      } else {
        double vn1_data[5];
        double vn2_data[5];
        double work_data[5];
        int ma;
        ix = A.size(1);
        ma = A.size(0);
        for (int k{0}; k < ix; k++) {
          jpvt_data[k] = static_cast<signed char>(k + 1);
          work_data[k] = 0.0;
          vn1_data[k] = 0.0;
          vn2_data[k] = 0.0;
        }

        for (pvt = 0; pvt < n; pvt++) {
          smax = blas::xnrm2(m, A, pvt * ma + 1);
          vn1_data[pvt] = smax;
          vn2_data[pvt] = smax;
        }

        for (int b_i{0}; b_i < u1; b_i++) {
          double s;
          double temp2;
          int ii;
          int ip1;
          int mmi;
          int nmi;
          ip1 = b_i + 2;
          assumedRank = b_i * ma;
          ii = assumedRank + b_i;
          nmi = n - b_i;
          mmi = m - b_i;
          if (nmi < 1) {
            knt = -1;
          } else {
            knt = 0;
            if (nmi > 1) {
              smax = std::abs(vn1_data[b_i]);
              for (int k{2}; k <= nmi; k++) {
                s = std::abs(vn1_data[(b_i + k) - 1]);
                if (s > smax) {
                  knt = k - 1;
                  smax = s;
                }
              }
            }
          }

          pvt = b_i + knt;
          if (pvt != b_i) {
            ix = pvt * ma;
            if (m > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int k{0}; k < m; k++) {
              knt = ix + k;
              smax = b_A[knt];
              i = assumedRank + k;
              b_A[knt] = b_A[i];
              b_A[i] = smax;
            }

            ix = jpvt_data[pvt];
            jpvt_data[pvt] = jpvt_data[b_i];
            jpvt_data[b_i] = static_cast<signed char>(ix);
            vn1_data[pvt] = vn1_data[b_i];
            vn2_data[pvt] = vn2_data[b_i];
          }

          if (b_i + 1 < m) {
            temp2 = b_A[ii];
            assumedRank = ii + 2;
            tau_data[b_i] = 0.0;
            if (mmi > 0) {
              smax = blas::xnrm2(mmi - 1, b_A, ii + 2);
              if (smax != 0.0) {
                s = rt_hypotd_snf(b_A[ii], smax);
                if (b_A[ii] >= 0.0) {
                  s = -s;
                }

                if (std::abs(s) < 1.0020841800044864E-292) {
                  bool overflow_tmp;
                  knt = 0;
                  ix = ii + mmi;
                  overflow_tmp = ((ii + 2 <= ix) && (ix > 2147483646));
                  do {
                    knt++;
                    if (overflow_tmp) {
                      check_forloop_overflow_error();
                    }

                    for (int k{assumedRank}; k <= ix; k++) {
                      b_A[k - 1] = 9.9792015476736E+291 * b_A[k - 1];
                    }

                    s *= 9.9792015476736E+291;
                    temp2 *= 9.9792015476736E+291;
                  } while ((std::abs(s) < 1.0020841800044864E-292) && (knt < 20));

                  smax = blas::xnrm2(mmi - 1, b_A, ii + 2);
                  s = rt_hypotd_snf(temp2, smax);
                  if (temp2 >= 0.0) {
                    s = -s;
                  }

                  tau_data[b_i] = (s - temp2) / s;
                  smax = 1.0 / (temp2 - s);
                  for (int k{assumedRank}; k <= ix; k++) {
                    b_A[k - 1] = smax * b_A[k - 1];
                  }

                  for (int k{0}; k < knt; k++) {
                    s *= 1.0020841800044864E-292;
                  }

                  temp2 = s;
                } else {
                  tau_data[b_i] = (s - b_A[ii]) / s;
                  smax = 1.0 / (b_A[ii] - s);
                  knt = ii + mmi;
                  if ((ii + 2 <= knt) && (knt > 2147483646)) {
                    check_forloop_overflow_error();
                  }

                  for (int k{assumedRank}; k <= knt; k++) {
                    b_A[k - 1] = smax * b_A[k - 1];
                  }

                  temp2 = s;
                }
              }
            }

            b_A[ii] = temp2;
          } else {
            tau_data[b_i] = 0.0;
          }

          if (b_i + 1 < n) {
            temp2 = b_A[ii];
            b_A[ii] = 1.0;
            reflapack::xzlarf(mmi, nmi - 1, ii + 1, tau_data[b_i], b_A, (ii + ma)
                              + 1, ma, work_data);
            b_A[ii] = temp2;
          }

          for (pvt = ip1; pvt <= n; pvt++) {
            knt = b_i + (pvt - 1) * ma;
            smax = vn1_data[pvt - 1];
            if (smax != 0.0) {
              s = std::abs(b_A[knt]) / smax;
              s = 1.0 - s * s;
              if (s < 0.0) {
                s = 0.0;
              }

              temp2 = smax / vn2_data[pvt - 1];
              temp2 = s * (temp2 * temp2);
              if (temp2 <= 1.4901161193847656E-8) {
                if (b_i + 1 < m) {
                  smax = blas::xnrm2(mmi - 1, b_A, knt + 2);
                  vn1_data[pvt - 1] = smax;
                  vn2_data[pvt - 1] = smax;
                } else {
                  vn1_data[pvt - 1] = 0.0;
                  vn2_data[pvt - 1] = 0.0;
                }
              } else {
                vn1_data[pvt - 1] = smax * std::sqrt(s);
              }
            }
          }
        }
      }

      rankA = 0;
      if (b_A.size(0) < b_A.size(1)) {
        knt = b_A.size(0);
        ix = b_A.size(1);
      } else {
        knt = b_A.size(1);
        ix = b_A.size(0);
      }

      if (knt > 0) {
        smax = std::fmin(1.4901161193847656E-8, 2.2204460492503131E-15 *
                         static_cast<double>(ix)) * std::abs(b_A[0]);
        while ((rankA < knt) && (!(std::abs(b_A[rankA + b_A.size(0) * rankA]) <=
                 smax))) {
          rankA++;
        }
      }

      assumedRank = 0;
      knt = b_A.size(0);
      u1 = b_A.size(1);
      if (knt <= u1) {
        u1 = knt;
      }

      if (u1 > 0) {
        for (int k{0}; k < u1; k++) {
          if (b_A[k + b_A.size(0) * k] != 0.0) {
            assumedRank++;
          }
        }
      }

      b_B.set_size(B.size(0));
      ix = B.size(0);
      for (i = 0; i < ix; i++) {
        b_B[i] = B[i];
      }

      Y_size = b_A.size(1);
      ix = b_A.size(1);
      if (ix - 1 >= 0) {
        std::memset(&Y_data[0], 0, static_cast<unsigned int>(ix) * sizeof(double));
      }

      m = b_A.size(0);
      for (pvt = 0; pvt < u1; pvt++) {
        if (tau_data[pvt] != 0.0) {
          smax = b_B[pvt];
          knt = pvt + 2;
          if ((pvt + 2 <= m) && (m > 2147483646)) {
            check_forloop_overflow_error();
          }

          for (int b_i{knt}; b_i <= m; b_i++) {
            smax += b_A[(b_i + b_A.size(0) * pvt) - 1] * b_B[b_i - 1];
          }

          smax *= tau_data[pvt];
          if (smax != 0.0) {
            b_B[pvt] = b_B[pvt] - smax;
            for (int b_i{knt}; b_i <= m; b_i++) {
              b_B[b_i - 1] = b_B[b_i - 1] - b_A[(b_i + b_A.size(0) * pvt) - 1] *
                smax;
            }
          }
        }
      }

      for (int b_i{0}; b_i < assumedRank; b_i++) {
        Y_data[jpvt_data[b_i] - 1] = b_B[b_i];
      }

      for (pvt = assumedRank; pvt >= 1; pvt--) {
        knt = jpvt_data[pvt - 1] - 1;
        Y_data[jpvt_data[pvt - 1] - 1] = Y_data[knt] / b_A[(pvt + b_A.size(0) *
          (pvt - 1)) - 1];
        for (int b_i{0}; b_i <= pvt - 2; b_i++) {
          ix = jpvt_data[b_i] - 1;
          Y_data[ix] -= Y_data[knt] * b_A[b_i + b_A.size(0) * (pvt - 1)];
        }
      }

      return Y_size;
    }

    //
    // Arguments    : int m
    //                int n
    //                int iv0
    //                double tau
    //                ::coder::array<double, 2U> &C
    //                int ic0
    //                int ldc
    //                double work_data[]
    // Return Type  : void
    //
    namespace reflapack
    {
      static void xzlarf(int m, int n, int iv0, double tau, ::coder::array<
                         double, 2U> &C, int ic0, int ldc, double work_data[])
      {
        static rtRunTimeErrorInfo s_emlrtRTEI{ 18,// lineNo
          27,                          // colNo
          "eml_int_forloop_overflow_check",// fName
          "/usr/local/MATLAB/R2023a/toolbox/eml/lib/matlab/eml/eml_int_forloop_overflow_check.m"// pName
        };

        int colbottom;
        int i;
        int lastc;
        int lastv;
        if (tau != 0.0) {
          bool exitg2;
          lastv = m - 1;
          i = iv0 + m;
          while ((lastv + 1 > 0) && (C[i - 2] == 0.0)) {
            lastv--;
            i--;
          }

          lastc = n;
          exitg2 = false;
          while ((!exitg2) && (lastc > 0)) {
            int exitg1;
            i = ic0 + (lastc - 1) * ldc;
            colbottom = i + lastv;
            if ((i <= colbottom) && (colbottom > 2147483646)) {
              check_forloop_overflow_error();
            }

            do {
              exitg1 = 0;
              if (i <= colbottom) {
                if (C[i - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  i++;
                }
              } else {
                lastc--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }
        } else {
          lastv = -1;
          lastc = 0;
        }

        if (lastv + 1 > 0) {
          double c;
          int b;
          if (lastc != 0) {
            bool overflow;
            if (lastc > 2147483646) {
              check_forloop_overflow_error();
            }

            if (lastc - 1 >= 0) {
              std::memset(&work_data[0], 0, static_cast<unsigned int>(lastc) *
                          sizeof(double));
            }

            i = 0;
            b = ic0 + ldc * (lastc - 1);
            if ((ldc == 0) || (ic0 > b)) {
              overflow = false;
            } else {
              overflow = (b > MAX_int32_T - ldc);
            }

            if (ldc == 0) {
              y_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
            }

            if (overflow) {
              check_forloop_overflow_error();
            }

            for (int iac{ic0}; ldc < 0 ? iac >= b : iac <= b; iac += ldc) {
              c = 0.0;
              colbottom = iac + lastv;
              if ((iac <= colbottom) && (colbottom > 2147483646)) {
                check_forloop_overflow_error();
              }

              for (int ia{iac}; ia <= colbottom; ia++) {
                c += C[ia - 1] * C[((iv0 + ia) - iac) - 1];
              }

              work_data[i] += c;
              i++;
            }
          }

          if (!(-tau == 0.0)) {
            i = ic0;
            for (colbottom = 0; colbottom < lastc; colbottom++) {
              c = work_data[colbottom];
              if (c != 0.0) {
                c *= -tau;
                b = lastv + i;
                if ((i <= b) && (b > 2147483646)) {
                  check_forloop_overflow_error();
                }

                for (int iac{i}; iac <= b; iac++) {
                  C[iac - 1] = C[iac - 1] + C[((iv0 + iac) - i) - 1] * c;
                }
              }

              i += ldc;
            }
          }
        }
      }

      //
      // Arguments    : double x[4]
      // Return Type  : void
      //
    }

    static void sort(double x[4])
    {
      double x4[4];
      double xwork[4];
      int i2;
      int i3;
      int ib;
      int nNaNs;
      x4[0] = 0.0;
      xwork[0] = 0.0;
      x4[1] = 0.0;
      xwork[1] = 0.0;
      x4[2] = 0.0;
      xwork[2] = 0.0;
      x4[3] = 0.0;
      xwork[3] = 0.0;
      nNaNs = -3;
      ib = 0;
      if (std::isnan(x[0])) {
        xwork[3] = x[0];
        nNaNs = -2;
      } else {
        ib = 1;
        x4[0] = x[0];
      }

      if (std::isnan(x[1])) {
        xwork[-nNaNs] = x[1];
        nNaNs++;
      } else {
        ib++;
        x4[ib - 1] = x[1];
      }

      if (std::isnan(x[2])) {
        xwork[-nNaNs] = x[2];
        nNaNs++;
      } else {
        ib++;
        x4[ib - 1] = x[2];
      }

      if (std::isnan(x[3])) {
        xwork[-nNaNs] = x[3];
        nNaNs++;
      } else {
        ib++;
        x4[ib - 1] = x[3];
        if (ib == 4) {
          double d;
          double d1;
          int i4;
          signed char b_i2;
          signed char b_i3;
          signed char i;
          signed char i1;
          if (x4[0] <= x4[1]) {
            ib = 1;
            i2 = 2;
          } else {
            ib = 2;
            i2 = 1;
          }

          if (x4[2] <= x4[3]) {
            i3 = 3;
            i4 = 4;
          } else {
            i3 = 4;
            i4 = 3;
          }

          d = x4[i3 - 1];
          d1 = x4[ib - 1];
          if (d1 <= d) {
            d1 = x4[i2 - 1];
            if (d1 <= d) {
              i = static_cast<signed char>(ib);
              i1 = static_cast<signed char>(i2);
              b_i2 = static_cast<signed char>(i3);
              b_i3 = static_cast<signed char>(i4);
            } else if (d1 <= x4[i4 - 1]) {
              i = static_cast<signed char>(ib);
              i1 = static_cast<signed char>(i3);
              b_i2 = static_cast<signed char>(i2);
              b_i3 = static_cast<signed char>(i4);
            } else {
              i = static_cast<signed char>(ib);
              i1 = static_cast<signed char>(i3);
              b_i2 = static_cast<signed char>(i4);
              b_i3 = static_cast<signed char>(i2);
            }
          } else {
            d = x4[i4 - 1];
            if (d1 <= d) {
              if (x4[i2 - 1] <= d) {
                i = static_cast<signed char>(i3);
                i1 = static_cast<signed char>(ib);
                b_i2 = static_cast<signed char>(i2);
                b_i3 = static_cast<signed char>(i4);
              } else {
                i = static_cast<signed char>(i3);
                i1 = static_cast<signed char>(ib);
                b_i2 = static_cast<signed char>(i4);
                b_i3 = static_cast<signed char>(i2);
              }
            } else {
              i = static_cast<signed char>(i3);
              i1 = static_cast<signed char>(i4);
              b_i2 = static_cast<signed char>(ib);
              b_i3 = static_cast<signed char>(i2);
            }
          }

          x[-(nNaNs + 3)] = x4[i - 1];
          x[-(nNaNs + 2)] = x4[i1 - 1];
          x[-(nNaNs + 1)] = x4[b_i2 - 1];
          x[-nNaNs] = x4[b_i3 - 1];
          ib = 0;
        }
      }

      if (ib > 0) {
        signed char perm[4];
        perm[1] = 0;
        perm[2] = 0;
        perm[3] = 0;
        if (ib == 1) {
          perm[0] = 1;
        } else if (ib == 2) {
          if (x4[0] <= x4[1]) {
            perm[0] = 1;
            perm[1] = 2;
          } else {
            perm[0] = 2;
            perm[1] = 1;
          }
        } else if (x4[0] <= x4[1]) {
          if (x4[1] <= x4[2]) {
            perm[0] = 1;
            perm[1] = 2;
            perm[2] = 3;
          } else if (x4[0] <= x4[2]) {
            perm[0] = 1;
            perm[1] = 3;
            perm[2] = 2;
          } else {
            perm[0] = 3;
            perm[1] = 1;
            perm[2] = 2;
          }
        } else if (x4[0] <= x4[2]) {
          perm[0] = 2;
          perm[1] = 1;
          perm[2] = 3;
        } else if (x4[1] <= x4[2]) {
          perm[0] = 2;
          perm[1] = 3;
          perm[2] = 1;
        } else {
          perm[0] = 3;
          perm[1] = 2;
          perm[2] = 1;
        }

        for (i3 = 0; i3 < ib; i3++) {
          x[((i3 - nNaNs) - ib) + 1] = x4[perm[i3] - 1];
        }
      }

      ib = ((nNaNs + 3) >> 1) + 1;
      for (i3 = 0; i3 <= ib - 2; i3++) {
        i2 = (i3 - nNaNs) + 1;
        x[i2] = xwork[3 - i3];
        x[3 - i3] = xwork[i2];
      }

      if (((nNaNs + 3) & 1) != 0) {
        i2 = ib - nNaNs;
        x[i2] = xwork[i2];
      }
    }

    //
    // Arguments    : ::coder::array<int, 1U> &x
    //                ::coder::array<int, 1U> &idx
    // Return Type  : void
    //
    static void sort(::coder::array<int, 1U> &x, ::coder::array<int, 1U> &idx)
    {
      array<int, 1U> b_iwork;
      array<int, 1U> b_vwork;
      array<int, 1U> iidx;
      array<int, 1U> iwork;
      array<int, 1U> vwork;
      array<int, 1U> xwork;
      int dim;
      int i;
      int vlen;
      int vstride;
      dim = 0;
      if (x.size(0) != 1) {
        dim = -1;
      }

      if (dim + 2 <= 1) {
        i = x.size(0);
      } else {
        i = 1;
      }

      vlen = i - 1;
      vwork.set_size(i);
      idx.set_size(x.size(0));
      vstride = 1;
      for (int k{0}; k <= dim; k++) {
        vstride *= x.size(0);
      }

      if (vstride > 2147483646) {
        check_forloop_overflow_error();
      }

      for (int j{0}; j < vstride; j++) {
        int i1;
        if (i > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int k{0}; k <= vlen; k++) {
          vwork[k] = x[j + k * vstride];
        }

        dim = vwork.size(0);
        b_vwork.set_size(vwork.size(0));
        for (i1 = 0; i1 < dim; i1++) {
          b_vwork[i1] = vwork[i1];
        }

        iidx.set_size(vwork.size(0));
        dim = vwork.size(0);
        for (i1 = 0; i1 < dim; i1++) {
          iidx[i1] = 0;
        }

        if (vwork.size(0) != 0) {
          int idx4[4];
          int x4[4];
          int b_i;
          int b_i1;
          int i2;
          int i4;
          int nLeft;
          int nQuartets;
          x4[0] = 0;
          idx4[0] = 0;
          x4[1] = 0;
          idx4[1] = 0;
          x4[2] = 0;
          idx4[2] = 0;
          x4[3] = 0;
          idx4[3] = 0;
          iwork.set_size(vwork.size(0));
          dim = vwork.size(0);
          for (i1 = 0; i1 < dim; i1++) {
            iwork[i1] = 0;
          }

          xwork.set_size(vwork.size(0));
          dim = vwork.size(0);
          for (i1 = 0; i1 < dim; i1++) {
            xwork[i1] = 0;
          }

          nQuartets = vwork.size(0) >> 2;
          for (int b_j{0}; b_j < nQuartets; b_j++) {
            signed char b_i2;
            signed char b_i4;
            signed char i3;
            signed char i5;
            b_i = b_j << 2;
            idx4[0] = b_i + 1;
            idx4[1] = b_i + 2;
            idx4[2] = b_i + 3;
            idx4[3] = b_i + 4;
            x4[0] = b_vwork[b_i];
            dim = b_vwork[b_i + 1];
            x4[1] = dim;
            i4 = b_vwork[b_i + 2];
            x4[2] = i4;
            nLeft = b_vwork[b_i + 3];
            x4[3] = nLeft;
            if (b_vwork[b_i] <= dim) {
              b_i1 = 1;
              i2 = 2;
            } else {
              b_i1 = 2;
              i2 = 1;
            }

            if (i4 <= nLeft) {
              dim = 3;
              i4 = 4;
            } else {
              dim = 4;
              i4 = 3;
            }

            i1 = x4[dim - 1];
            nLeft = x4[b_i1 - 1];
            if (nLeft <= i1) {
              nLeft = x4[i2 - 1];
              if (nLeft <= i1) {
                b_i2 = static_cast<signed char>(b_i1);
                i3 = static_cast<signed char>(i2);
                b_i4 = static_cast<signed char>(dim);
                i5 = static_cast<signed char>(i4);
              } else if (nLeft <= x4[i4 - 1]) {
                b_i2 = static_cast<signed char>(b_i1);
                i3 = static_cast<signed char>(dim);
                b_i4 = static_cast<signed char>(i2);
                i5 = static_cast<signed char>(i4);
              } else {
                b_i2 = static_cast<signed char>(b_i1);
                i3 = static_cast<signed char>(dim);
                b_i4 = static_cast<signed char>(i4);
                i5 = static_cast<signed char>(i2);
              }
            } else {
              i1 = x4[i4 - 1];
              if (nLeft <= i1) {
                if (x4[i2 - 1] <= i1) {
                  b_i2 = static_cast<signed char>(dim);
                  i3 = static_cast<signed char>(b_i1);
                  b_i4 = static_cast<signed char>(i2);
                  i5 = static_cast<signed char>(i4);
                } else {
                  b_i2 = static_cast<signed char>(dim);
                  i3 = static_cast<signed char>(b_i1);
                  b_i4 = static_cast<signed char>(i4);
                  i5 = static_cast<signed char>(i2);
                }
              } else {
                b_i2 = static_cast<signed char>(dim);
                i3 = static_cast<signed char>(i4);
                b_i4 = static_cast<signed char>(b_i1);
                i5 = static_cast<signed char>(i2);
              }
            }

            iidx[b_i] = idx4[b_i2 - 1];
            iidx[b_i + 1] = idx4[i3 - 1];
            iidx[b_i + 2] = idx4[b_i4 - 1];
            iidx[b_i + 3] = idx4[i5 - 1];
            b_vwork[b_i] = x4[b_i2 - 1];
            b_vwork[b_i + 1] = x4[i3 - 1];
            b_vwork[b_i + 2] = x4[b_i4 - 1];
            b_vwork[b_i + 3] = x4[i5 - 1];
          }

          i4 = nQuartets << 2;
          nLeft = b_vwork.size(0) - i4;
          if (nLeft > 0) {
            signed char perm[4];
            if (nLeft > 2147483646) {
              check_forloop_overflow_error();
            }

            for (int k{0}; k < nLeft; k++) {
              dim = i4 + k;
              idx4[k] = dim + 1;
              x4[k] = b_vwork[dim];
            }

            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            if (nLeft == 1) {
              perm[0] = 1;
            } else if (nLeft == 2) {
              if (x4[0] <= x4[1]) {
                perm[0] = 1;
                perm[1] = 2;
              } else {
                perm[0] = 2;
                perm[1] = 1;
              }
            } else if (x4[0] <= x4[1]) {
              if (x4[1] <= x4[2]) {
                perm[0] = 1;
                perm[1] = 2;
                perm[2] = 3;
              } else if (x4[0] <= x4[2]) {
                perm[0] = 1;
                perm[1] = 3;
                perm[2] = 2;
              } else {
                perm[0] = 3;
                perm[1] = 1;
                perm[2] = 2;
              }
            } else if (x4[0] <= x4[2]) {
              perm[0] = 2;
              perm[1] = 1;
              perm[2] = 3;
            } else if (x4[1] <= x4[2]) {
              perm[0] = 2;
              perm[1] = 3;
              perm[2] = 1;
            } else {
              perm[0] = 3;
              perm[1] = 2;
              perm[2] = 1;
            }

            for (int k{0}; k < nLeft; k++) {
              b_i1 = perm[k] - 1;
              dim = i4 + k;
              iidx[dim] = idx4[b_i1];
              b_vwork[dim] = x4[b_i1];
            }
          }

          i4 = 2;
          if (b_vwork.size(0) > 1) {
            if (b_vwork.size(0) >= 256) {
              nQuartets = b_vwork.size(0) >> 8;
              for (int b{0}; b < nQuartets; b++) {
                int b_xwork[256];
                int c_iwork[256];
                b_i = (b << 8) - 1;
                for (int b_b{0}; b_b < 6; b_b++) {
                  int bLen;
                  int bLen2;
                  bLen = 1 << (b_b + 2);
                  bLen2 = bLen << 1;
                  i1 = 256 >> (b_b + 3);
                  for (int k{0}; k < i1; k++) {
                    i4 = (b_i + k * bLen2) + 1;
                    for (int b_j{0}; b_j < bLen2; b_j++) {
                      dim = i4 + b_j;
                      c_iwork[b_j] = iidx[dim];
                      b_xwork[b_j] = b_vwork[dim];
                    }

                    i2 = 0;
                    nLeft = bLen;
                    dim = i4 - 1;
                    int exitg1;
                    do {
                      exitg1 = 0;
                      dim++;
                      if (b_xwork[i2] <= b_xwork[nLeft]) {
                        iidx[dim] = c_iwork[i2];
                        b_vwork[dim] = b_xwork[i2];
                        if (i2 + 1 < bLen) {
                          i2++;
                        } else {
                          exitg1 = 1;
                        }
                      } else {
                        iidx[dim] = c_iwork[nLeft];
                        b_vwork[dim] = b_xwork[nLeft];
                        if (nLeft + 1 < bLen2) {
                          nLeft++;
                        } else {
                          dim -= i2;
                          for (int b_j{i2 + 1}; b_j <= bLen; b_j++) {
                            b_i1 = dim + b_j;
                            iidx[b_i1] = c_iwork[b_j - 1];
                            b_vwork[b_i1] = b_xwork[b_j - 1];
                          }

                          exitg1 = 1;
                        }
                      }
                    } while (exitg1 == 0);
                  }
                }
              }

              dim = nQuartets << 8;
              i4 = b_vwork.size(0) - dim;
              if (i4 > 0) {
                merge_block(iidx, b_vwork, dim, i4, 2, iwork, xwork);
              }

              i4 = 8;
            }

            dim = iwork.size(0);
            b_iwork.set_size(iwork.size(0));
            for (i1 = 0; i1 < dim; i1++) {
              b_iwork[i1] = iwork[i1];
            }

            dim = xwork.size(0);
            iwork.set_size(xwork.size(0));
            for (i1 = 0; i1 < dim; i1++) {
              iwork[i1] = xwork[i1];
            }

            merge_block(iidx, b_vwork, 0, vwork.size(0), i4, b_iwork, iwork);
          }
        }

        vwork.set_size(b_vwork.size(0));
        dim = b_vwork.size(0);
        for (i1 = 0; i1 < dim; i1++) {
          vwork[i1] = b_vwork[i1];
        }

        for (int k{0}; k <= vlen; k++) {
          i1 = j + k * vstride;
          x[i1] = b_vwork[k];
          idx[i1] = iidx[k];
        }
      }
    }

    //
    // Arguments    : ::coder::array<double, 1U> &x
    //                ::coder::array<int, 1U> &idx
    // Return Type  : void
    //
    static void sort(::coder::array<double, 1U> &x, ::coder::array<int, 1U> &idx)
    {
      array<double, 1U> b_xwork;
      array<double, 1U> vwork;
      array<double, 1U> xwork;
      array<int, 1U> b_iwork;
      array<int, 1U> iidx;
      array<int, 1U> iwork;
      int dim;
      int i;
      int vlen;
      int vstride;
      dim = 0;
      if (x.size(0) != 1) {
        dim = -1;
      }

      if (dim + 2 <= 1) {
        i = x.size(0);
      } else {
        i = 1;
      }

      vlen = i - 1;
      vwork.set_size(i);
      idx.set_size(x.size(0));
      vstride = 1;
      for (int k{0}; k <= dim; k++) {
        vstride *= x.size(0);
      }

      if (vstride > 2147483646) {
        check_forloop_overflow_error();
      }

      for (int j{0}; j < vstride; j++) {
        int i1;
        if (i > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int k{0}; k <= vlen; k++) {
          vwork[k] = x[j + k * vstride];
        }

        iidx.set_size(vwork.size(0));
        dim = vwork.size(0);
        for (i1 = 0; i1 < dim; i1++) {
          iidx[i1] = 0;
        }

        if (vwork.size(0) != 0) {
          double x4[4];
          int idx4[4];
          int bLen;
          int b_i1;
          int i2;
          int i3;
          int i4;
          int iidx_tmp;
          int n;
          int wOffset_tmp;
          n = vwork.size(0);
          x4[0] = 0.0;
          idx4[0] = 0;
          x4[1] = 0.0;
          idx4[1] = 0;
          x4[2] = 0.0;
          idx4[2] = 0;
          x4[3] = 0.0;
          idx4[3] = 0;
          iwork.set_size(vwork.size(0));
          dim = vwork.size(0);
          for (i1 = 0; i1 < dim; i1++) {
            iwork[i1] = 0;
          }

          xwork.set_size(vwork.size(0));
          dim = vwork.size(0);
          for (i1 = 0; i1 < dim; i1++) {
            xwork[i1] = 0.0;
          }

          bLen = 0;
          dim = 0;
          if (vwork.size(0) > 2147483646) {
            check_forloop_overflow_error();
          }

          for (int k{0}; k < n; k++) {
            if (std::isnan(vwork[k])) {
              iidx_tmp = (n - bLen) - 1;
              iidx[iidx_tmp] = k + 1;
              xwork[iidx_tmp] = vwork[k];
              bLen++;
            } else {
              dim++;
              idx4[dim - 1] = k + 1;
              x4[dim - 1] = vwork[k];
              if (dim == 4) {
                double d;
                double d1;
                signed char b_i2;
                signed char b_i3;
                signed char b_i4;
                signed char i5;
                dim = k - bLen;
                if (x4[0] <= x4[1]) {
                  b_i1 = 1;
                  i2 = 2;
                } else {
                  b_i1 = 2;
                  i2 = 1;
                }

                if (x4[2] <= x4[3]) {
                  i3 = 3;
                  i4 = 4;
                } else {
                  i3 = 4;
                  i4 = 3;
                }

                d = x4[i3 - 1];
                d1 = x4[b_i1 - 1];
                if (d1 <= d) {
                  d1 = x4[i2 - 1];
                  if (d1 <= d) {
                    b_i2 = static_cast<signed char>(b_i1);
                    b_i3 = static_cast<signed char>(i2);
                    b_i4 = static_cast<signed char>(i3);
                    i5 = static_cast<signed char>(i4);
                  } else if (d1 <= x4[i4 - 1]) {
                    b_i2 = static_cast<signed char>(b_i1);
                    b_i3 = static_cast<signed char>(i3);
                    b_i4 = static_cast<signed char>(i2);
                    i5 = static_cast<signed char>(i4);
                  } else {
                    b_i2 = static_cast<signed char>(b_i1);
                    b_i3 = static_cast<signed char>(i3);
                    b_i4 = static_cast<signed char>(i4);
                    i5 = static_cast<signed char>(i2);
                  }
                } else {
                  d = x4[i4 - 1];
                  if (d1 <= d) {
                    if (x4[i2 - 1] <= d) {
                      b_i2 = static_cast<signed char>(i3);
                      b_i3 = static_cast<signed char>(b_i1);
                      b_i4 = static_cast<signed char>(i2);
                      i5 = static_cast<signed char>(i4);
                    } else {
                      b_i2 = static_cast<signed char>(i3);
                      b_i3 = static_cast<signed char>(b_i1);
                      b_i4 = static_cast<signed char>(i4);
                      i5 = static_cast<signed char>(i2);
                    }
                  } else {
                    b_i2 = static_cast<signed char>(i3);
                    b_i3 = static_cast<signed char>(i4);
                    b_i4 = static_cast<signed char>(b_i1);
                    i5 = static_cast<signed char>(i2);
                  }
                }

                iidx[dim - 3] = idx4[b_i2 - 1];
                iidx[dim - 2] = idx4[b_i3 - 1];
                iidx[dim - 1] = idx4[b_i4 - 1];
                iidx[dim] = idx4[i5 - 1];
                vwork[dim - 3] = x4[b_i2 - 1];
                vwork[dim - 2] = x4[b_i3 - 1];
                vwork[dim - 1] = x4[b_i4 - 1];
                vwork[dim] = x4[i5 - 1];
                dim = 0;
              }
            }
          }

          wOffset_tmp = vwork.size(0) - bLen;
          if (dim > 0) {
            signed char perm[4];
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            if (dim == 1) {
              perm[0] = 1;
            } else if (dim == 2) {
              if (x4[0] <= x4[1]) {
                perm[0] = 1;
                perm[1] = 2;
              } else {
                perm[0] = 2;
                perm[1] = 1;
              }
            } else if (x4[0] <= x4[1]) {
              if (x4[1] <= x4[2]) {
                perm[0] = 1;
                perm[1] = 2;
                perm[2] = 3;
              } else if (x4[0] <= x4[2]) {
                perm[0] = 1;
                perm[1] = 3;
                perm[2] = 2;
              } else {
                perm[0] = 3;
                perm[1] = 1;
                perm[2] = 2;
              }
            } else if (x4[0] <= x4[2]) {
              perm[0] = 2;
              perm[1] = 1;
              perm[2] = 3;
            } else if (x4[1] <= x4[2]) {
              perm[0] = 2;
              perm[1] = 3;
              perm[2] = 1;
            } else {
              perm[0] = 3;
              perm[1] = 2;
              perm[2] = 1;
            }

            if (dim > 2147483646) {
              check_forloop_overflow_error();
            }

            i1 = static_cast<unsigned char>(dim);
            for (int k{0}; k < i1; k++) {
              iidx_tmp = perm[k] - 1;
              b_i1 = (wOffset_tmp - dim) + k;
              iidx[b_i1] = idx4[iidx_tmp];
              vwork[b_i1] = x4[iidx_tmp];
            }
          }

          dim = bLen >> 1;
          for (int k{0}; k < dim; k++) {
            b_i1 = wOffset_tmp + k;
            i2 = iidx[b_i1];
            iidx_tmp = (n - k) - 1;
            iidx[b_i1] = iidx[iidx_tmp];
            iidx[iidx_tmp] = i2;
            vwork[b_i1] = xwork[iidx_tmp];
            vwork[iidx_tmp] = xwork[b_i1];
          }

          if ((bLen & 1) != 0) {
            dim += wOffset_tmp;
            vwork[dim] = xwork[dim];
          }

          b_i1 = 2;
          if (wOffset_tmp > 1) {
            if (vwork.size(0) >= 256) {
              int nBlocks;
              nBlocks = wOffset_tmp >> 8;
              if (nBlocks > 0) {
                for (int b{0}; b < nBlocks; b++) {
                  double c_xwork[256];
                  int c_iwork[256];
                  i4 = (b << 8) - 1;
                  for (int b_b{0}; b_b < 6; b_b++) {
                    bLen = 1 << (b_b + 2);
                    n = bLen << 1;
                    i1 = 256 >> (b_b + 3);
                    for (int k{0}; k < i1; k++) {
                      i2 = (i4 + k * n) + 1;
                      for (b_i1 = 0; b_i1 < n; b_i1++) {
                        dim = i2 + b_i1;
                        c_iwork[b_i1] = iidx[dim];
                        c_xwork[b_i1] = vwork[dim];
                      }

                      i3 = 0;
                      b_i1 = bLen;
                      dim = i2 - 1;
                      int exitg1;
                      do {
                        exitg1 = 0;
                        dim++;
                        if (c_xwork[i3] <= c_xwork[b_i1]) {
                          iidx[dim] = c_iwork[i3];
                          vwork[dim] = c_xwork[i3];
                          if (i3 + 1 < bLen) {
                            i3++;
                          } else {
                            exitg1 = 1;
                          }
                        } else {
                          iidx[dim] = c_iwork[b_i1];
                          vwork[dim] = c_xwork[b_i1];
                          if (b_i1 + 1 < n) {
                            b_i1++;
                          } else {
                            dim -= i3;
                            for (b_i1 = i3 + 1; b_i1 <= bLen; b_i1++) {
                              iidx_tmp = dim + b_i1;
                              iidx[iidx_tmp] = c_iwork[b_i1 - 1];
                              vwork[iidx_tmp] = c_xwork[b_i1 - 1];
                            }

                            exitg1 = 1;
                          }
                        }
                      } while (exitg1 == 0);
                    }
                  }
                }

                dim = nBlocks << 8;
                b_i1 = wOffset_tmp - dim;
                if (b_i1 > 0) {
                  merge_block(iidx, vwork, dim, b_i1, 2, iwork, xwork);
                }

                b_i1 = 8;
              }
            }

            dim = iwork.size(0);
            b_iwork.set_size(iwork.size(0));
            for (i1 = 0; i1 < dim; i1++) {
              b_iwork[i1] = iwork[i1];
            }

            b_xwork.set_size(xwork.size(0));
            dim = xwork.size(0);
            for (i1 = 0; i1 < dim; i1++) {
              b_xwork[i1] = xwork[i1];
            }

            merge_block(iidx, vwork, 0, wOffset_tmp, b_i1, b_iwork, b_xwork);
          }
        }

        for (int k{0}; k <= vlen; k++) {
          i1 = j + k * vstride;
          x[i1] = vwork[k];
          idx[i1] = iidx[k];
        }
      }
    }

    //
    // Arguments    : ::coder::array<float, 1U> &x
    //                ::coder::array<int, 1U> &idx
    // Return Type  : void
    //
    static void sort(::coder::array<float, 1U> &x, ::coder::array<int, 1U> &idx)
    {
      array<float, 1U> vwork;
      array<int, 1U> iidx;
      int dim;
      int i;
      int vlen;
      int vstride;
      dim = 0;
      if (x.size(0) != 1) {
        dim = -1;
      }

      if (dim + 2 <= 1) {
        i = x.size(0);
      } else {
        i = 1;
      }

      vlen = i - 1;
      vwork.set_size(i);
      idx.set_size(x.size(0));
      vstride = 1;
      for (int k{0}; k <= dim; k++) {
        vstride *= x.size(0);
      }

      if (vstride > 2147483646) {
        check_forloop_overflow_error();
      }

      for (int j{0}; j < vstride; j++) {
        if (i > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int k{0}; k <= vlen; k++) {
          vwork[k] = x[j + k * vstride];
        }

        sortIdx(vwork, iidx);
        for (int k{0}; k <= vlen; k++) {
          dim = j + k * vstride;
          x[dim] = vwork[k];
          idx[dim] = iidx[k];
        }
      }
    }

    //
    // Arguments    : const ::coder::array<double, 2U> &x
    //                ::coder::array<int, 2U> &idx
    // Return Type  : void
    //
    static void sortIdx(const ::coder::array<double, 2U> &x, ::coder::array<int,
                        2U> &idx)
    {
      array<int, 1U> iwork;
      int b_i;
      int i;
      int n;
      int qEnd;
      n = x.size(1) + 1;
      idx.set_size(1, x.size(1));
      i = x.size(1);
      for (b_i = 0; b_i < i; b_i++) {
        idx[b_i] = 0;
      }

      if (x.size(1) != 0) {
        double d;
        int k;
        iwork.set_size(x.size(1));
        i = x.size(1) - 1;
        if (x.size(1) - 1 > 2147483645) {
          check_forloop_overflow_error();
        }

        for (k = 1; k <= i; k += 2) {
          d = x[k];
          if ((x[k - 1] <= d) || std::isnan(d)) {
            idx[k - 1] = k;
            idx[k] = k + 1;
          } else {
            idx[k - 1] = k + 1;
            idx[k] = k;
          }
        }

        if ((x.size(1) & 1) != 0) {
          idx[x.size(1) - 1] = x.size(1);
        }

        i = 2;
        while (i < n - 1) {
          int i2;
          int j;
          i2 = i << 1;
          j = 1;
          for (int pEnd{i + 1}; pEnd < n; pEnd = qEnd + i) {
            int kEnd;
            int p;
            int q;
            p = j;
            q = pEnd - 1;
            qEnd = j + i2;
            if (qEnd > n) {
              qEnd = n;
            }

            k = 0;
            kEnd = qEnd - j;
            while (k + 1 <= kEnd) {
              d = x[idx[q] - 1];
              b_i = idx[p - 1];
              if ((x[b_i - 1] <= d) || std::isnan(d)) {
                iwork[k] = b_i;
                p++;
                if (p == pEnd) {
                  while (q + 1 < qEnd) {
                    k++;
                    iwork[k] = idx[q];
                    q++;
                  }
                }
              } else {
                iwork[k] = idx[q];
                q++;
                if (q + 1 == qEnd) {
                  while (p < pEnd) {
                    k++;
                    iwork[k] = idx[p - 1];
                    p++;
                  }
                }
              }

              k++;
            }

            for (k = 0; k < kEnd; k++) {
              idx[(j + k) - 1] = iwork[k];
            }

            j = qEnd;
          }

          i = i2;
        }
      }
    }

    //
    // Arguments    : ::coder::array<float, 1U> &x
    //                ::coder::array<int, 1U> &idx
    // Return Type  : void
    //
    static void sortIdx(::coder::array<float, 1U> &x, ::coder::array<int, 1U>
                        &idx)
    {
      array<float, 1U> xwork;
      array<int, 1U> iwork;
      int i;
      int ib;
      unsigned int unnamed_idx_0;
      unnamed_idx_0 = static_cast<unsigned int>(x.size(0));
      idx.set_size(static_cast<int>(unnamed_idx_0));
      ib = static_cast<int>(unnamed_idx_0);
      for (i = 0; i < ib; i++) {
        idx[i] = 0;
      }

      if (x.size(0) != 0) {
        float x4[4];
        int idx4[4];
        int i2;
        int i3;
        int i4;
        int idx_tmp;
        int n;
        int nNaNs;
        int quartetOffset;
        int wOffset_tmp;
        n = x.size(0);
        x4[0] = 0.0F;
        idx4[0] = 0;
        x4[1] = 0.0F;
        idx4[1] = 0;
        x4[2] = 0.0F;
        idx4[2] = 0;
        x4[3] = 0.0F;
        idx4[3] = 0;
        iwork.set_size(static_cast<int>(unnamed_idx_0));
        for (i = 0; i < ib; i++) {
          iwork[i] = 0;
        }

        ib = x.size(0);
        xwork.set_size(ib);
        for (i = 0; i < ib; i++) {
          xwork[i] = 0.0F;
        }

        nNaNs = 0;
        ib = 0;
        if (x.size(0) > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int k{0}; k < n; k++) {
          if (std::isnan(x[k])) {
            idx_tmp = (n - nNaNs) - 1;
            idx[idx_tmp] = k + 1;
            xwork[idx_tmp] = x[k];
            nNaNs++;
          } else {
            ib++;
            idx4[ib - 1] = k + 1;
            x4[ib - 1] = x[k];
            if (ib == 4) {
              float f;
              float f1;
              signed char b_i2;
              signed char b_i3;
              signed char b_i4;
              signed char i1;
              quartetOffset = k - nNaNs;
              if (x4[0] >= x4[1]) {
                ib = 1;
                i2 = 2;
              } else {
                ib = 2;
                i2 = 1;
              }

              if (x4[2] >= x4[3]) {
                i3 = 3;
                i4 = 4;
              } else {
                i3 = 4;
                i4 = 3;
              }

              f = x4[i3 - 1];
              f1 = x4[ib - 1];
              if (f1 >= f) {
                f1 = x4[i2 - 1];
                if (f1 >= f) {
                  i1 = static_cast<signed char>(ib);
                  b_i2 = static_cast<signed char>(i2);
                  b_i3 = static_cast<signed char>(i3);
                  b_i4 = static_cast<signed char>(i4);
                } else if (f1 >= x4[i4 - 1]) {
                  i1 = static_cast<signed char>(ib);
                  b_i2 = static_cast<signed char>(i3);
                  b_i3 = static_cast<signed char>(i2);
                  b_i4 = static_cast<signed char>(i4);
                } else {
                  i1 = static_cast<signed char>(ib);
                  b_i2 = static_cast<signed char>(i3);
                  b_i3 = static_cast<signed char>(i4);
                  b_i4 = static_cast<signed char>(i2);
                }
              } else {
                f = x4[i4 - 1];
                if (f1 >= f) {
                  if (x4[i2 - 1] >= f) {
                    i1 = static_cast<signed char>(i3);
                    b_i2 = static_cast<signed char>(ib);
                    b_i3 = static_cast<signed char>(i2);
                    b_i4 = static_cast<signed char>(i4);
                  } else {
                    i1 = static_cast<signed char>(i3);
                    b_i2 = static_cast<signed char>(ib);
                    b_i3 = static_cast<signed char>(i4);
                    b_i4 = static_cast<signed char>(i2);
                  }
                } else {
                  i1 = static_cast<signed char>(i3);
                  b_i2 = static_cast<signed char>(i4);
                  b_i3 = static_cast<signed char>(ib);
                  b_i4 = static_cast<signed char>(i2);
                }
              }

              idx[quartetOffset - 3] = idx4[i1 - 1];
              idx[quartetOffset - 2] = idx4[b_i2 - 1];
              idx[quartetOffset - 1] = idx4[b_i3 - 1];
              idx[quartetOffset] = idx4[b_i4 - 1];
              x[quartetOffset - 3] = x4[i1 - 1];
              x[quartetOffset - 2] = x4[b_i2 - 1];
              x[quartetOffset - 1] = x4[b_i3 - 1];
              x[quartetOffset] = x4[b_i4 - 1];
              ib = 0;
            }
          }
        }

        wOffset_tmp = x.size(0) - nNaNs;
        if (ib > 0) {
          signed char perm[4];
          perm[1] = 0;
          perm[2] = 0;
          perm[3] = 0;
          if (ib == 1) {
            perm[0] = 1;
          } else if (ib == 2) {
            if (x4[0] >= x4[1]) {
              perm[0] = 1;
              perm[1] = 2;
            } else {
              perm[0] = 2;
              perm[1] = 1;
            }
          } else if (x4[0] >= x4[1]) {
            if (x4[1] >= x4[2]) {
              perm[0] = 1;
              perm[1] = 2;
              perm[2] = 3;
            } else if (x4[0] >= x4[2]) {
              perm[0] = 1;
              perm[1] = 3;
              perm[2] = 2;
            } else {
              perm[0] = 3;
              perm[1] = 1;
              perm[2] = 2;
            }
          } else if (x4[0] >= x4[2]) {
            perm[0] = 2;
            perm[1] = 1;
            perm[2] = 3;
          } else if (x4[1] >= x4[2]) {
            perm[0] = 2;
            perm[1] = 3;
            perm[2] = 1;
          } else {
            perm[0] = 3;
            perm[1] = 2;
            perm[2] = 1;
          }

          if (ib > 2147483646) {
            check_forloop_overflow_error();
          }

          i = static_cast<unsigned char>(ib);
          for (int k{0}; k < i; k++) {
            idx_tmp = perm[k] - 1;
            quartetOffset = (wOffset_tmp - ib) + k;
            idx[quartetOffset] = idx4[idx_tmp];
            x[quartetOffset] = x4[idx_tmp];
          }
        }

        ib = nNaNs >> 1;
        for (int k{0}; k < ib; k++) {
          quartetOffset = wOffset_tmp + k;
          i2 = idx[quartetOffset];
          idx_tmp = (n - k) - 1;
          idx[quartetOffset] = idx[idx_tmp];
          idx[idx_tmp] = i2;
          x[quartetOffset] = xwork[idx_tmp];
          x[idx_tmp] = xwork[quartetOffset];
        }

        if ((nNaNs & 1) != 0) {
          i = wOffset_tmp + ib;
          x[i] = xwork[i];
        }

        ib = 2;
        if (wOffset_tmp > 1) {
          if (x.size(0) >= 256) {
            int nBlocks;
            nBlocks = wOffset_tmp >> 8;
            if (nBlocks > 0) {
              for (int b{0}; b < nBlocks; b++) {
                float b_xwork[256];
                int b_iwork[256];
                i4 = (b << 8) - 1;
                for (int b_b{0}; b_b < 6; b_b++) {
                  int bLen2;
                  n = 1 << (b_b + 2);
                  bLen2 = n << 1;
                  i = 256 >> (b_b + 3);
                  for (int k{0}; k < i; k++) {
                    i2 = (i4 + k * bLen2) + 1;
                    for (quartetOffset = 0; quartetOffset < bLen2; quartetOffset
                         ++) {
                      ib = i2 + quartetOffset;
                      b_iwork[quartetOffset] = idx[ib];
                      b_xwork[quartetOffset] = x[ib];
                    }

                    i3 = 0;
                    quartetOffset = n;
                    ib = i2 - 1;
                    int exitg1;
                    do {
                      exitg1 = 0;
                      ib++;
                      if (b_xwork[i3] >= b_xwork[quartetOffset]) {
                        idx[ib] = b_iwork[i3];
                        x[ib] = b_xwork[i3];
                        if (i3 + 1 < n) {
                          i3++;
                        } else {
                          exitg1 = 1;
                        }
                      } else {
                        idx[ib] = b_iwork[quartetOffset];
                        x[ib] = b_xwork[quartetOffset];
                        if (quartetOffset + 1 < bLen2) {
                          quartetOffset++;
                        } else {
                          ib -= i3;
                          for (quartetOffset = i3 + 1; quartetOffset <= n;
                               quartetOffset++) {
                            idx_tmp = ib + quartetOffset;
                            idx[idx_tmp] = b_iwork[quartetOffset - 1];
                            x[idx_tmp] = b_xwork[quartetOffset - 1];
                          }

                          exitg1 = 1;
                        }
                      }
                    } while (exitg1 == 0);
                  }
                }
              }

              ib = nBlocks << 8;
              quartetOffset = wOffset_tmp - ib;
              if (quartetOffset > 0) {
                merge_block(idx, x, ib, quartetOffset, 2, iwork, xwork);
              }

              ib = 8;
            }
          }

          merge_block(idx, x, 0, wOffset_tmp, ib, iwork, xwork);
        }

        if ((nNaNs > 0) && (wOffset_tmp > 0)) {
          if (nNaNs > 2147483646) {
            check_forloop_overflow_error();
          }

          for (int k{0}; k < nNaNs; k++) {
            ib = wOffset_tmp + k;
            xwork[k] = x[ib];
            iwork[k] = idx[ib];
          }

          for (int k{wOffset_tmp}; k >= 1; k--) {
            i = (nNaNs + k) - 1;
            x[i] = x[k - 1];
            idx[i] = idx[k - 1];
          }

          for (int k{0}; k < nNaNs; k++) {
            x[k] = xwork[k];
            idx[k] = iwork[k];
          }
        }
      }
    }

    //
    // Arguments    : const int siz[2]
    //                const ::coder::array<float, 1U> &varargin_1
    //                const ::coder::array<float, 1U> &varargin_2
    //                ::coder::array<int, 1U> &idx
    // Return Type  : void
    //
    static void sub2ind(const int siz[2], const ::coder::array<float, 1U>
                        &varargin_1, const ::coder::array<float, 1U> &varargin_2,
                        ::coder::array<int, 1U> &idx)
    {
      static rtRunTimeErrorInfo s_emlrtRTEI{ 28,// lineNo
        19,                            // colNo
        "sub2ind",                     // fName
        "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/sub2ind.m"// pName
      };

      static rtRunTimeErrorInfo t_emlrtRTEI{ 18,// lineNo
        23,                            // colNo
        "sub2ind",                     // fName
        "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/sub2ind.m"// pName
      };

      unsigned int b_varargin_1[2];
      unsigned int b_varargin_2[2];
      int k;
      bool exitg1;
      bool p;
      if (!allinrange(varargin_1, siz[0])) {
        b_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
      }

      b_varargin_1[0] = static_cast<unsigned int>(varargin_1.size(0));
      b_varargin_1[1] = 1U;
      b_varargin_2[0] = static_cast<unsigned int>(varargin_2.size(0));
      b_varargin_2[1] = 1U;
      p = true;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k < 2)) {
        if (static_cast<int>(b_varargin_1[k]) != static_cast<int>(b_varargin_2[k]))
        {
          p = false;
          exitg1 = true;
        } else {
          k++;
        }
      }

      if (!p) {
        g_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
      }

      if (!allinrange(varargin_2, siz[1])) {
        b_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
      }

      idx.set_size(varargin_1.size(0));
      k = varargin_1.size(0);
      for (int i{0}; i < k; i++) {
        idx[i] = static_cast<int>(varargin_1[i]) + siz[0] * (static_cast<int>
          (varargin_2[i]) - 1);
      }
    }

    //
    // Arguments    : const ::coder::array<double, 2U> &a
    //                const ::coder::array<double, 2U> &s
    //                ::coder::array<bool, 2U> &tf
    // Return Type  : void
    //
  }

  static void isMember(const ::coder::array<double, 2U> &a, const ::coder::array<
                       double, 2U> &s, ::coder::array<bool, 2U> &tf)
  {
    array<double, 1U> ss;
    array<int, 1U> b_ss;
    int n;
    int na;
    int ns;
    int pmax;
    int pmin;
    bool exitg1;
    bool guard1{ false };

    na = a.size(1);
    ns = s.size(1);
    pmax = a.size(1);
    tf.set_size(1, a.size(1));
    for (pmin = 0; pmin < pmax; pmin++) {
      tf[pmin] = false;
    }

    guard1 = false;
    if (s.size(1) <= 4) {
      guard1 = true;
    } else {
      pmax = 31;
      pmin = 0;
      exitg1 = false;
      while ((!exitg1) && (pmax - pmin > 1)) {
        int p;
        int pow2p;
        p = (pmin + pmax) >> 1;
        pow2p = 1 << p;
        if (pow2p == ns) {
          pmax = p;
          exitg1 = true;
        } else if (pow2p > ns) {
          pmax = p;
        } else {
          pmin = p;
        }
      }

      if (a.size(1) <= pmax + 4) {
        guard1 = true;
      } else {
        bool y;
        y = true;
        pmax = 0;
        exitg1 = false;
        while ((!exitg1) && (pmax <= s.size(1) - 2)) {
          double v_idx_1;
          v_idx_1 = s[pmax + 1];
          if ((s[pmax] <= v_idx_1) || std::isnan(v_idx_1)) {
            pmax++;
          } else {
            y = false;
            exitg1 = true;
          }
        }

        if (!y) {
          ss.set_size(s.size(1));
          pmax = s.size(1);
          for (pmin = 0; pmin < pmax; pmin++) {
            ss[pmin] = s[pmin];
          }

          internal::sort(ss, b_ss);
          if (a.size(1) > 2147483646) {
            check_forloop_overflow_error();
          }

          pmax = a.size(1) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(n)

          for (int k = 0; k <= pmax; k++) {
            n = bsearchni(k + 1, a, ss);
            if (n > 0) {
              tf[k] = true;
            }
          }
        } else {
          if (a.size(1) > 2147483646) {
            check_forloop_overflow_error();
          }

          pmax = a.size(1) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(n)

          for (int k = 0; k <= pmax; k++) {
            n = bsearchni(k + 1, a, s);
            if (n > 0) {
              tf[k] = true;
            }
          }
        }
      }
    }

    if (guard1) {
      if (a.size(1) > 2147483646) {
        check_forloop_overflow_error();
      }

      for (pmin = 0; pmin < na; pmin++) {
        if (ns > 2147483646) {
          check_forloop_overflow_error();
        }

        pmax = 0;
        exitg1 = false;
        while ((!exitg1) && (pmax <= ns - 1)) {
          if (a[pmin] == s[pmax]) {
            tf[pmin] = true;
            exitg1 = true;
          } else {
            pmax++;
          }
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<bool, 2U> &varargin_1
  //                const ::coder::array<bool, 2U> &varargin_2
  // Return Type  : bool
  //
  static bool isequal(const ::coder::array<bool, 2U> &varargin_1, const ::coder::
                      array<bool, 2U> &varargin_2)
  {
    bool p;
    p = false;
    if ((varargin_1.size(0) == varargin_2.size(0)) && (varargin_1.size(1) ==
         varargin_2.size(1))) {
      p = true;
    }

    if (p && ((varargin_1.size(0) != 0) && (varargin_1.size(1) != 0)) &&
        ((varargin_2.size(0) != 0) && (varargin_2.size(1) != 0))) {
      int k;
      bool exitg1;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= varargin_2.size(0) * varargin_2.size(1) - 1)) {
        if (varargin_1[k] != varargin_2[k]) {
          p = false;
          exitg1 = true;
        } else {
          k++;
        }
      }
    }

    return p;
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &x
  // Return Type  : double
  //
  static double mean(const ::coder::array<double, 2U> &x)
  {
    double y;
    if (x.size(1) == 0) {
      y = 0.0;
    } else {
      int firstBlockLength;
      int lastBlockLength;
      int nblocks;
      if (x.size(1) <= 1024) {
        firstBlockLength = x.size(1);
        lastBlockLength = 0;
        nblocks = 1;
      } else {
        firstBlockLength = 1024;
        nblocks = static_cast<int>(static_cast<unsigned int>(x.size(1)) >> 10);
        lastBlockLength = x.size(1) - (nblocks << 10);
        if (lastBlockLength > 0) {
          nblocks++;
        } else {
          lastBlockLength = 1024;
        }
      }

      y = x[0];
      for (int k{2}; k <= firstBlockLength; k++) {
        y += x[k - 1];
      }

      for (int ib{2}; ib <= nblocks; ib++) {
        double bsum;
        int hi;
        firstBlockLength = (ib - 1) << 10;
        bsum = x[firstBlockLength];
        if (ib == nblocks) {
          hi = lastBlockLength;
        } else {
          hi = 1024;
        }

        for (int k{2}; k <= hi; k++) {
          bsum += x[(firstBlockLength + k) - 1];
        }

        y += bsum;
      }
    }

    y /= static_cast<double>(x.size(1));
    return y;
  }

  //
  // Arguments    : const ::coder::array<double, 1U> &x
  // Return Type  : double
  //
  static double mean(const ::coder::array<double, 1U> &x)
  {
    double y;
    if (x.size(0) == 0) {
      y = 0.0;
    } else {
      int firstBlockLength;
      int lastBlockLength;
      int nblocks;
      if (x.size(0) <= 1024) {
        firstBlockLength = x.size(0);
        lastBlockLength = 0;
        nblocks = 1;
      } else {
        firstBlockLength = 1024;
        nblocks = static_cast<int>(static_cast<unsigned int>(x.size(0)) >> 10);
        lastBlockLength = x.size(0) - (nblocks << 10);
        if (lastBlockLength > 0) {
          nblocks++;
        } else {
          lastBlockLength = 1024;
        }
      }

      y = x[0];
      for (int k{2}; k <= firstBlockLength; k++) {
        y += x[k - 1];
      }

      for (int ib{2}; ib <= nblocks; ib++) {
        double bsum;
        int hi;
        firstBlockLength = (ib - 1) << 10;
        bsum = x[firstBlockLength];
        if (ib == nblocks) {
          hi = lastBlockLength;
        } else {
          hi = 1024;
        }

        for (int k{2}; k <= hi; k++) {
          bsum += x[(firstBlockLength + k) - 1];
        }

        y += bsum;
      }
    }

    y /= static_cast<double>(x.size(0));
    return y;
  }

  //
  // Arguments    : const ::coder::array<float, 1U> &x
  // Return Type  : float
  //
  static float mean(const ::coder::array<float, 1U> &x)
  {
    float b_x;
    if (x.size(0) == 0) {
      b_x = 0.0F;
    } else {
      int firstBlockLength;
      int lastBlockLength;
      int nblocks;
      if (x.size(0) <= 1024) {
        firstBlockLength = x.size(0);
        lastBlockLength = 0;
        nblocks = 1;
      } else {
        firstBlockLength = 1024;
        nblocks = static_cast<int>(static_cast<unsigned int>(x.size(0)) >> 10);
        lastBlockLength = x.size(0) - (nblocks << 10);
        if (lastBlockLength > 0) {
          nblocks++;
        } else {
          lastBlockLength = 1024;
        }
      }

      b_x = x[0];
      for (int k{2}; k <= firstBlockLength; k++) {
        b_x += x[k - 1];
      }

      for (int ib{2}; ib <= nblocks; ib++) {
        float bsum;
        int hi;
        firstBlockLength = (ib - 1) << 10;
        bsum = x[firstBlockLength];
        if (ib == nblocks) {
          hi = lastBlockLength;
        } else {
          hi = 1024;
        }

        for (int k{2}; k <= hi; k++) {
          bsum += x[(firstBlockLength + k) - 1];
        }

        b_x += bsum;
      }
    }

    return b_x / static_cast<float>(x.size(0));
  }

  //
  // Arguments    : const ::coder::array<float, 2U> &a_tmp
  //                const double pad[2]
  //                ::coder::array<float, 2U> &a
  // Return Type  : void
  //
  static void padImage_outSize(const ::coder::array<float, 2U> &a_tmp, const
    double pad[2], ::coder::array<float, 2U> &a)
  {
    static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      724,                             // lineNo
      104,                             // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      724,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      724,                             // lineNo
      58,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      680,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      680,                             // lineNo
      21,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      687,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      687,                             // lineNo
      21,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      694,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      694,                             // lineNo
      21,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      701,                             // lineNo
      19,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      701,                             // lineNo
      21,                              // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
      -1,                              // iLast
      724,                             // lineNo
      102,                             // colNo
      "",                              // aName
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      0                                // checkKind
    };

    static rtDoubleCheckInfo g_emlrtDCI{ 533,// lineNo
      35,                              // colNo
      "ConstantPad",                   // fName
      "/usr/local/MATLAB/R2023a/toolbox/images/images/eml/padarray.m",// pName
      1                                // checkKind
    };

    static rtRunTimeErrorInfo s_emlrtRTEI{ 13,// lineNo
      37,                              // colNo
      "validateinteger",               // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/+valattr/validateinteger.m"// pName
    };

    static rtRunTimeErrorInfo t_emlrtRTEI{ 49,// lineNo
      19,                              // colNo
      "assertValidSizeArg",            // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/assertValidSizeArg.m"// pName
    };

    static rtRunTimeErrorInfo u_emlrtRTEI{ 64,// lineNo
      15,                              // colNo
      "assertValidSizeArg",            // fName
      "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/assertValidSizeArg.m"// pName
    };

    int k;
    bool exitg1;
    bool p;
    p = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 2)) {
      if (!std::isnan(pad[k])) {
        k++;
      } else {
        p = false;
        exitg1 = true;
      }
    }

    if (!p) {
      b_rtErrorWithMessageID("input number 2, PADSIZE,", emlrtRTEI.fName,
        emlrtRTEI.lineNo);
    }

    p = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 2)) {
      if ((!std::isinf(pad[k])) && (!std::isnan(pad[k])) && (std::floor(pad[k]) ==
           pad[k])) {
        k++;
      } else {
        p = false;
        exitg1 = true;
      }
    }

    if (!p) {
      c_rtErrorWithMessageID("input number 2, PADSIZE,", s_emlrtRTEI.fName,
        s_emlrtRTEI.lineNo);
    }

    if ((a_tmp.size(0) == 0) || (a_tmp.size(1) == 0)) {
      double varargin_1[2];
      double d;
      double sizeB_idx_0;
      double sizeB_idx_1;
      int exitg2;
      sizeB_idx_0 = static_cast<double>(a_tmp.size(0)) + 2.0 * pad[0];
      sizeB_idx_1 = static_cast<double>(a_tmp.size(1)) + 2.0 * pad[1];
      varargin_1[0] = sizeB_idx_0;
      varargin_1[1] = sizeB_idx_1;
      k = 0;
      do {
        exitg2 = 0;
        if (k < 2) {
          if ((varargin_1[k] != varargin_1[k]) || std::isinf(varargin_1[k])) {
            bb_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
          } else {
            k++;
          }
        } else {
          k = 0;
          exitg2 = 2;
        }
      } while (exitg2 == 0);

      if (exitg2 != 1) {
        exitg1 = false;
        while ((!exitg1) && (k < 2)) {
          if (varargin_1[k] > 2.147483647E+9) {
            bb_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
          } else {
            k++;
          }
        }
      }

      if (sizeB_idx_0 <= 0.0) {
        d = 0.0;
      } else {
        d = sizeB_idx_0;
      }

      if (sizeB_idx_1 <= 0.0) {
        d = 0.0;
      } else {
        d *= sizeB_idx_1;
      }

      if (!(d <= 2.147483647E+9)) {
        rtErrorWithMessageID(u_emlrtRTEI.fName, u_emlrtRTEI.lineNo);
      }

      a.set_size(static_cast<int>(sizeB_idx_0), static_cast<int>(sizeB_idx_1));
      k = static_cast<int>(sizeB_idx_0) * static_cast<int>(sizeB_idx_1);
      for (int i{0}; i < k; i++) {
        a[i] = 0.0F;
      }
    } else {
      double sizeB_idx_0;
      double sizeB_idx_1;
      int b;
      int i;
      int i1;
      int i2;
      int i3;
      sizeB_idx_0 = static_cast<double>(a_tmp.size(0)) + 2.0 * pad[0];
      if (sizeB_idx_0 != static_cast<int>(std::floor(sizeB_idx_0))) {
        rtIntegerError(sizeB_idx_0, g_emlrtDCI);
      }

      sizeB_idx_1 = static_cast<double>(a_tmp.size(1)) + 2.0 * pad[1];
      if (sizeB_idx_1 != static_cast<int>(std::floor(sizeB_idx_1))) {
        rtIntegerError(sizeB_idx_1, g_emlrtDCI);
      }

      a.set_size(static_cast<int>(sizeB_idx_0), static_cast<int>(sizeB_idx_1));
      i = static_cast<int>(pad[1]);
      for (int j{0}; j < i; j++) {
        i1 = a.size(0);
        for (int b_i{0}; b_i < i1; b_i++) {
          if (b_i + 1 > a.size(0)) {
            rtDynamicBoundsError(b_i + 1, 1, a.size(0), qf_emlrtBCI);
          }

          if ((static_cast<int>(static_cast<unsigned int>(j) + 1U) < 1) || (
               static_cast<int>(static_cast<unsigned int>(j) + 1U) > a.size(1)))
          {
            rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(j) +
              1U), 1, a.size(1), rf_emlrtBCI);
          }

          a[b_i + a.size(0) * j] = 0.0F;
        }
      }

      k = (a_tmp.size(1) + static_cast<int>(pad[1])) + 1;
      b = a.size(1);
      if ((k <= a.size(1)) && (a.size(1) > 2147483646)) {
        check_forloop_overflow_error();
      }

      for (int j{k}; j <= b; j++) {
        i1 = a.size(0);
        for (int b_i{0}; b_i < i1; b_i++) {
          if (b_i + 1 > a.size(0)) {
            rtDynamicBoundsError(b_i + 1, 1, a.size(0), sf_emlrtBCI);
          }

          if ((j < 1) || (j > a.size(1))) {
            rtDynamicBoundsError(j, 1, a.size(1), tf_emlrtBCI);
          }

          a[b_i + a.size(0) * (j - 1)] = 0.0F;
        }
      }

      i1 = a_tmp.size(1);
      i2 = static_cast<int>(pad[0]);
      for (int j{0}; j < i1; j++) {
        for (int b_i{0}; b_i < i2; b_i++) {
          if ((static_cast<int>(static_cast<unsigned int>(b_i) + 1U) < 1) || (
               static_cast<int>(static_cast<unsigned int>(b_i) + 1U) > a.size(0)))
          {
            rtDynamicBoundsError(static_cast<int>(static_cast<unsigned int>(b_i)
              + 1U), 1, a.size(0), uf_emlrtBCI);
          }

          i3 = (j + i) + 1;
          if ((i3 < 1) || (i3 > a.size(1))) {
            rtDynamicBoundsError(i3, 1, a.size(1), vf_emlrtBCI);
          }

          a[b_i + a.size(0) * (i3 - 1)] = 0.0F;
        }
      }

      i1 = a_tmp.size(1);
      k = (static_cast<int>(pad[0]) + a_tmp.size(0)) + 1;
      for (int j{0}; j < i1; j++) {
        b = a.size(0);
        if ((k <= a.size(0)) && (a.size(0) > 2147483646)) {
          check_forloop_overflow_error();
        }

        for (int b_i{k}; b_i <= b; b_i++) {
          if ((b_i < 1) || (b_i > a.size(0))) {
            rtDynamicBoundsError(b_i, 1, a.size(0), wf_emlrtBCI);
          }

          i3 = (j + i) + 1;
          if ((i3 < 1) || (i3 > a.size(1))) {
            rtDynamicBoundsError(i3, 1, a.size(1), xf_emlrtBCI);
          }

          a[(b_i + a.size(0) * (i3 - 1)) - 1] = 0.0F;
        }
      }

      i1 = a_tmp.size(1);
      i3 = a_tmp.size(0);
      for (int j{0}; j < i1; j++) {
        k = (j + i) + 1;
        for (int b_i{0}; b_i < i3; b_i++) {
          if (b_i + 1 > a_tmp.size(0)) {
            rtDynamicBoundsError(b_i + 1, 1, a_tmp.size(0), yf_emlrtBCI);
          }

          if (j + 1 > a_tmp.size(1)) {
            rtDynamicBoundsError(j + 1, 1, a_tmp.size(1), ag_emlrtBCI);
          }

          b = (b_i + i2) + 1;
          if ((b < 1) || (b > a.size(0))) {
            rtDynamicBoundsError(b, 1, a.size(0), bg_emlrtBCI);
          }

          if ((k < 1) || (k > a.size(1))) {
            rtDynamicBoundsError(k, 1, a.size(1), cg_emlrtBCI);
          }

          a[(b + a.size(0) * (k - 1)) - 1] = a_tmp[b_i + a_tmp.size(0) * j];
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<double, 1U> &x
  //                const ::coder::array<double, 1U> &y
  //                double n
  //                double p_data[]
  //                int p_size[2]
  // Return Type  : void
  //
  static void polyfit(const ::coder::array<double, 1U> &x, const ::coder::array<
                      double, 1U> &y, double n, double p_data[], int p_size[2])
  {
    array<double, 2U> V;
    double p1_data[5];
    int p1_size;
    int rr;
    if (x.size(0) != y.size(0)) {
      m_rtErrorWithMessageID(l_emlrtRTEI.fName, l_emlrtRTEI.lineNo);
    }

    V.set_size(x.size(0), static_cast<int>(n + 1.0));
    if (x.size(0) != 0) {
      p1_size = x.size(0);
      for (int k{0}; k < p1_size; k++) {
        V[k + V.size(0) * (static_cast<int>(n + 1.0) - 1)] = 1.0;
      }

      p1_size = x.size(0);
      for (int k{0}; k < p1_size; k++) {
        V[k + V.size(0) * (static_cast<int>(n) - 1)] = x[k];
      }

      p1_size = static_cast<int>(-((-1.0 - (n - 1.0)) + 1.0));
      rr = x.size(0);
      for (int j{0}; j < p1_size; j++) {
        double b_j;
        b_j = (n - 1.0) - static_cast<double>(j);
        for (int k{0}; k < rr; k++) {
          V[k + V.size(0) * (static_cast<int>(b_j) - 1)] = x[k] * V[k + V.size(0)
            * (static_cast<int>(b_j + 1.0) - 1)];
        }
      }
    }

    p1_size = internal::qrsolve(V, y, p1_data, rr);
    p_size[0] = 1;
    p_size[1] = p1_size;
    if (p1_size - 1 >= 0) {
      std::copy(&p1_data[0], &p1_data[p1_size], &p_data[0]);
    }
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &x
  //                const ::coder::array<double, 2U> &y
  //                double n
  //                double p_data[]
  //                int p_size[2]
  // Return Type  : void
  //
  static void polyfit(const ::coder::array<double, 2U> &x, const ::coder::array<
                      double, 2U> &y, double n, double p_data[], int p_size[2])
  {
    array<double, 2U> V;
    array<double, 1U> c_y;
    double p1_data[5];
    int b_y;
    int rr;
    if (x.size(1) != y.size(1)) {
      m_rtErrorWithMessageID(l_emlrtRTEI.fName, l_emlrtRTEI.lineNo);
    }

    V.set_size(x.size(1), static_cast<int>(n + 1.0));
    if (x.size(1) != 0) {
      b_y = x.size(1);
      for (int k{0}; k < b_y; k++) {
        V[k + V.size(0) * (static_cast<int>(n + 1.0) - 1)] = 1.0;
      }

      b_y = x.size(1);
      for (int k{0}; k < b_y; k++) {
        V[k + V.size(0) * (static_cast<int>(n) - 1)] = x[k];
      }

      b_y = static_cast<int>(-((-1.0 - (n - 1.0)) + 1.0));
      rr = x.size(1);
      for (int j{0}; j < b_y; j++) {
        double b_j;
        b_j = (n - 1.0) - static_cast<double>(j);
        for (int k{0}; k < rr; k++) {
          V[k + V.size(0) * (static_cast<int>(b_j) - 1)] = x[k] * V[k + V.size(0)
            * (static_cast<int>(b_j + 1.0) - 1)];
        }
      }
    }

    b_y = y.size(1);
    c_y = y.reshape(b_y);
    b_y = internal::qrsolve(V, c_y, p1_data, rr);
    p_size[0] = 1;
    p_size[1] = b_y;
    if (b_y - 1 >= 0) {
      std::copy(&p1_data[0], &p1_data[b_y], &p_data[0]);
    }
  }

  //
  // Arguments    : const ::coder::array<double, 2U> &A
  //                ::coder::array<double, 2U> &B
  // Return Type  : void
  //
  static void rot90(const ::coder::array<double, 2U> &A, ::coder::array<double,
                    2U> &B)
  {
    int b_j;
    int m;
    int n;
    m = A.size(0);
    n = A.size(1);
    B.set_size(A.size(1), A.size(0));
    if (A.size(0) * A.size(1) >= 8192) {
      int i;
      if (A.size(1) > 2147483646) {
        check_forloop_overflow_error();
      }

      i = A.size(1) - 1;

#pragma omp parallel for \
 num_threads(omp_get_max_threads()) \
 private(b_j)

      for (int b_i = 0; b_i <= i; b_i++) {
        if (m > 2147483646) {
          check_forloop_overflow_error();
        }

        for (b_j = 0; b_j < m; b_j++) {
          B[b_i + B.size(0) * b_j] = A[b_j + A.size(0) * ((n - b_i) - 1)];
        }
      }
    } else {
      if (A.size(1) > 2147483646) {
        check_forloop_overflow_error();
      }

      for (int i{0}; i < n; i++) {
        if (m > 2147483646) {
          check_forloop_overflow_error();
        }

        for (int j{0}; j < m; j++) {
          B[i + B.size(0) * j] = A[j + A.size(0) * ((n - i) - 1)];
        }
      }
    }
  }

  //
  // Arguments    : const ::coder::array<double, 3U> &a
  //                ::coder::array<double, 2U> &b
  // Return Type  : void
  //
  static void squeeze(const ::coder::array<double, 3U> &a, ::coder::array<double,
                      2U> &b)
  {
    int szb[2];
    int j;
    int nx;
    szb[0] = 1;
    szb[1] = a.size(1);
    if (a.size(2) != 1) {
      j = 0;
      if (a.size(1) != 1) {
        j = 1;
        szb[0] = a.size(1);
      }

      if (a.size(2) != 1) {
        szb[j] = a.size(2);
      }
    }

    nx = a.size(1) * a.size(2);
    j = 1;
    if (a.size(1) > 1) {
      j = a.size(1);
    }

    if (a.size(2) > j) {
      j = a.size(2);
    }

    if (nx >= j) {
      j = nx;
    }

    if (szb[0] > j) {
      q_rtErrorWithMessageID(p_emlrtRTEI.fName, p_emlrtRTEI.lineNo);
    }

    if (szb[1] > j) {
      q_rtErrorWithMessageID(p_emlrtRTEI.fName, p_emlrtRTEI.lineNo);
    }

    j = szb[0] * szb[1];
    if (j != nx) {
      r_rtErrorWithMessageID(q_emlrtRTEI.fName, q_emlrtRTEI.lineNo);
    }

    b.set_size(szb[0], szb[1]);
    for (nx = 0; nx < j; nx++) {
      b[nx] = a[nx];
    }
  }

  //
  // Arguments    : const ::coder::array<float, 2U> &b_I
  //                ::coder::array<float, 2U> &cxy
  //                ::coder::array<float, 2U> &c45
  //                ::coder::array<float, 2U> &Ix
  //                ::coder::array<float, 2U> &Iy
  //                ::coder::array<float, 2U> &Ixy
  //                ::coder::array<float, 2U> &I_45_45
  // Return Type  : void
  //
  namespace vision
  {
    namespace internal
    {
      namespace calibration
      {
        namespace checkerboard
        {
          static void b_secondDerivCornerMetric(const ::coder::array<float, 2U>
            &b_I, ::coder::array<float, 2U> &cxy, ::coder::array<float, 2U> &c45,
            ::coder::array<float, 2U> &Ix, ::coder::array<float, 2U> &Iy, ::
            coder::array<float, 2U> &Ixy, ::coder::array<float, 2U> &I_45_45)
          {
            static const double dv[29]{ 0.00021823147295907269,
              0.00050740337669472686, 0.0011082708667872049,
              0.0022740241675853852, 0.0043832963079210854,
              0.0079371242384296756, 0.013501503141458728, 0.021575340587545226,
              0.0323884223174645, 0.04567499638225736, 0.06050953906221062,
              0.0753053380745791, 0.088040859838021152, 0.09669396810002269,
              0.099763364132126942, 0.09669396810002269, 0.088040859838021152,
              0.0753053380745791, 0.06050953906221062, 0.04567499638225736,
              0.0323884223174645, 0.021575340587545226, 0.013501503141458728,
              0.0079371242384296756, 0.0043832963079210854,
              0.0022740241675853852, 0.0011082708667872049,
              0.00050740337669472686, 0.00021823147295905031 };

            static const double dv1[29]{ 0.00021823147295907278,
              0.00050740337669472676, 0.0011082708667872047,
              0.0022740241675853856, 0.0043832963079210854,
              0.0079371242384296773, 0.013501503141458728, 0.02157534058754523,
              0.032388422317464506, 0.045674996382257374, 0.060509539062210613,
              0.075305338074579134, 0.088040859838021152, 0.096693968100022676,
              0.099763364132126955, 0.096693968100022676, 0.088040859838021152,
              0.075305338074579134, 0.060509539062210613, 0.045674996382257374,
              0.032388422317464506, 0.02157534058754523, 0.013501503141458728,
              0.0079371242384296773, 0.0043832963079210854,
              0.0022740241675853856, 0.0011082708667872047,
              0.00050740337669473586, 0.00021823147295907272 };

            array<double, 2U> b;
            array<double, 2U> b_a;
            array<double, 2U> b_b;
            array<float, 2U> I_45;
            array<float, 2U> I_n45;
            array<float, 2U> a;
            array<float, 2U> r;
            double finalSize[2];
            double pad[2];
            int b_loop_ub_tmp;
            int c_loop_ub_tmp;
            int d_loop_ub_tmp;
            int loop_ub_tmp;
            int nx;
            finalSize[0] = b_I.size(0);
            pad[0] = 14.0;
            finalSize[1] = b_I.size(1);
            pad[1] = 14.0;
            if ((b_I.size(0) == 0) || (b_I.size(1) == 0)) {
              Ix.set_size(b_I.size(0), b_I.size(1));
              nx = b_I.size(0) * b_I.size(1);
              for (int i{0}; i < nx; i++) {
                Ix[i] = b_I[i];
              }
            } else {
              padImage_outSize(b_I, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              b_conv2_separable_valid(dv, dv1, b_a, finalSize, b);
              Ix.set_size(b.size(0), b.size(1));
              nx = b.size(0) * b.size(1);
              for (int i{0}; i < nx; i++) {
                Ix[i] = static_cast<float>(b[i]);
              }
            }

            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((Ix.size(0) == 0) || (Ix.size(1) == 0)) {
              Iy.set_size(Ix.size(0), Ix.size(1));
              nx = Ix.size(0) * Ix.size(1);
              for (int i{0}; i < nx; i++) {
                Iy[i] = Ix[i];
              }
            } else {
              padImage_outSize(Ix, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              Iy.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                Iy[i] = static_cast<float>(b_b[i]);
              }
            }

            imfilter(Ix);
            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((Ix.size(0) == 0) || (Ix.size(1) == 0)) {
              Ixy.set_size(Ix.size(0), Ix.size(1));
              nx = Ix.size(0) * Ix.size(1);
              for (int i{0}; i < nx; i++) {
                Ixy[i] = Ix[i];
              }
            } else {
              padImage_outSize(Ix, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              Ixy.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                Ixy[i] = static_cast<float>(b_b[i]);
              }
            }

            I_n45.set_size(Ix.size(0), Ix.size(1));
            loop_ub_tmp = Ix.size(0) * Ix.size(1);
            for (int i{0}; i < loop_ub_tmp; i++) {
              I_n45[i] = Ix[i] * 0.707106769F;
            }

            I_45.set_size(Iy.size(0), Iy.size(1));
            b_loop_ub_tmp = Iy.size(0) * Iy.size(1);
            for (int i{0}; i < b_loop_ub_tmp; i++) {
              I_45[i] = Iy[i] * 0.707106769F;
            }

            if ((I_n45.size(0) != I_45.size(0)) && ((I_n45.size(0) != 1) &&
                 (I_45.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(0), I_45.size(0), emlrtECI);
            }

            if ((I_n45.size(1) != I_45.size(1)) && ((I_n45.size(1) != 1) &&
                 (I_45.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(1), I_45.size(1),
                b_emlrtECI);
            }

            if ((I_n45.size(0) == I_45.size(0)) && (I_n45.size(1) == I_45.size(1)))
            {
              I_45.set_size(I_n45.size(0), I_n45.size(1));
              for (int i{0}; i < loop_ub_tmp; i++) {
                I_45[i] = I_n45[i] + I_45[i];
              }
            } else {
              b_plus(I_45, I_n45);
            }

            r.set_size(Iy.size(0), Iy.size(1));
            for (int i{0}; i < b_loop_ub_tmp; i++) {
              r[i] = Iy[i] * -0.707106769F;
            }

            if ((I_n45.size(0) != r.size(0)) && ((I_n45.size(0) != 1) && (r.size
                  (0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(0), r.size(0), c_emlrtECI);
            }

            if ((I_n45.size(1) != r.size(1)) && ((I_n45.size(1) != 1) && (r.size
                  (1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(1), r.size(1), d_emlrtECI);
            }

            if ((I_n45.size(0) == r.size(0)) && (I_n45.size(1) == r.size(1))) {
              nx = I_n45.size(0) * I_n45.size(1);
              for (int i{0}; i < nx; i++) {
                I_n45[i] = I_n45[i] + r[i];
              }
            } else {
              plus(I_n45, r);
            }

            I_45_45.set_size(I_45.size(0), I_45.size(1));
            c_loop_ub_tmp = I_45.size(0) * I_45.size(1);
            for (int i{0}; i < c_loop_ub_tmp; i++) {
              I_45_45[i] = I_45[i];
            }

            imfilter(I_45_45);
            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((I_45.size(0) == 0) || (I_45.size(1) == 0)) {
              a.set_size(I_45.size(0), I_45.size(1));
              for (int i{0}; i < c_loop_ub_tmp; i++) {
                a[i] = I_45[i];
              }
            } else {
              padImage_outSize(I_45, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              a.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                a[i] = static_cast<float>(b_b[i]);
              }
            }

            nx = I_45_45.size(0) * I_45_45.size(1);
            for (int i{0}; i < nx; i++) {
              I_45_45[i] = I_45_45[i] * 0.707106769F;
            }

            d_loop_ub_tmp = a.size(0) * a.size(1);
            for (int i{0}; i < d_loop_ub_tmp; i++) {
              a[i] = a[i] * -0.707106769F;
            }

            if ((I_45_45.size(0) != a.size(0)) && ((I_45_45.size(0) != 1) &&
                 (a.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_45_45.size(0), a.size(0), e_emlrtECI);
            }

            if ((I_45_45.size(1) != a.size(1)) && ((I_45_45.size(1) != 1) &&
                 (a.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_45_45.size(1), a.size(1), f_emlrtECI);
            }

            if ((I_45_45.size(0) == a.size(0)) && (I_45_45.size(1) == a.size(1)))
            {
              for (int i{0}; i < nx; i++) {
                I_45_45[i] = I_45_45[i] + a[i];
              }
            } else {
              plus(I_45_45, a);
            }

            r.set_size(I_45.size(0), I_45.size(1));
            if (c_loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < c_loop_ub_tmp; d_loop_ub_tmp
                 ++) {
              r[d_loop_ub_tmp] = std::abs(I_45[d_loop_ub_tmp]);
            }

            nx = I_n45.size(0) * I_n45.size(1);
            a.set_size(I_n45.size(0), I_n45.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              a[d_loop_ub_tmp] = std::abs(I_n45[d_loop_ub_tmp]);
            }

            if ((r.size(0) != a.size(0)) && ((r.size(0) != 1) && (a.size(0) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(0), a.size(0), g_emlrtECI);
            }

            if ((r.size(1) != a.size(1)) && ((r.size(1) != 1) && (a.size(1) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(1), a.size(1), h_emlrtECI);
            }

            nx = Ixy.size(0) * Ixy.size(1);
            cxy.set_size(Ixy.size(0), Ixy.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              cxy[d_loop_ub_tmp] = std::abs(Ixy[d_loop_ub_tmp]);
            }

            c_loop_ub_tmp = cxy.size(0) * cxy.size(1);
            for (int i{0}; i < c_loop_ub_tmp; i++) {
              cxy[i] = 16.0F * cxy[i];
            }

            if ((r.size(0) == a.size(0)) && (r.size(1) == a.size(1))) {
              nx = r.size(0) * r.size(1);
              for (int i{0}; i < nx; i++) {
                r[i] = 6.0F * (r[i] + a[i]);
              }
            } else {
              b_binary_expand_op(r, a);
            }

            if ((cxy.size(0) != r.size(0)) && ((cxy.size(0) != 1) && (r.size(0)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(cxy.size(0), r.size(0), i_emlrtECI);
            }

            if ((cxy.size(1) != r.size(1)) && ((cxy.size(1) != 1) && (r.size(1)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(cxy.size(1), r.size(1), j_emlrtECI);
            }

            if ((cxy.size(0) == r.size(0)) && (cxy.size(1) == r.size(1))) {
              for (int i{0}; i < c_loop_ub_tmp; i++) {
                cxy[i] = cxy[i] - r[i];
              }
            } else {
              minus(cxy, r);
            }

            nx = cxy.size(0) * cxy.size(1) - 1;
            for (d_loop_ub_tmp = 0; d_loop_ub_tmp <= nx; d_loop_ub_tmp++) {
              if (cxy[d_loop_ub_tmp] < 0.0F) {
                if (d_loop_ub_tmp > nx) {
                  rtDynamicBoundsError(d_loop_ub_tmp, 0, nx, j_emlrtBCI);
                }

                cxy[d_loop_ub_tmp] = 0.0F;
              }
            }

            r.set_size(Ix.size(0), Ix.size(1));
            if (loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < loop_ub_tmp; d_loop_ub_tmp++)
            {
              r[d_loop_ub_tmp] = std::abs(Ix[d_loop_ub_tmp]);
            }

            a.set_size(Iy.size(0), Iy.size(1));
            if (b_loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < b_loop_ub_tmp; d_loop_ub_tmp
                 ++) {
              a[d_loop_ub_tmp] = std::abs(Iy[d_loop_ub_tmp]);
            }

            if ((r.size(0) != a.size(0)) && ((r.size(0) != 1) && (a.size(0) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(0), a.size(0), k_emlrtECI);
            }

            if ((r.size(1) != a.size(1)) && ((r.size(1) != 1) && (a.size(1) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(1), a.size(1), l_emlrtECI);
            }

            nx = I_45_45.size(0) * I_45_45.size(1);
            c45.set_size(I_45_45.size(0), I_45_45.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              c45[d_loop_ub_tmp] = std::abs(I_45_45[d_loop_ub_tmp]);
            }

            loop_ub_tmp = c45.size(0) * c45.size(1);
            for (int i{0}; i < loop_ub_tmp; i++) {
              c45[i] = 16.0F * c45[i];
            }

            if ((r.size(0) == a.size(0)) && (r.size(1) == a.size(1))) {
              nx = r.size(0) * r.size(1);
              for (int i{0}; i < nx; i++) {
                r[i] = 6.0F * (r[i] + a[i]);
              }
            } else {
              b_binary_expand_op(r, a);
            }

            if ((c45.size(0) != r.size(0)) && ((c45.size(0) != 1) && (r.size(0)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(c45.size(0), r.size(0), m_emlrtECI);
            }

            if ((c45.size(1) != r.size(1)) && ((c45.size(1) != 1) && (r.size(1)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(c45.size(1), r.size(1), n_emlrtECI);
            }

            if ((c45.size(0) == r.size(0)) && (c45.size(1) == r.size(1))) {
              for (int i{0}; i < loop_ub_tmp; i++) {
                c45[i] = c45[i] - r[i];
              }
            } else {
              minus(c45, r);
            }

            nx = c45.size(0) * c45.size(1) - 1;
            for (d_loop_ub_tmp = 0; d_loop_ub_tmp <= nx; d_loop_ub_tmp++) {
              if (c45[d_loop_ub_tmp] < 0.0F) {
                if (d_loop_ub_tmp > nx) {
                  rtDynamicBoundsError(d_loop_ub_tmp, 0, nx, k_emlrtBCI);
                }

                c45[d_loop_ub_tmp] = 0.0F;
              }
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &Ix
          //                const ::coder::array<float, 2U> &Iy
          //                ::coder::array<float, 2U> &Ix2
          //                ::coder::array<float, 2U> &Iy2
          //                ::coder::array<float, 2U> &Ixy
          // Return Type  : void
          //
          static void computeJacobianEntries(const ::coder::array<float, 2U> &Ix,
            const ::coder::array<float, 2U> &Iy, ::coder::array<float, 2U> &Ix2,
            ::coder::array<float, 2U> &Iy2, ::coder::array<float, 2U> &Ixy)
          {
            static rtEqualityCheckInfo lb_emlrtECI{ 1,// nDims
              60,                      // lineNo
              7,                       // colNo
              "computeJacobianEntries",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ 2,// nDims
              60,                      // lineNo
              7,                       // colNo
              "computeJacobianEntries",// fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m"// pName
            };

            array<double, 2U> b_a;
            array<double, 2U> r;
            array<float, 2U> a;
            double pad[2];
            float varargin_1;
            int loop_ub;
            int loop_ub_tmp;
            if ((Ix.size(0) != Iy.size(0)) && ((Ix.size(0) != 1) && (Iy.size(0)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(Ix.size(0), Iy.size(0), lb_emlrtECI);
            }

            if ((Ix.size(1) != Iy.size(1)) && ((Ix.size(1) != 1) && (Iy.size(1)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(Ix.size(1), Iy.size(1), mb_emlrtECI);
            }

            Ix2.set_size(Ix.size(0), Ix.size(1));
            loop_ub_tmp = Ix.size(0) * Ix.size(1);
            for (int i{0}; i < loop_ub_tmp; i++) {
              varargin_1 = Ix[i];
              Ix2[i] = varargin_1 * varargin_1;
            }

            pad[0] = 3.0;
            pad[1] = 3.0;
            if ((Ix2.size(0) != 0) && (Ix2.size(1) != 0)) {
              padImage_outSize(Ix2, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              loop_ub = a.size(0) * a.size(1);
              for (int i{0}; i < loop_ub; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::c_conv2AXPYValidCMP(b_a, r);
              Ix2.set_size(r.size(0), r.size(1));
              loop_ub = r.size(0) * r.size(1);
              for (int i{0}; i < loop_ub; i++) {
                Ix2[i] = static_cast<float>(r[i]);
              }
            }

            Iy2.set_size(Iy.size(0), Iy.size(1));
            loop_ub = Iy.size(0) * Iy.size(1);
            for (int i{0}; i < loop_ub; i++) {
              varargin_1 = Iy[i];
              Iy2[i] = varargin_1 * varargin_1;
            }

            pad[0] = 3.0;
            pad[1] = 3.0;
            if ((Iy2.size(0) != 0) && (Iy2.size(1) != 0)) {
              padImage_outSize(Iy2, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              loop_ub = a.size(0) * a.size(1);
              for (int i{0}; i < loop_ub; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::c_conv2AXPYValidCMP(b_a, r);
              Iy2.set_size(r.size(0), r.size(1));
              loop_ub = r.size(0) * r.size(1);
              for (int i{0}; i < loop_ub; i++) {
                Iy2[i] = static_cast<float>(r[i]);
              }
            }

            if ((Ix.size(0) == Iy.size(0)) && (Ix.size(1) == Iy.size(1))) {
              Ixy.set_size(Ix.size(0), Ix.size(1));
              for (int i{0}; i < loop_ub_tmp; i++) {
                Ixy[i] = Ix[i] * Iy[i];
              }
            } else {
              times(Ixy, Ix, Iy);
            }

            pad[0] = 3.0;
            pad[1] = 3.0;
            if ((Ixy.size(0) != 0) && (Ixy.size(1) != 0)) {
              padImage_outSize(Ixy, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              loop_ub = a.size(0) * a.size(1);
              for (int i{0}; i < loop_ub; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::c_conv2AXPYValidCMP(b_a, r);
              Ixy.set_size(r.size(0), r.size(1));
              loop_ub = r.size(0) * r.size(1);
              for (int i{0}; i < loop_ub; i++) {
                Ixy[i] = static_cast<float>(r[i]);
              }
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &Ix2
          //                const ::coder::array<float, 2U> &Iy2
          //                const ::coder::array<float, 2U> &Ixy
          //                const float p[2]
          //                float v1[2]
          //                float v2[2]
          // Return Type  : void
          //
          static void cornerOrientations(const ::coder::array<float, 2U> &Ix2,
            const ::coder::array<float, 2U> &Iy2, const ::coder::array<float, 2U>
            &Ixy, const float p[2], float v1[2], float v2[2])
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              153,                     // lineNo
              9,                       // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              153,                     // lineNo
              15,                      // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              154,                     // lineNo
              9,                       // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              154,                     // lineNo
              15,                      // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              9,                       // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              155,                     // lineNo
              15,                      // colNo
              "",                      // aName
              "cornerOrientations",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            float a;
            float ab;
            float adf;
            float b;
            float c;
            float df;
            float tb;
            int i;
            int sgn2;
            if ((static_cast<int>(p[1]) < 1) || (static_cast<int>(p[1]) >
                 Ix2.size(0))) {
              rtDynamicBoundsError(static_cast<int>(p[1]), 1, Ix2.size(0),
                                   qf_emlrtBCI);
            }

            if ((static_cast<int>(p[0]) < 1) || (static_cast<int>(p[0]) >
                 Ix2.size(1))) {
              rtDynamicBoundsError(static_cast<int>(p[0]), 1, Ix2.size(1),
                                   rf_emlrtBCI);
            }

            a = Ix2[(static_cast<int>(static_cast<float>(static_cast<int>(p[1])))
                     + Ix2.size(0) * (static_cast<int>(static_cast<float>(
                        static_cast<int>(p[0]))) - 1)) - 1];
            if ((static_cast<int>(p[1]) < 1) || (static_cast<int>(p[1]) >
                 Ixy.size(0))) {
              rtDynamicBoundsError(static_cast<int>(p[1]), 1, Ixy.size(0),
                                   sf_emlrtBCI);
            }

            if ((static_cast<int>(p[0]) < 1) || (static_cast<int>(p[0]) >
                 Ixy.size(1))) {
              rtDynamicBoundsError(static_cast<int>(p[0]), 1, Ixy.size(1),
                                   tf_emlrtBCI);
            }

            b = Ixy[(static_cast<int>(static_cast<float>(static_cast<int>(p[1])))
                     + Ixy.size(0) * (static_cast<int>(static_cast<float>(
                        static_cast<int>(p[0]))) - 1)) - 1];
            if ((static_cast<int>(p[1]) < 1) || (static_cast<int>(p[1]) >
                 Iy2.size(0))) {
              rtDynamicBoundsError(static_cast<int>(p[1]), 1, Iy2.size(0),
                                   uf_emlrtBCI);
            }

            if ((static_cast<int>(p[0]) < 1) || (static_cast<int>(p[0]) >
                 Iy2.size(1))) {
              rtDynamicBoundsError(static_cast<int>(p[0]), 1, Iy2.size(1),
                                   vf_emlrtBCI);
            }

            c = Iy2[(static_cast<int>(static_cast<float>(static_cast<int>(p[1])))
                     + Iy2.size(0) * (static_cast<int>(static_cast<float>(
                        static_cast<int>(p[0]))) - 1)) - 1];
            df = a - c;
            adf = std::abs(df);
            tb = b + b;
            ab = std::abs(tb);
            if (adf > ab) {
              b = ab / adf;
              b = adf * std::sqrt(b * b + 1.0F);
            } else if (adf < ab) {
              b = adf / ab;
              b = ab * std::sqrt(b * b + 1.0F);
            } else {
              b = ab * 1.41421354F;
            }

            if (df > 0.0F) {
              b += df;
              sgn2 = 1;
            } else {
              b = df - b;
              sgn2 = -1;
            }

            if (std::abs(b) > ab) {
              adf = -tb / b;
              b = adf * adf + 1.0F;
              if (b < 0.0F) {
                d_rtErrorWithMessageID("sqrt", f_emlrtRTEI.fName,
                  f_emlrtRTEI.lineNo);
              }

              df = 1.0F / std::sqrt(b);
              b = adf * df;
            } else if (ab == 0.0F) {
              b = 1.0F;
              df = 0.0F;
            } else {
              adf = -b / tb;
              b = adf * adf + 1.0F;
              if (b < 0.0F) {
                d_rtErrorWithMessageID("sqrt", f_emlrtRTEI.fName,
                  f_emlrtRTEI.lineNo);
              }

              b = 1.0F / std::sqrt(b);
              df = adf * b;
            }

            if (a + c < 0.0F) {
              i = -1;
            } else {
              i = 1;
            }

            if (i == sgn2) {
              adf = b;
              b = -df;
              df = adf;
            }

            v1[0] = -df * 0.707106769F + b * 0.707106769F;
            v1[1] = -df * -0.707106769F + b * 0.707106769F;
            v2[0] = b * 0.707106769F + df * 0.707106769F;
            v2[1] = b * -0.707106769F + df * 0.707106769F;
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &b_I
          //                ::coder::array<double, 2U> &points
          //                double boardSize[2]
          // Return Type  : void
          //
          static void detectCheckerboard(const ::coder::array<float, 2U> &b_I, ::
            coder::array<double, 2U> &points, double boardSize[2])
          {
            Checkerboard lobj_0[6];
            Checkerboard *board0;
            Checkerboard *currentBoard;
            Checkerboard *iobj_0;
            Checkerboard *previousBoard;
            Checkerboard *tmpBoard;
            array<double, 1U> sortedIdx;
            array<float, 2U> I_45_45;
            array<float, 2U> Ix;
            array<float, 2U> Ix2;
            array<float, 2U> IxIy;
            array<float, 2U> Ixy;
            array<float, 2U> Iy;
            array<float, 2U> Iy2;
            array<float, 2U> c45;
            array<float, 2U> cxy;
            array<float, 2U> points0;
            array<float, 1U> b_points0;
            array<float, 1U> c_points0;
            array<unsigned int, 2U> b_seedIdx;
            array<unsigned int, 2U> seedIdx;
            array<int, 1U> iidx;
            float d_points0[2];
            float v1[2];
            float v2[2];
            int iv[2];
            int b_i;
            int cxy_tmp;
            int i;
            int loop_ub;
            unsigned int u;
            bool guard1{ false };

            bool guard2{ false };

            bool hasExpanded;
            b_secondDerivCornerMetric(b_I, cxy, c45, Ix, Iy, Ixy, I_45_45);
            computeJacobianEntries(Ix, Iy, Ix2, Iy2, IxIy);
            find_peaks(cxy, points0);
            b_points0.set_size(points0.size(0));
            loop_ub = points0.size(0);
            c_points0.set_size(points0.size(0));
            for (i = 0; i < loop_ub; i++) {
              b_points0[i] = points0[i + points0.size(0)];
              c_points0[i] = points0[i];
            }

            iv[0] = (*(int (*)[2])cxy.size())[0];
            iv[1] = (*(int (*)[2])cxy.size())[1];
            ::coder::internal::sub2ind(iv, b_points0, c_points0, iidx);
            sortedIdx.set_size(iidx.size(0));
            loop_ub = iidx.size(0);
            for (i = 0; i < loop_ub; i++) {
              sortedIdx[i] = iidx[i];
            }

            iv[0] = (*(int (*)[2])cxy.size())[0];
            iv[1] = (*(int (*)[2])cxy.size())[1];
            ::coder::internal::indexShapeCheck(iv, sortedIdx.size(0));
            cxy_tmp = cxy.size(0) * cxy.size(1);
            loop_ub = sortedIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_i = static_cast<int>(sortedIdx[i]);
              if ((b_i < 1) || (b_i > cxy_tmp)) {
                rtDynamicBoundsError(b_i, 1, cxy_tmp, d_emlrtBCI);
              }
            }

            iobj_0 = &lobj_0[0];
            if (sortedIdx.size(0) == 0) {
              iobj_0[0].isValid = false;
              iobj_0[0].Energy = rtInfF;
              iobj_0[0].IsDistortionHigh = false;
              board0 = &iobj_0[0];
              iobj_0[0].BoardIdx.set_size(1, 1);
              iobj_0[0].BoardIdx[0] = 0.0;
              iobj_0[0].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[0].BoardIdx[i] = 0.0;
              }

              iobj_0[0].BoardCoords.set_size(1, 1, 1);
              iobj_0[0].BoardCoords[0] = 0.0;
              iobj_0[0].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[0].BoardCoords[i] = 0.0;
              }

              iobj_0[0].Points.set_size(1, 1);
              iobj_0[0].Points[0] = 0.0F;
              iobj_0[0].Points.set_size(0, 2);
            } else {
              if (points0.size(0) < 1) {
                seedIdx.set_size(1, 0);
              } else {
                seedIdx.set_size(1, points0.size(0));
                loop_ub = points0.size(0) - 1;
                for (i = 0; i <= loop_ub; i++) {
                  seedIdx[i] = static_cast<unsigned int>(i) + 1U;
                }
              }

              iv[0] = (*(int (*)[2])seedIdx.size())[0];
              iv[1] = (*(int (*)[2])seedIdx.size())[1];
              ::coder::internal::indexShapeCheck(sortedIdx.size(0), iv);
              loop_ub = seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                b_i = static_cast<int>(seedIdx[i]);
                if (b_i > sortedIdx.size(0)) {
                  rtDynamicBoundsError(b_i, 1, sortedIdx.size(0), e_emlrtBCI);
                }
              }

              b_points0.set_size(seedIdx.size(1));
              loop_ub = seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                b_points0[i] = cxy[static_cast<int>(static_cast<unsigned int>
                  (sortedIdx[static_cast<int>(seedIdx[i]) - 1])) - 1];
              }

              ::coder::internal::sort(b_points0, iidx);
              sortedIdx.set_size(iidx.size(0));
              loop_ub = iidx.size(0);
              for (i = 0; i < loop_ub; i++) {
                sortedIdx[i] = iidx[i];
              }

              iv[0] = (*(int (*)[2])seedIdx.size())[0];
              iv[1] = (*(int (*)[2])seedIdx.size())[1];
              ::coder::internal::b_indexShapeCheck(iv, sortedIdx.size(0));
              b_seedIdx.set_size(1, sortedIdx.size(0));
              loop_ub = sortedIdx.size(0);
              for (i = 0; i < loop_ub; i++) {
                b_i = static_cast<int>(sortedIdx[i]);
                if ((b_i < 1) || (b_i > seedIdx.size(1))) {
                  rtDynamicBoundsError(b_i, 1, seedIdx.size(1), f_emlrtBCI);
                }

                b_seedIdx[i] = seedIdx[b_i - 1];
              }

              seedIdx.set_size(1, b_seedIdx.size(1));
              loop_ub = b_seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                seedIdx[i] = b_seedIdx[i];
              }

              if (sortedIdx.size(0) > 2000) {
                loop_ub = static_cast<int>(std::fmin(2000.0, std::round(
                  static_cast<double>(seedIdx.size(1)) / 2.0)));
                if (loop_ub < 1) {
                  loop_ub = 0;
                } else {
                  if (seedIdx.size(1) < 1) {
                    rtDynamicBoundsError(1, 1, seedIdx.size(1), c_emlrtBCI);
                  }

                  if (loop_ub > seedIdx.size(1)) {
                    rtDynamicBoundsError(loop_ub, 1, seedIdx.size(1), b_emlrtBCI);
                  }
                }

                for (i = 0; i < loop_ub; i++) {
                  seedIdx[i] = seedIdx[i];
                }

                seedIdx.set_size(1, loop_ub);
              }

              iobj_0[1].isValid = false;
              iobj_0[1].Energy = rtInfF;
              iobj_0[1].IsDistortionHigh = false;
              previousBoard = &iobj_0[1];
              iobj_0[1].BoardIdx.set_size(1, 1);
              iobj_0[1].BoardIdx[0] = 0.0;
              iobj_0[1].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[1].BoardIdx[i] = 0.0;
              }

              iobj_0[1].BoardCoords.set_size(1, 1, 1);
              iobj_0[1].BoardCoords[0] = 0.0;
              iobj_0[1].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[1].BoardCoords[i] = 0.0;
              }

              iobj_0[1].Points.set_size(1, 1);
              iobj_0[1].Points[0] = 0.0F;
              iobj_0[1].Points.set_size(0, 2);
              iobj_0[1].IsDistortionHigh = false;
              iobj_0[2].isValid = false;
              iobj_0[2].Energy = rtInfF;
              iobj_0[2].IsDistortionHigh = false;
              currentBoard = &iobj_0[2];
              iobj_0[2].BoardIdx.set_size(1, 1);
              iobj_0[2].BoardIdx[0] = 0.0;
              iobj_0[2].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[2].BoardIdx[i] = 0.0;
              }

              iobj_0[2].BoardCoords.set_size(1, 1, 1);
              iobj_0[2].BoardCoords[0] = 0.0;
              iobj_0[2].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[2].BoardCoords[i] = 0.0;
              }

              iobj_0[2].Points.set_size(1, 1);
              iobj_0[2].Points[0] = 0.0F;
              iobj_0[2].Points.set_size(0, 2);
              iobj_0[2].IsDistortionHigh = false;
              i = seedIdx.size(1);
              for (b_i = 0; b_i < i; b_i++) {
                if (b_i + 1 > seedIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, seedIdx.size(1), h_emlrtBCI);
                }

                u = seedIdx[b_i];
                if (static_cast<int>(u) > points0.size(0)) {
                  rtDynamicBoundsError(static_cast<int>(u), 1, points0.size(0),
                                       emlrtBCI);
                }

                cxy_tmp = static_cast<int>(seedIdx[b_i]);
                d_points0[0] = points0[cxy_tmp - 1];
                d_points0[1] = points0[(cxy_tmp + points0.size(0)) - 1];
                cornerOrientations(Ix2, Iy2, IxIy, d_points0, v1, v2);
                if ((!(std::abs(std::abs(rt_atan2f_snf(v1[1], v1[0])) -
                                3.14159274F) > 0.58904862254808621)) || (!(std::
                      abs(std::abs(rt_atan2f_snf(v2[1], v2[0])) - 3.14159274F) >
                      0.58904862254808621))) {
                  if (b_i + 1 > seedIdx.size(1)) {
                    rtDynamicBoundsError(b_i + 1, 1, seedIdx.size(1), i_emlrtBCI);
                  }

                  currentBoard->initialize(static_cast<double>(u), points0, v1,
                    v2);
                  if (currentBoard->isValid) {
                    hasExpanded = true;
                    while (hasExpanded) {
                      hasExpanded = currentBoard->expandBoardOnce();
                    }
                  }

                  if (currentBoard->Energy < previousBoard->Energy) {
                    tmpBoard = previousBoard;
                    previousBoard = currentBoard;
                    currentBoard = tmpBoard;
                  }
                }
              }

              board0 = previousBoard;
              if (previousBoard->isValid) {
                previousBoard->IsDirectionBad[0] = false;
                previousBoard->IsDirectionBad[1] = false;
                previousBoard->IsDirectionBad[2] = false;
                previousBoard->IsDirectionBad[3] = false;
                hasExpanded = true;
                while (hasExpanded) {
                  hasExpanded = previousBoard->b_expandBoardOnce();
                }
              }
            }

            points.set_size(0, 0);
            boardSize[0] = 0.0;
            boardSize[1] = 0.0;
            find_peaks(c45, points0);
            b_points0.set_size(points0.size(0));
            loop_ub = points0.size(0);
            c_points0.set_size(points0.size(0));
            for (i = 0; i < loop_ub; i++) {
              b_points0[i] = points0[i + points0.size(0)];
              c_points0[i] = points0[i];
            }

            iv[0] = (*(int (*)[2])c45.size())[0];
            iv[1] = (*(int (*)[2])c45.size())[1];
            ::coder::internal::sub2ind(iv, b_points0, c_points0, iidx);
            sortedIdx.set_size(iidx.size(0));
            loop_ub = iidx.size(0);
            for (i = 0; i < loop_ub; i++) {
              sortedIdx[i] = iidx[i];
            }

            iv[0] = (*(int (*)[2])c45.size())[0];
            iv[1] = (*(int (*)[2])c45.size())[1];
            ::coder::internal::indexShapeCheck(iv, sortedIdx.size(0));
            cxy_tmp = c45.size(0) * c45.size(1);
            loop_ub = sortedIdx.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_i = static_cast<int>(sortedIdx[i]);
              if ((b_i < 1) || (b_i > cxy_tmp)) {
                rtDynamicBoundsError(b_i, 1, cxy_tmp, g_emlrtBCI);
              }
            }

            iobj_0 = &lobj_0[3];
            if (sortedIdx.size(0) == 0) {
              iobj_0[0].isValid = false;
              iobj_0[0].Energy = rtInfF;
              iobj_0[0].IsDistortionHigh = false;
              tmpBoard = &iobj_0[0];
              iobj_0[0].BoardIdx.set_size(1, 1);
              iobj_0[0].BoardIdx[0] = 0.0;
              iobj_0[0].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[0].BoardIdx[i] = 0.0;
              }

              iobj_0[0].BoardCoords.set_size(1, 1, 1);
              iobj_0[0].BoardCoords[0] = 0.0;
              iobj_0[0].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[0].BoardCoords[i] = 0.0;
              }

              iobj_0[0].Points.set_size(1, 1);
              iobj_0[0].Points[0] = 0.0F;
              iobj_0[0].Points.set_size(0, 2);
            } else {
              if (points0.size(0) < 1) {
                seedIdx.set_size(1, 0);
              } else {
                seedIdx.set_size(1, points0.size(0));
                loop_ub = points0.size(0) - 1;
                for (i = 0; i <= loop_ub; i++) {
                  seedIdx[i] = static_cast<unsigned int>(i) + 1U;
                }
              }

              iv[0] = (*(int (*)[2])seedIdx.size())[0];
              iv[1] = (*(int (*)[2])seedIdx.size())[1];
              ::coder::internal::indexShapeCheck(sortedIdx.size(0), iv);
              loop_ub = seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                b_i = static_cast<int>(seedIdx[i]);
                if (b_i > sortedIdx.size(0)) {
                  rtDynamicBoundsError(b_i, 1, sortedIdx.size(0), e_emlrtBCI);
                }
              }

              b_points0.set_size(seedIdx.size(1));
              loop_ub = seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                b_points0[i] = c45[static_cast<int>(static_cast<unsigned int>
                  (sortedIdx[static_cast<int>(seedIdx[i]) - 1])) - 1];
              }

              ::coder::internal::sort(b_points0, iidx);
              sortedIdx.set_size(iidx.size(0));
              loop_ub = iidx.size(0);
              for (i = 0; i < loop_ub; i++) {
                sortedIdx[i] = iidx[i];
              }

              iv[0] = (*(int (*)[2])seedIdx.size())[0];
              iv[1] = (*(int (*)[2])seedIdx.size())[1];
              ::coder::internal::b_indexShapeCheck(iv, sortedIdx.size(0));
              b_seedIdx.set_size(1, sortedIdx.size(0));
              loop_ub = sortedIdx.size(0);
              for (i = 0; i < loop_ub; i++) {
                b_i = static_cast<int>(sortedIdx[i]);
                if ((b_i < 1) || (b_i > seedIdx.size(1))) {
                  rtDynamicBoundsError(b_i, 1, seedIdx.size(1), f_emlrtBCI);
                }

                b_seedIdx[i] = seedIdx[b_i - 1];
              }

              seedIdx.set_size(1, b_seedIdx.size(1));
              loop_ub = b_seedIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                seedIdx[i] = b_seedIdx[i];
              }

              if (sortedIdx.size(0) > 2000) {
                loop_ub = static_cast<int>(std::fmin(2000.0, std::round(
                  static_cast<double>(seedIdx.size(1)) / 2.0)));
                if (loop_ub < 1) {
                  loop_ub = 0;
                } else {
                  if (seedIdx.size(1) < 1) {
                    rtDynamicBoundsError(1, 1, seedIdx.size(1), c_emlrtBCI);
                  }

                  if (loop_ub > seedIdx.size(1)) {
                    rtDynamicBoundsError(loop_ub, 1, seedIdx.size(1), b_emlrtBCI);
                  }
                }

                for (i = 0; i < loop_ub; i++) {
                  seedIdx[i] = seedIdx[i];
                }

                seedIdx.set_size(1, loop_ub);
              }

              iobj_0[1].isValid = false;
              iobj_0[1].Energy = rtInfF;
              iobj_0[1].IsDistortionHigh = false;
              previousBoard = &iobj_0[1];
              iobj_0[1].BoardIdx.set_size(1, 1);
              iobj_0[1].BoardIdx[0] = 0.0;
              iobj_0[1].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[1].BoardIdx[i] = 0.0;
              }

              iobj_0[1].BoardCoords.set_size(1, 1, 1);
              iobj_0[1].BoardCoords[0] = 0.0;
              iobj_0[1].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[1].BoardCoords[i] = 0.0;
              }

              iobj_0[1].Points.set_size(1, 1);
              iobj_0[1].Points[0] = 0.0F;
              iobj_0[1].Points.set_size(0, 2);
              iobj_0[1].IsDistortionHigh = false;
              iobj_0[2].isValid = false;
              iobj_0[2].Energy = rtInfF;
              iobj_0[2].IsDistortionHigh = false;
              currentBoard = &iobj_0[2];
              iobj_0[2].BoardIdx.set_size(1, 1);
              iobj_0[2].BoardIdx[0] = 0.0;
              iobj_0[2].BoardIdx.set_size(3, 3);
              for (i = 0; i < 9; i++) {
                iobj_0[2].BoardIdx[i] = 0.0;
              }

              iobj_0[2].BoardCoords.set_size(1, 1, 1);
              iobj_0[2].BoardCoords[0] = 0.0;
              iobj_0[2].BoardCoords.set_size(3, 3, 2);
              for (i = 0; i < 18; i++) {
                iobj_0[2].BoardCoords[i] = 0.0;
              }

              iobj_0[2].Points.set_size(1, 1);
              iobj_0[2].Points[0] = 0.0F;
              iobj_0[2].Points.set_size(0, 2);
              iobj_0[2].IsDistortionHigh = false;
              i = seedIdx.size(1);
              for (b_i = 0; b_i < i; b_i++) {
                if (b_i + 1 > seedIdx.size(1)) {
                  rtDynamicBoundsError(b_i + 1, 1, seedIdx.size(1), h_emlrtBCI);
                }

                u = seedIdx[b_i];
                if (static_cast<int>(u) > points0.size(0)) {
                  rtDynamicBoundsError(static_cast<int>(u), 1, points0.size(0),
                                       emlrtBCI);
                }

                cxy_tmp = static_cast<int>(seedIdx[b_i]);
                d_points0[0] = points0[cxy_tmp - 1];
                d_points0[1] = points0[(cxy_tmp + points0.size(0)) - 1];
                cornerOrientations(Ix2, Iy2, IxIy, d_points0, v1, v2);
                if ((!(std::abs(std::abs(std::abs(rt_atan2f_snf(v1[1], v1[0])) -
                        3.14159274F) - 0.785398185F) > 0.58904862254808621)) ||
                    (!(std::abs(std::abs(std::abs(rt_atan2f_snf(v2[1], v2[0])) -
                        3.14159274F) - 0.785398185F) > 0.58904862254808621))) {
                  if (b_i + 1 > seedIdx.size(1)) {
                    rtDynamicBoundsError(b_i + 1, 1, seedIdx.size(1), i_emlrtBCI);
                  }

                  currentBoard->initialize(static_cast<double>(u), points0, v1,
                    v2);
                  if (currentBoard->isValid) {
                    hasExpanded = true;
                    while (hasExpanded) {
                      hasExpanded = currentBoard->expandBoardOnce();
                    }
                  }

                  if (currentBoard->Energy < previousBoard->Energy) {
                    tmpBoard = previousBoard;
                    previousBoard = currentBoard;
                    currentBoard = tmpBoard;
                  }
                }
              }

              tmpBoard = previousBoard;
              if (previousBoard->isValid) {
                previousBoard->IsDirectionBad[0] = false;
                previousBoard->IsDirectionBad[1] = false;
                previousBoard->IsDirectionBad[2] = false;
                previousBoard->IsDirectionBad[3] = false;
                hasExpanded = true;
                while (hasExpanded) {
                  hasExpanded = previousBoard->b_expandBoardOnce();
                }
              }
            }

            guard1 = false;
            guard2 = false;
            if (board0->isValid) {
              if (board0->Energy <= tmpBoard->Energy) {
                guard2 = true;
              } else {
                unsigned int varargin_1[2];
                unsigned int varargin_2[2];
                bool exitg1;
                varargin_1[0] = static_cast<unsigned int>(board0->BoardIdx.size
                  (0));
                varargin_1[1] = static_cast<unsigned int>(board0->BoardIdx.size
                  (1));
                varargin_2[0] = static_cast<unsigned int>
                  (tmpBoard->BoardIdx.size(0));
                varargin_2[1] = static_cast<unsigned int>
                  (tmpBoard->BoardIdx.size(1));
                hasExpanded = true;
                loop_ub = 0;
                exitg1 = false;
                while ((!exitg1) && (loop_ub < 2)) {
                  if (static_cast<int>(varargin_1[loop_ub]) != static_cast<int>
                      (varargin_2[loop_ub])) {
                    hasExpanded = false;
                    exitg1 = true;
                  } else {
                    loop_ub++;
                  }
                }

                if (hasExpanded) {
                  sortedIdx.set_size(board0->BoardIdx.size(0) *
                                     board0->BoardIdx.size(1));
                  loop_ub = board0->BoardIdx.size(0) * board0->BoardIdx.size(1);
                  for (i = 0; i < loop_ub; i++) {
                    sortedIdx[i] = board0->BoardIdx[i];
                  }

                  b_i = 0;
                  i = sortedIdx.size(0);
                  for (loop_ub = 0; loop_ub < i; loop_ub++) {
                    if (sortedIdx[loop_ub] != 0.0) {
                      b_i++;
                    }
                  }

                  sortedIdx.set_size(tmpBoard->BoardIdx.size(0) *
                                     tmpBoard->BoardIdx.size(1));
                  loop_ub = tmpBoard->BoardIdx.size(0) * tmpBoard->BoardIdx.size
                    (1);
                  for (i = 0; i < loop_ub; i++) {
                    sortedIdx[i] = tmpBoard->BoardIdx[i];
                  }

                  cxy_tmp = 0;
                  i = sortedIdx.size(0);
                  for (loop_ub = 0; loop_ub < i; loop_ub++) {
                    if (sortedIdx[loop_ub] != 0.0) {
                      cxy_tmp++;
                    }
                  }

                  if (b_i > cxy_tmp) {
                    guard2 = true;
                  } else {
                    guard1 = true;
                  }
                } else {
                  guard1 = true;
                }
              }
            } else {
              guard1 = true;
            }

            if (guard2) {
              board0 = orient(board0, b_I);
              toPoints(board0, points, boardSize);
              subPixelLocation(Ixy, points);
            }

            if (guard1 && tmpBoard->isValid) {
              tmpBoard = orient(tmpBoard, b_I);
              toPoints(tmpBoard, points, boardSize);
              subPixelLocation(I_45_45, points);
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &metric
          //                ::coder::array<float, 2U> &loc
          // Return Type  : void
          //
          static void find_peaks(const ::coder::array<float, 2U> &metric, ::
            coder::array<float, 2U> &loc)
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              16,                      // lineNo
              8,                       // colNo
              "",                      // aName
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              20,                      // lineNo
              8,                       // colNo
              "",                      // aName
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              21,                      // lineNo
              8,                       // colNo
              "",                      // aName
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              22,                      // lineNo
              11,                      // colNo
              "",                      // aName
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              23,                      // lineNo
              11,                      // colNo
              "",                      // aName
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m",// pName
              0                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              28,                      // lineNo
              6,                       // colNo
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              28,                      // lineNo
              17,                      // colNo
              "findPeaks",             // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/findPeaks.m"// pName
            };

            static rtRunTimeErrorInfo s_emlrtRTEI{ 21,// lineNo
              15,                      // colNo
              "ind2sub",               // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/ind2sub.m"// pName
            };

            images::internal::coder::NeighborhoodProcessor np;
            array<int, 1U> ii;
            array<int, 1U> vk;
            array<bool, 2U> bwpre;
            array<bool, 2U> expl_temp_bw;
            struct_T expl_temp;
            float maxMetric;
            int idx;
            int k;
            int last;
            int nx;
            bool exitg1;
            last = metric.size(0) * metric.size(1);
            if (last < 1) {
              d_rtErrorWithMessageID(c_emlrtRTEI.fName, c_emlrtRTEI.lineNo);
            }

            if (last <= 2) {
              if (last == 1) {
                maxMetric = metric[0];
              } else {
                maxMetric = metric[1];
                if ((!(metric[0] < maxMetric)) && ((!std::isnan(metric[0])) ||
                     std::isnan(maxMetric))) {
                  maxMetric = metric[0];
                }
              }
            } else {
              if (!std::isnan(metric[0])) {
                idx = 1;
              } else {
                idx = 0;
                if (last > 2147483646) {
                  check_forloop_overflow_error();
                }

                k = 2;
                exitg1 = false;
                while ((!exitg1) && (k <= last)) {
                  if (!std::isnan(metric[k - 1])) {
                    idx = k;
                    exitg1 = true;
                  } else {
                    k++;
                  }
                }
              }

              if (idx == 0) {
                maxMetric = metric[0];
              } else {
                maxMetric = metric[idx - 1];
                nx = idx + 1;
                if ((idx + 1 <= last) && (last > 2147483646)) {
                  check_forloop_overflow_error();
                }

                for (k = nx; k <= last; k++) {
                  float f;
                  f = metric[k - 1];
                  if (maxMetric < f) {
                    maxMetric = f;
                  }
                }
              }
            }

            if (maxMetric <= 4.94065645841247E-324) {
              loc.set_size(0, 2);
            } else {
              int i;
              int loop_ub_tmp;
              unsigned int unnamed_idx_0_tmp;
              bool continuePropagation;
              continuePropagation = true;
              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= last - 1)) {
                if (!std::isnan(metric[k])) {
                  k++;
                } else {
                  continuePropagation = false;
                  exitg1 = true;
                }
              }

              if (!continuePropagation) {
                b_rtErrorWithMessageID("input number 1, I,", emlrtRTEI.fName,
                  emlrtRTEI.lineNo);
              }

              np.ImageSize[0] = metric.size(0);
              np.ImageSize[1] = metric.size(1);
              np.Padding = 1.0;
              np.ProcessBorder = true;
              np.NeighborhoodCenter = 1.0;
              np.PadValue = 0.0;
              for (idx = 0; idx < 9; idx++) {
                np.Neighborhood[idx] = true;
                np.ImageNeighborLinearOffsets[idx] = 0;
                np.NeighborLinearIndices[idx] = 0;
              }

              std::memset(&np.NeighborSubscriptOffsets[0], 0, 18U * sizeof(int));
              unnamed_idx_0_tmp = static_cast<unsigned int>(metric.size(0));
              expl_temp_bw.set_size(metric.size(0), metric.size(1));
              loop_ub_tmp = metric.size(0) * metric.size(1);
              for (i = 0; i < loop_ub_tmp; i++) {
                expl_temp_bw[i] = true;
              }

              continuePropagation = true;
              while (continuePropagation) {
                bwpre.set_size(expl_temp_bw.size(0), expl_temp_bw.size(1));
                k = expl_temp_bw.size(0) * expl_temp_bw.size(1);
                for (i = 0; i < k; i++) {
                  bwpre[i] = expl_temp_bw[i];
                }

                images::internal::coder::NeighborhoodProcessor::
                  computeParameters(np.ImageSize, np.Neighborhood,
                                    np.NeighborhoodCenter,
                                    np.ImageNeighborLinearOffsets,
                                    np.NeighborLinearIndices,
                                    np.NeighborSubscriptOffsets,
                                    np.InteriorStart, np.InteriorEnd);
                expl_temp.bw = expl_temp_bw;
                np.process2D(metric, expl_temp_bw, expl_temp);
                continuePropagation = !isequal(bwpre, expl_temp_bw);
              }

              nx = last - 1;
              for (idx = 0; idx <= nx; idx++) {
                if (metric[idx] < 0.15F * maxMetric) {
                  i = expl_temp_bw.size(0) * expl_temp_bw.size(1) - 1;
                  if (idx > i) {
                    rtDynamicBoundsError(idx, 0, i, qf_emlrtBCI);
                  }

                  expl_temp_bw[idx] = false;
                }
              }

              bwmorph(expl_temp_bw);
              if (expl_temp_bw.size(0) < 1) {
                rtDynamicBoundsError(1, 1, expl_temp_bw.size(0), rf_emlrtBCI);
              }

              k = expl_temp_bw.size(1);
              for (i = 0; i < k; i++) {
                expl_temp_bw[expl_temp_bw.size(0) * i] = false;
              }

              if (expl_temp_bw.size(0) < 1) {
                rtDynamicBoundsError(expl_temp_bw.size(0), 1, expl_temp_bw.size
                                     (0), sf_emlrtBCI);
              }

              k = expl_temp_bw.size(1);
              for (i = 0; i < k; i++) {
                expl_temp_bw[(expl_temp_bw.size(0) + expl_temp_bw.size(0) * i) -
                  1] = false;
              }

              if (expl_temp_bw.size(1) < 1) {
                rtDynamicBoundsError(1, 1, expl_temp_bw.size(1), tf_emlrtBCI);
              }

              k = expl_temp_bw.size(0);
              for (i = 0; i < k; i++) {
                expl_temp_bw[i] = false;
              }

              if (expl_temp_bw.size(1) < 1) {
                rtDynamicBoundsError(expl_temp_bw.size(1), 1, expl_temp_bw.size
                                     (1), uf_emlrtBCI);
              }

              k = expl_temp_bw.size(0);
              for (i = 0; i < k; i++) {
                expl_temp_bw[i + expl_temp_bw.size(0) * (expl_temp_bw.size(1) -
                  1)] = false;
              }

              nx = expl_temp_bw.size(0) * expl_temp_bw.size(1);
              idx = 0;
              ii.set_size(nx);
              if (nx > 2147483646) {
                check_forloop_overflow_error();
              }

              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= nx - 1)) {
                if (expl_temp_bw[k]) {
                  idx++;
                  ii[idx - 1] = k + 1;
                  if (idx >= nx) {
                    exitg1 = true;
                  } else {
                    k++;
                  }
                } else {
                  k++;
                }
              }

              if (idx > nx) {
                c_rtErrorWithMessageID(b_emlrtRTEI.fName, b_emlrtRTEI.lineNo);
              }

              if (nx == 1) {
                if (idx == 0) {
                  ii.set_size(0);
                }
              } else {
                int iv[2];
                if (idx < 1) {
                  i = 0;
                } else {
                  i = idx;
                }

                iv[0] = 1;
                iv[1] = i;
                ::coder::internal::indexShapeCheck(ii.size(0), iv);
                ii.set_size(i);
              }

              loc.set_size(ii.size(0), 2);
              k = ii.size(0) << 1;
              for (i = 0; i < k; i++) {
                loc[i] = 0.0F;
              }

              k = 0;
              exitg1 = false;
              while ((!exitg1) && (k <= ii.size(0) - 1)) {
                if (ii[k] > loop_ub_tmp) {
                  b_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
                } else {
                  k++;
                }
              }

              k = ii.size(0);
              for (i = 0; i < k; i++) {
                ii[i] = ii[i] - 1;
              }

              vk.set_size(ii.size(0));
              k = ii.size(0);
              for (i = 0; i < k; i++) {
                nx = div_s32(ii[i], static_cast<int>(unnamed_idx_0_tmp));
                vk[i] = nx;
                ii[i] = ii[i] - nx * static_cast<int>(unnamed_idx_0_tmp);
              }

              k = ii.size(0);
              for (i = 0; i < k; i++) {
                ii[i] = ii[i] + 1;
                vk[i] = vk[i] + 1;
              }

              rtSubAssignSizeCheck(ii.size(), 1, ii.size(), 1, lb_emlrtECI);
              k = ii.size(0);
              for (i = 0; i < k; i++) {
                loc[i + loc.size(0)] = static_cast<float>(ii[i]);
              }

              rtSubAssignSizeCheck(loc.size(), 1, vk.size(), 1, mb_emlrtECI);
              k = vk.size(0);
              for (i = 0; i < k; i++) {
                loc[i] = static_cast<float>(vk[i]);
              }
            }
          }

          //
          // Arguments    : const Checkerboard *b_this
          //                const ::coder::array<float, 2U> &b_I
          // Return Type  : bool
          //
          static bool isUpperLeftBlack(const Checkerboard *b_this, const ::coder::
            array<float, 2U> &b_I)
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              330,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ah_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              340,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              330,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              340,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              330,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ch_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              341,                     // lineNo
              37,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              331,                     // lineNo
              36,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              341,                     // lineNo
              40,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              331,                     // lineNo
              39,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              341,                     // lineNo
              43,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              331,                     // lineNo
              42,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo hg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo hh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ig_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ih_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo jg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo jh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo kg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo kh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              342,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo lg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              332,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo lh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              343,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo mg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              333,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo mh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              343,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ng_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              333,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo nh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              343,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo og_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              333,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo oh_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              348,                     // lineNo
              18,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo pg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              338,                     // lineNo
              37,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ph_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              348,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              328,                     // lineNo
              36,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              338,                     // lineNo
              40,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              328,                     // lineNo
              39,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              338,                     // lineNo
              43,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              328,                     // lineNo
              42,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              25,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ug_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              52,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              339,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              329,                     // lineNo
              55,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              340,                     // lineNo
              22,                      // colNo
              "",                      // aName
              "isUpperLeftBlack",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            array<float, 1U> c_I;
            array<int, 1U> r;
            array<int, 1U> r1;
            array<bool, 2U> nextSquareMask;
            array<bool, 2U> upperLeftMask;
            double c_this[4];
            double d_this[4];
            float y;
            int iv[2];
            int iv1[2];
            int I_idx_0_tmp;
            int end;
            int trueCount;
            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, qf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, rf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, sf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, tf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, uf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, vf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, wf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, xf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, yf_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, ag_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, bg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, cg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, dg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, eg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, fg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, gg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, hg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, ig_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, jg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, kg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, lg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, mg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, ng_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, og_emlrtBCI);
            }

            c_this[0] = b_this->BoardCoords[0];
            c_this[1] = b_this->BoardCoords[b_this->BoardCoords.size(0)];
            c_this[2] = b_this->BoardCoords[b_this->BoardCoords.size(0) + 1];
            c_this[3] = b_this->BoardCoords[1];
            d_this[0] = b_this->BoardCoords[b_this->BoardCoords.size(0) *
              b_this->BoardCoords.size(1)];
            d_this[1] = b_this->BoardCoords[b_this->BoardCoords.size(0) +
              b_this->BoardCoords.size(0) * b_this->BoardCoords.size(1)];
            d_this[2] = b_this->BoardCoords[(b_this->BoardCoords.size(0) +
              b_this->BoardCoords.size(0) * b_this->BoardCoords.size(1)) + 1];
            d_this[3] = b_this->BoardCoords[b_this->BoardCoords.size(0) *
              b_this->BoardCoords.size(1) + 1];
            poly2RectMask(c_this, d_this, static_cast<double>(b_I.size(0)),
                          static_cast<double>(b_I.size(1)), upperLeftMask);
            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, pg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, qg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, rg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, sg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 3) {
              rtDynamicBoundsError(3, 1, end, tg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, ug_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, vg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 3) {
              rtDynamicBoundsError(3, 1, end, wg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, xg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, yg_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, ah_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, bh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, ch_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, dh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, eh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 1) {
              rtDynamicBoundsError(1, 1, end, fh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 3) {
              rtDynamicBoundsError(3, 1, end, gh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, hh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, ih_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 3) {
              rtDynamicBoundsError(3, 1, end, jh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, kh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(0);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, lh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(1);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, mh_emlrtBCI);
            }

            end = b_this->BoardCoords.size(2);
            if (end < 2) {
              rtDynamicBoundsError(2, 1, end, nh_emlrtBCI);
            }

            c_this[0] = b_this->BoardCoords[b_this->BoardCoords.size(0)];
            c_this[1] = b_this->BoardCoords[b_this->BoardCoords.size(0) * 2];
            c_this[2] = b_this->BoardCoords[b_this->BoardCoords.size(0) * 2 + 1];
            c_this[3] = b_this->BoardCoords[b_this->BoardCoords.size(0) + 1];
            d_this[0] = b_this->BoardCoords[b_this->BoardCoords.size(0) +
              b_this->BoardCoords.size(0) * b_this->BoardCoords.size(1)];
            d_this[1] = b_this->BoardCoords[(b_this->BoardCoords.size(1) + 2) *
              b_this->BoardCoords.size(0)];
            d_this[2] = b_this->BoardCoords[(2 + b_this->BoardCoords.size(1)) *
              b_this->BoardCoords.size(0) + 1];
            d_this[3] = b_this->BoardCoords[(b_this->BoardCoords.size(0) +
              b_this->BoardCoords.size(0) * b_this->BoardCoords.size(1)) + 1];
            poly2RectMask(c_this, d_this, static_cast<double>(b_I.size(0)),
                          static_cast<double>(b_I.size(1)), nextSquareMask);
            iv[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&b_I)->size())[0];
            iv[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&b_I)->size())[1];
            iv1[0] = (*(int (*)[2])upperLeftMask.size())[0];
            iv1[1] = (*(int (*)[2])upperLeftMask.size())[1];
            ::coder::internal::b_indexShapeCheck(iv, iv1);
            iv[0] = (*(int (*)[2])((::coder::array<float, 2U> *)&b_I)->size())[0];
            iv[1] = (*(int (*)[2])((::coder::array<float, 2U> *)&b_I)->size())[1];
            iv1[0] = (*(int (*)[2])nextSquareMask.size())[0];
            iv1[1] = (*(int (*)[2])nextSquareMask.size())[1];
            ::coder::internal::b_indexShapeCheck(iv, iv1);
            end = upperLeftMask.size(0) * upperLeftMask.size(1) - 1;
            trueCount = 0;
            for (int i{0}; i <= end; i++) {
              if (upperLeftMask[i]) {
                trueCount++;
              }
            }

            r.set_size(trueCount);
            trueCount = 0;
            for (int i{0}; i <= end; i++) {
              if (upperLeftMask[i]) {
                r[trueCount] = i;
                trueCount++;
              }
            }

            I_idx_0_tmp = b_I.size(0) * b_I.size(1);
            c_I.set_size(r.size(0));
            trueCount = r.size(0);
            for (end = 0; end < trueCount; end++) {
              if (r[end] > I_idx_0_tmp - 1) {
                rtDynamicBoundsError(r[end], 0, I_idx_0_tmp - 1, oh_emlrtBCI);
              }

              c_I[end] = b_I[r[end]];
            }

            y = mean(c_I);
            end = nextSquareMask.size(0) * nextSquareMask.size(1) - 1;
            trueCount = 0;
            for (int i{0}; i <= end; i++) {
              if (nextSquareMask[i]) {
                trueCount++;
              }
            }

            r1.set_size(trueCount);
            trueCount = 0;
            for (int i{0}; i <= end; i++) {
              if (nextSquareMask[i]) {
                r1[trueCount] = i;
                trueCount++;
              }
            }

            c_I.set_size(r1.size(0));
            trueCount = r1.size(0);
            for (end = 0; end < trueCount; end++) {
              if (r1[end] > I_idx_0_tmp - 1) {
                rtDynamicBoundsError(r1[end], 0, I_idx_0_tmp - 1, ph_emlrtBCI);
              }

              c_I[end] = b_I[r1[end]];
            }

            float b_y;
            b_y = mean(c_I);
            return y < b_y;
          }

          //
          // Arguments    : Checkerboard *board
          //                const ::coder::array<float, 2U> &b_I
          // Return Type  : Checkerboard *
          //
          static Checkerboard *orient(Checkerboard *board, const ::coder::array<
            float, 2U> &b_I)
          {
            static rtBoundsCheckInfo ag_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              29,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo bg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              31,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo cg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              54,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo dg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              294,                     // lineNo
              45,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo eg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              293,                     // lineNo
              35,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo fg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              294,                     // lineNo
              5,                       // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo gg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              294,                     // lineNo
              30,                      // colNo
              "",                      // aName
              "getOriginInImage",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo hg_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              317,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "flip_checkerboard",     // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo ig_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              318,                     // lineNo
              46,                      // colNo
              "",                      // aName
              "flip_checkerboard",     // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              310,                     // lineNo
              47,                      // colNo
              "",                      // aName
              "rot90_checkerboard",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              309,                     // lineNo
              47,                      // colNo
              "",                      // aName
              "rot90_checkerboard",    // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              282,                     // lineNo
              38,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              282,                     // lineNo
              40,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              282,                     // lineNo
              65,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo vf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              282,                     // lineNo
              70,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo wf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              283,                     // lineNo
              49,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo xf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              283,                     // lineNo
              39,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo yf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              283,                     // lineNo
              44,                      // colNo
              "",                      // aName
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ 3,// nDims
              282,                     // lineNo
              20,                      // colNo
              "orient",                // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m"// pName
            };

            static rtRunTimeErrorInfo s_emlrtRTEI{ 44,// lineNo
              19,                      // colNo
              "allOrAny",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/allOrAny.m"// pName
            };

            static rtRunTimeErrorInfo t_emlrtRTEI{ 47,// lineNo
              19,                      // colNo
              "allOrAny",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/allOrAny.m"// pName
            };

            Checkerboard *b_board;
            array<double, 3U> r;
            array<double, 3U> r1;
            array<double, 3U> r2;
            array<double, 2U> c_board;
            array<double, 2U> newBoardCoords1;
            array<double, 2U> newBoardCoords2;
            array<bool, 3U> b_x;
            array<bool, 2U> c_numRot_data;
            array<bool, 2U> y;
            float x;
            int numRot_size[2];
            bool b_numRot_data;
            b_board = board;
            x = b_board->Energy;
            if (!std::isinf(x)) {
              double numRot_data;
              int i;
              int i1;
              int i2;
              int loop_ub;
              int npages;
              bool exitg1;
              if (b_board->BoardCoords.size(0) < b_board->BoardCoords.size(1)) {
                c_board.set_size(b_board->BoardIdx.size(0),
                                 b_board->BoardIdx.size(1));
                loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size(1)
                  - 1;
                for (i = 0; i <= loop_ub; i++) {
                  c_board[i] = b_board->BoardIdx[i];
                }

                rot90(c_board, b_board->BoardIdx);
                i = b_board->BoardCoords.size(2);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
                }

                c_board.set_size(b_board->BoardCoords.size(0),
                                 b_board->BoardCoords.size(1));
                loop_ub = b_board->BoardCoords.size(1);
                for (i = 0; i < loop_ub; i++) {
                  npages = b_board->BoardCoords.size(0);
                  for (i1 = 0; i1 < npages; i1++) {
                    c_board[i1 + c_board.size(0) * i] = b_board->BoardCoords[i1
                      + b_board->BoardCoords.size(0) * i];
                  }
                }

                rot90(c_board, newBoardCoords1);
                i = b_board->BoardCoords.size(2);
                if (i < 2) {
                  rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
                }

                c_board.set_size(b_board->BoardCoords.size(0),
                                 b_board->BoardCoords.size(1));
                loop_ub = b_board->BoardCoords.size(1);
                for (i = 0; i < loop_ub; i++) {
                  npages = b_board->BoardCoords.size(0);
                  for (i1 = 0; i1 < npages; i1++) {
                    c_board[i1 + c_board.size(0) * i] = b_board->BoardCoords[(i1
                      + b_board->BoardCoords.size(0) * i) +
                      b_board->BoardCoords.size(0) * b_board->BoardCoords.size(1)];
                  }
                }

                rot90(c_board, newBoardCoords2);
                cat(newBoardCoords1, newBoardCoords2, r);
                b_board->BoardCoords.set_size(r.size(0), r.size(1), 2);
                loop_ub = (r.size(0) * r.size(1)) << 1;
                for (i = 0; i < loop_ub; i++) {
                  b_board->BoardCoords[i] = r[i];
                }
              }

              newBoardCoords1.set_size(b_board->BoardIdx.size(0),
                b_board->BoardIdx.size(1));
              loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size(1);
              for (i = 0; i < loop_ub; i++) {
                newBoardCoords1[i] = b_board->BoardIdx[i];
              }

              if ((newBoardCoords1.size(0) == 0) && (newBoardCoords1.size(1) ==
                   0)) {
                t_rtErrorWithMessageID(s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
              }

              if ((newBoardCoords1.size(0) == 1) && (newBoardCoords1.size(1) !=
                   1)) {
                h_rtErrorWithMessageID(t_emlrtRTEI.fName, t_emlrtRTEI.lineNo);
              }

              y.set_size(1, newBoardCoords1.size(1));
              loop_ub = newBoardCoords1.size(1);
              for (i = 0; i < loop_ub; i++) {
                y[i] = true;
              }

              npages = newBoardCoords1.size(1);
              i2 = 0;
              if (newBoardCoords1.size(1) > 2147483646) {
                check_forloop_overflow_error();
              }

              for (i = 0; i < npages; i++) {
                loop_ub = i2 + newBoardCoords1.size(0);
                i1 = i2 + 1;
                i2 = loop_ub;
                if ((i1 <= loop_ub) && (loop_ub > 2147483646)) {
                  check_forloop_overflow_error();
                }

                exitg1 = false;
                while ((!exitg1) && (i1 <= loop_ub)) {
                  if (newBoardCoords1[i1 - 1] == 0.0) {
                    y[i] = false;
                    exitg1 = true;
                  } else {
                    i1++;
                  }
                }
              }

              if (::coder::internal::ifWhileCond(y)) {
                if (!isUpperLeftBlack(b_board, b_I)) {
                  c_board.set_size(b_board->BoardIdx.size(0),
                                   b_board->BoardIdx.size(1));
                  loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size(1)
                    - 1;
                  for (i = 0; i <= loop_ub; i++) {
                    c_board[i] = b_board->BoardIdx[i];
                  }

                  b_rot90(c_board, b_board->BoardIdx);
                  i = b_board->BoardCoords.size(2);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
                  }

                  c_board.set_size(b_board->BoardCoords.size(0),
                                   b_board->BoardCoords.size(1));
                  loop_ub = b_board->BoardCoords.size(1);
                  for (i = 0; i < loop_ub; i++) {
                    npages = b_board->BoardCoords.size(0);
                    for (i1 = 0; i1 < npages; i1++) {
                      c_board[i1 + c_board.size(0) * i] = b_board->
                        BoardCoords[i1 + b_board->BoardCoords.size(0) * i];
                    }
                  }

                  b_rot90(c_board, newBoardCoords1);
                  i = b_board->BoardCoords.size(2);
                  if (i < 2) {
                    rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
                  }

                  c_board.set_size(b_board->BoardCoords.size(0),
                                   b_board->BoardCoords.size(1));
                  loop_ub = b_board->BoardCoords.size(1);
                  for (i = 0; i < loop_ub; i++) {
                    npages = b_board->BoardCoords.size(0);
                    for (i1 = 0; i1 < npages; i1++) {
                      c_board[i1 + c_board.size(0) * i] = b_board->BoardCoords
                        [(i1 + b_board->BoardCoords.size(0) * i) +
                        b_board->BoardCoords.size(0) * b_board->BoardCoords.size
                        (1)];
                    }
                  }

                  b_rot90(c_board, newBoardCoords2);
                  cat(newBoardCoords1, newBoardCoords2, r);
                  b_board->BoardCoords.set_size(r.size(0), r.size(1), 2);
                  loop_ub = (r.size(0) * r.size(1)) << 1;
                  for (i = 0; i < loop_ub; i++) {
                    b_board->BoardCoords[i] = r[i];
                  }
                }
              } else {
                double cornerIdx[4];
                signed char ii_data;
                i = b_board->BoardIdx.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, ag_emlrtBCI);
                }

                i = b_board->BoardIdx.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, bg_emlrtBCI);
                }

                i = b_board->BoardIdx.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, cg_emlrtBCI);
                }

                i = b_board->BoardIdx.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, dg_emlrtBCI);
                }

                cornerIdx[0] = b_board->BoardIdx[0];
                i = b_board->BoardIdx.size(0);
                i1 = b_board->BoardIdx.size(0);
                if ((i1 < 1) || (i1 > i)) {
                  rtDynamicBoundsError(i1, 1, i, eg_emlrtBCI);
                }

                cornerIdx[1] = b_board->BoardIdx[i1 - 1];
                i = b_board->BoardIdx.size(0);
                i1 = b_board->BoardIdx.size(0);
                if ((i1 < 1) || (i1 > i)) {
                  rtDynamicBoundsError(i1, 1, i, fg_emlrtBCI);
                }

                i = b_board->BoardIdx.size(1);
                npages = b_board->BoardIdx.size(1);
                if ((npages < 1) || (npages > i)) {
                  rtDynamicBoundsError(npages, 1, i, fg_emlrtBCI);
                }

                cornerIdx[2] = b_board->BoardIdx[(i1 + b_board->BoardIdx.size(0)
                  * (npages - 1)) - 1];
                i = b_board->BoardIdx.size(1);
                i1 = b_board->BoardIdx.size(1);
                if ((i1 < 1) || (i1 > i)) {
                  rtDynamicBoundsError(i1, 1, i, gg_emlrtBCI);
                }

                cornerIdx[3] = b_board->BoardIdx[b_board->BoardIdx.size(0) * (i1
                  - 1)];
                npages = 0;
                loop_ub = 1;
                i2 = 0;
                exitg1 = false;
                while ((!exitg1) && (i2 < 4)) {
                  if (cornerIdx[i2] != 0.0) {
                    npages = 1;
                    ii_data = static_cast<signed char>(i2 + 1);
                    exitg1 = true;
                  } else {
                    i2++;
                  }
                }

                if (npages == 0) {
                  loop_ub = 0;
                }

                numRot_size[0] = 1;
                numRot_size[1] = loop_ub;
                for (i = 0; i < loop_ub; i++) {
                  numRot_data = static_cast<double>(ii_data) - 1.0;
                }

                if (loop_ub == 0) {
                  numRot_size[0] = 1;
                  numRot_size[1] = 1;
                  numRot_data = 0.0;
                }

                b_numRot_data = (numRot_data == 2.0);
                c_numRot_data.set(&b_numRot_data, 1, 1);
                if (::coder::internal::ifWhileCond(c_numRot_data)) {
                  c_board.set_size(b_board->BoardIdx.size(0),
                                   b_board->BoardIdx.size(1));
                  loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size(1)
                    - 1;
                  for (i = 0; i <= loop_ub; i++) {
                    c_board[i] = b_board->BoardIdx[i];
                  }

                  b_rot90(c_board, b_board->BoardIdx);
                  i = b_board->BoardCoords.size(2);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
                  }

                  c_board.set_size(b_board->BoardCoords.size(0),
                                   b_board->BoardCoords.size(1));
                  loop_ub = b_board->BoardCoords.size(1);
                  for (i = 0; i < loop_ub; i++) {
                    npages = b_board->BoardCoords.size(0);
                    for (i1 = 0; i1 < npages; i1++) {
                      c_board[i1 + c_board.size(0) * i] = b_board->
                        BoardCoords[i1 + b_board->BoardCoords.size(0) * i];
                    }
                  }

                  b_rot90(c_board, newBoardCoords1);
                  i = b_board->BoardCoords.size(2);
                  if (i < 2) {
                    rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
                  }

                  c_board.set_size(b_board->BoardCoords.size(0),
                                   b_board->BoardCoords.size(1));
                  loop_ub = b_board->BoardCoords.size(1);
                  for (i = 0; i < loop_ub; i++) {
                    npages = b_board->BoardCoords.size(0);
                    for (i1 = 0; i1 < npages; i1++) {
                      c_board[i1 + c_board.size(0) * i] = b_board->BoardCoords
                        [(i1 + b_board->BoardCoords.size(0) * i) +
                        b_board->BoardCoords.size(0) * b_board->BoardCoords.size
                        (1)];
                    }
                  }

                  b_rot90(c_board, newBoardCoords2);
                  cat(newBoardCoords1, newBoardCoords2, r);
                  b_board->BoardCoords.set_size(r.size(0), r.size(1), 2);
                  loop_ub = (r.size(0) * r.size(1)) << 1;
                  for (i = 0; i < loop_ub; i++) {
                    b_board->BoardCoords[i] = r[i];
                  }
                } else {
                  if (b_isequal((const double *)&numRot_data, numRot_size, 1.0))
                  {
                    i2 = 1;
                  } else if (b_isequal((const double *)&numRot_data, numRot_size,
                                       3.0)) {
                    i2 = 2;
                  } else {
                    i2 = 0;
                  }

                  if (i2 != 0) {
                    newBoardCoords1.set_size(b_board->BoardIdx.size(0),
                      b_board->BoardIdx.size(1));
                    loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size
                      (1);
                    for (i = 0; i < loop_ub; i++) {
                      newBoardCoords1[i] = b_board->BoardIdx[i];
                    }

                    flip(newBoardCoords1, static_cast<double>(i2));
                    b_board->BoardIdx.set_size(newBoardCoords1.size(0),
                      newBoardCoords1.size(1));
                    loop_ub = newBoardCoords1.size(0) * newBoardCoords1.size(1);
                    for (i = 0; i < loop_ub; i++) {
                      b_board->BoardIdx[i] = newBoardCoords1[i];
                    }

                    i = b_board->BoardCoords.size(2);
                    if (i < 1) {
                      rtDynamicBoundsError(1, 1, i, hg_emlrtBCI);
                    }

                    newBoardCoords1.set_size(b_board->BoardCoords.size(0),
                      b_board->BoardCoords.size(1));
                    loop_ub = b_board->BoardCoords.size(1);
                    for (i = 0; i < loop_ub; i++) {
                      npages = b_board->BoardCoords.size(0);
                      for (i1 = 0; i1 < npages; i1++) {
                        newBoardCoords1[i1 + newBoardCoords1.size(0) * i] =
                          b_board->BoardCoords[i1 + b_board->BoardCoords.size(0)
                          * i];
                      }
                    }

                    flip(newBoardCoords1, static_cast<double>(i2));
                    i = b_board->BoardCoords.size(2);
                    if (i < 2) {
                      rtDynamicBoundsError(2, 1, i, ig_emlrtBCI);
                    }

                    newBoardCoords2.set_size(b_board->BoardCoords.size(0),
                      b_board->BoardCoords.size(1));
                    loop_ub = b_board->BoardCoords.size(1);
                    for (i = 0; i < loop_ub; i++) {
                      npages = b_board->BoardCoords.size(0);
                      for (i1 = 0; i1 < npages; i1++) {
                        newBoardCoords2[i1 + newBoardCoords2.size(0) * i] =
                          b_board->BoardCoords[(i1 + b_board->BoardCoords.size(0)
                          * i) + b_board->BoardCoords.size(0) *
                          b_board->BoardCoords.size(1)];
                      }
                    }

                    flip(newBoardCoords2, static_cast<double>(i2));
                    cat(newBoardCoords1, newBoardCoords2, r);
                    b_board->BoardCoords.set_size(r.size(0), r.size(1), 2);
                    loop_ub = (r.size(0) * r.size(1)) << 1;
                    for (i = 0; i < loop_ub; i++) {
                      b_board->BoardCoords[i] = r[i];
                    }
                  }
                }
              }

              npages = b_board->BoardCoords.size(0);
              i2 = b_board->BoardCoords.size(1);
              if (npages == 0) {
                npages = 0;
              } else {
                npages = static_cast<int>(std::fmod(static_cast<double>(npages),
                  2.0));
              }

              if (i2 == 0) {
                loop_ub = 0;
              } else {
                loop_ub = static_cast<int>(std::fmod(static_cast<double>(i2),
                  2.0));
              }

              if ((npages == 0.0) == (loop_ub == 0.0)) {
                bool b_y;
                i = b_board->BoardCoords.size(0);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, sf_emlrtBCI);
                }

                i = b_board->BoardCoords.size(1);
                if (i < 1) {
                  rtDynamicBoundsError(1, 1, i, tf_emlrtBCI);
                }

                r1.set_size(1, 1, b_board->BoardCoords.size(2));
                loop_ub = b_board->BoardCoords.size(2);
                for (i = 0; i < loop_ub; i++) {
                  r1[i] = b_board->BoardCoords[b_board->BoardCoords.size(0) *
                    b_board->BoardCoords.size(1) * i];
                }

                i = b_board->BoardCoords.size(0);
                npages = b_board->BoardCoords.size(0);
                if ((npages < 1) || (npages > i)) {
                  rtDynamicBoundsError(npages, 1, i, uf_emlrtBCI);
                }

                i = b_board->BoardCoords.size(1);
                i2 = b_board->BoardCoords.size(1);
                if ((i2 < 1) || (i2 > i)) {
                  rtDynamicBoundsError(i2, 1, i, vf_emlrtBCI);
                }

                r2.set_size(1, 1, b_board->BoardCoords.size(2));
                loop_ub = b_board->BoardCoords.size(2);
                for (i = 0; i < loop_ub; i++) {
                  r2[i] = b_board->BoardCoords[((npages +
                    b_board->BoardCoords.size(0) * (i2 - 1)) +
                    b_board->BoardCoords.size(0) * b_board->BoardCoords.size(1) *
                    i) - 1];
                }

                if (r1.size(2) != r2.size(2)) {
                  rtSizeEqNDCheck(r1.size(), r2.size(), lb_emlrtECI);
                }

                b_x.set_size(1, 1, r1.size(2));
                loop_ub = r1.size(2);
                for (i = 0; i < loop_ub; i++) {
                  b_x[i] = (r1[i] > r2[i]);
                }

                b_y = false;
                if (b_x.size(2) > 2147483646) {
                  check_forloop_overflow_error();
                }

                npages = 1;
                exitg1 = false;
                while ((!exitg1) && (npages <= b_x.size(2))) {
                  if (b_x[npages - 1]) {
                    b_y = true;
                    exitg1 = true;
                  } else {
                    npages++;
                  }
                }

                if (b_y) {
                  i = b_board->BoardCoords.size(2);
                  if (i < 1) {
                    rtDynamicBoundsError(1, 1, i, wf_emlrtBCI);
                  }

                  i = b_board->BoardCoords.size(0);
                  i1 = b_board->BoardCoords.size(0);
                  if ((i1 < 1) || (i1 > i)) {
                    rtDynamicBoundsError(i1, 1, i, xf_emlrtBCI);
                  }

                  i = b_board->BoardCoords.size(1);
                  npages = b_board->BoardCoords.size(1);
                  if ((npages < 1) || (npages > i)) {
                    rtDynamicBoundsError(npages, 1, i, yf_emlrtBCI);
                  }

                  numRot_data = b_board->BoardCoords[(i1 +
                    b_board->BoardCoords.size(0) * (npages - 1)) - 1];
                  if (std::isnan(numRot_data)) {
                    s_rtErrorWithMessageID(r_emlrtRTEI.fName, r_emlrtRTEI.lineNo);
                  }

                  if (numRot_data != 0.0) {
                    c_board.set_size(b_board->BoardIdx.size(0),
                                     b_board->BoardIdx.size(1));
                    loop_ub = b_board->BoardIdx.size(0) * b_board->BoardIdx.size
                      (1) - 1;
                    for (i = 0; i <= loop_ub; i++) {
                      c_board[i] = b_board->BoardIdx[i];
                    }

                    b_rot90(c_board, b_board->BoardIdx);
                    i = b_board->BoardCoords.size(2);
                    if (i < 1) {
                      rtDynamicBoundsError(1, 1, i, rf_emlrtBCI);
                    }

                    c_board.set_size(b_board->BoardCoords.size(0),
                                     b_board->BoardCoords.size(1));
                    loop_ub = b_board->BoardCoords.size(1);
                    for (i = 0; i < loop_ub; i++) {
                      npages = b_board->BoardCoords.size(0);
                      for (i1 = 0; i1 < npages; i1++) {
                        c_board[i1 + c_board.size(0) * i] = b_board->
                          BoardCoords[i1 + b_board->BoardCoords.size(0) * i];
                      }
                    }

                    b_rot90(c_board, newBoardCoords1);
                    i = b_board->BoardCoords.size(2);
                    if (i < 2) {
                      rtDynamicBoundsError(2, 1, i, qf_emlrtBCI);
                    }

                    c_board.set_size(b_board->BoardCoords.size(0),
                                     b_board->BoardCoords.size(1));
                    loop_ub = b_board->BoardCoords.size(1);
                    for (i = 0; i < loop_ub; i++) {
                      npages = b_board->BoardCoords.size(0);
                      for (i1 = 0; i1 < npages; i1++) {
                        c_board[i1 + c_board.size(0) * i] = b_board->
                          BoardCoords[(i1 + b_board->BoardCoords.size(0) * i) +
                          b_board->BoardCoords.size(0) *
                          b_board->BoardCoords.size(1)];
                      }
                    }

                    b_rot90(c_board, newBoardCoords2);
                    cat(newBoardCoords1, newBoardCoords2, r);
                    b_board->BoardCoords.set_size(r.size(0), r.size(1), 2);
                    loop_ub = (r.size(0) * r.size(1)) << 1;
                    for (i = 0; i < loop_ub; i++) {
                      b_board->BoardCoords[i] = r[i];
                    }
                  }
                }
              }
            }

            return b_board;
          }

          //
          // Arguments    : double b_X[4]
          //                double Y[4]
          //                double height
          //                double width
          //                ::coder::array<bool, 2U> &mask
          // Return Type  : void
          //
          static void poly2RectMask(double b_X[4], double Y[4], double height,
            double width, ::coder::array<bool, 2U> &mask)
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              360,                     // lineNo
              13,                      // colNo
              "",                      // aName
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              360,                     // lineNo
              16,                      // colNo
              "",                      // aName
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              360,                     // lineNo
              6,                       // colNo
              "",                      // aName
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              360,                     // lineNo
              9,                       // colNo
              "",                      // aName
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 360,// lineNo
              13,                      // colNo
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 360,// lineNo
              16,                      // colNo
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 360,// lineNo
              6,                       // colNo
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 360,// lineNo
              9,                       // colNo
              "poly2RectMask",         // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            int i;
            int i1;
            int i2;
            int i3;
            int loop_ub;
            int unnamed_idx_0;
            ::coder::internal::sort(b_X);
            ::coder::internal::sort(Y);
            mask.set_size(static_cast<int>(height), static_cast<int>(width));
            loop_ub = static_cast<int>(height) * static_cast<int>(width);
            for (i = 0; i < loop_ub; i++) {
              mask[i] = false;
            }

            if (Y[1] > Y[2]) {
              i = 0;
              i1 = 0;
            } else {
              if (Y[1] != static_cast<int>(std::floor(Y[1]))) {
                rtIntegerError(Y[1], i_emlrtDCI);
              }

              if ((static_cast<int>(Y[1]) < 1) || (static_cast<int>(Y[1]) >
                   static_cast<int>(height))) {
                rtDynamicBoundsError(static_cast<int>(Y[1]), 1, static_cast<int>
                                     (height), sf_emlrtBCI);
              }

              i = static_cast<int>(Y[1]) - 1;
              if (Y[2] != static_cast<int>(std::floor(Y[2]))) {
                rtIntegerError(Y[2], j_emlrtDCI);
              }

              if ((static_cast<int>(Y[2]) < 1) || (static_cast<int>(Y[2]) >
                   static_cast<int>(height))) {
                rtDynamicBoundsError(static_cast<int>(Y[2]), 1, static_cast<int>
                                     (height), tf_emlrtBCI);
              }

              i1 = static_cast<int>(Y[2]);
            }

            if (b_X[1] > b_X[2]) {
              i2 = 0;
              i3 = 0;
            } else {
              if (b_X[1] != static_cast<int>(std::floor(b_X[1]))) {
                rtIntegerError(b_X[1], g_emlrtDCI);
              }

              if ((static_cast<int>(b_X[1]) < 1) || (static_cast<int>(b_X[1]) >
                   static_cast<int>(width))) {
                rtDynamicBoundsError(static_cast<int>(b_X[1]), 1, static_cast<
                                     int>(width), qf_emlrtBCI);
              }

              i2 = static_cast<int>(b_X[1]) - 1;
              if (b_X[2] != static_cast<int>(std::floor(b_X[2]))) {
                rtIntegerError(b_X[2], h_emlrtDCI);
              }

              if ((static_cast<int>(b_X[2]) < 1) || (static_cast<int>(b_X[2]) >
                   static_cast<int>(width))) {
                rtDynamicBoundsError(static_cast<int>(b_X[2]), 1, static_cast<
                                     int>(width), rf_emlrtBCI);
              }

              i3 = static_cast<int>(b_X[2]);
            }

            unnamed_idx_0 = i1 - i;
            loop_ub = i3 - i2;
            for (i1 = 0; i1 < loop_ub; i1++) {
              for (i3 = 0; i3 < unnamed_idx_0; i3++) {
                mask[(i + i3) + mask.size(0) * (i2 + i1)] = true;
              }
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &b_I
          //                ::coder::array<float, 2U> &cxy
          //                ::coder::array<float, 2U> &c45
          //                ::coder::array<float, 2U> &Ix
          //                ::coder::array<float, 2U> &Iy
          //                ::coder::array<float, 2U> &Ixy
          //                ::coder::array<float, 2U> &I_45_45
          // Return Type  : void
          //
          static void secondDerivCornerMetric(const ::coder::array<float, 2U>
            &b_I, ::coder::array<float, 2U> &cxy, ::coder::array<float, 2U> &c45,
            ::coder::array<float, 2U> &Ix, ::coder::array<float, 2U> &Iy, ::
            coder::array<float, 2U> &Ixy, ::coder::array<float, 2U> &I_45_45)
          {
            static const double dv[15]{ 0.00043640742603817326,
              0.0022162597803590169, 0.0087654774692430167, 0.026999571389573731,
              0.064768604754149334, 0.12100368400046491, 0.17605932135785024,
              0.19950134764464325, 0.17605932135785024, 0.12100368400046491,
              0.064768604754149334, 0.026999571389573731, 0.0087654774692430167,
              0.0022162597803590169, 0.00043640742603818741 };

            static const double dv1[15]{ 0.00043640742603817315,
              0.0022162597803590169, 0.0087654774692430184, 0.026999571389573731,
              0.064768604754149334, 0.12100368400046491, 0.17605932135785024,
              0.19950134764464325, 0.17605932135785024, 0.12100368400046491,
              0.064768604754149334, 0.026999571389573731, 0.0087654774692430184,
              0.0022162597803590156, 0.00043640742603817309 };

            array<double, 2U> b;
            array<double, 2U> b_a;
            array<double, 2U> b_b;
            array<float, 2U> I_45;
            array<float, 2U> I_n45;
            array<float, 2U> a;
            array<float, 2U> r;
            double finalSize[2];
            double pad[2];
            int b_loop_ub_tmp;
            int c_loop_ub_tmp;
            int d_loop_ub_tmp;
            int loop_ub_tmp;
            int nx;
            finalSize[0] = b_I.size(0);
            pad[0] = 7.0;
            finalSize[1] = b_I.size(1);
            pad[1] = 7.0;
            if ((b_I.size(0) == 0) || (b_I.size(1) == 0)) {
              Ix.set_size(b_I.size(0), b_I.size(1));
              nx = b_I.size(0) * b_I.size(1);
              for (int i{0}; i < nx; i++) {
                Ix[i] = b_I[i];
              }
            } else {
              padImage_outSize(b_I, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              conv2_separable_valid(dv, dv1, b_a, finalSize, b);
              Ix.set_size(b.size(0), b.size(1));
              nx = b.size(0) * b.size(1);
              for (int i{0}; i < nx; i++) {
                Ix[i] = static_cast<float>(b[i]);
              }
            }

            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((Ix.size(0) == 0) || (Ix.size(1) == 0)) {
              Iy.set_size(Ix.size(0), Ix.size(1));
              nx = Ix.size(0) * Ix.size(1);
              for (int i{0}; i < nx; i++) {
                Iy[i] = Ix[i];
              }
            } else {
              padImage_outSize(Ix, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              Iy.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                Iy[i] = static_cast<float>(b_b[i]);
              }
            }

            imfilter(Ix);
            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((Ix.size(0) == 0) || (Ix.size(1) == 0)) {
              Ixy.set_size(Ix.size(0), Ix.size(1));
              nx = Ix.size(0) * Ix.size(1);
              for (int i{0}; i < nx; i++) {
                Ixy[i] = Ix[i];
              }
            } else {
              padImage_outSize(Ix, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              Ixy.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                Ixy[i] = static_cast<float>(b_b[i]);
              }
            }

            I_n45.set_size(Ix.size(0), Ix.size(1));
            loop_ub_tmp = Ix.size(0) * Ix.size(1);
            for (int i{0}; i < loop_ub_tmp; i++) {
              I_n45[i] = Ix[i] * 0.707106769F;
            }

            I_45.set_size(Iy.size(0), Iy.size(1));
            b_loop_ub_tmp = Iy.size(0) * Iy.size(1);
            for (int i{0}; i < b_loop_ub_tmp; i++) {
              I_45[i] = Iy[i] * 0.707106769F;
            }

            if ((I_n45.size(0) != I_45.size(0)) && ((I_n45.size(0) != 1) &&
                 (I_45.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(0), I_45.size(0), emlrtECI);
            }

            if ((I_n45.size(1) != I_45.size(1)) && ((I_n45.size(1) != 1) &&
                 (I_45.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(1), I_45.size(1),
                b_emlrtECI);
            }

            if ((I_n45.size(0) == I_45.size(0)) && (I_n45.size(1) == I_45.size(1)))
            {
              I_45.set_size(I_n45.size(0), I_n45.size(1));
              for (int i{0}; i < loop_ub_tmp; i++) {
                I_45[i] = I_n45[i] + I_45[i];
              }
            } else {
              b_plus(I_45, I_n45);
            }

            r.set_size(Iy.size(0), Iy.size(1));
            for (int i{0}; i < b_loop_ub_tmp; i++) {
              r[i] = Iy[i] * -0.707106769F;
            }

            if ((I_n45.size(0) != r.size(0)) && ((I_n45.size(0) != 1) && (r.size
                  (0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(0), r.size(0), c_emlrtECI);
            }

            if ((I_n45.size(1) != r.size(1)) && ((I_n45.size(1) != 1) && (r.size
                  (1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_n45.size(1), r.size(1), d_emlrtECI);
            }

            if ((I_n45.size(0) == r.size(0)) && (I_n45.size(1) == r.size(1))) {
              nx = I_n45.size(0) * I_n45.size(1);
              for (int i{0}; i < nx; i++) {
                I_n45[i] = I_n45[i] + r[i];
              }
            } else {
              plus(I_n45, r);
            }

            I_45_45.set_size(I_45.size(0), I_45.size(1));
            c_loop_ub_tmp = I_45.size(0) * I_45.size(1);
            for (int i{0}; i < c_loop_ub_tmp; i++) {
              I_45_45[i] = I_45[i];
            }

            imfilter(I_45_45);
            pad[0] = 1.0;
            pad[1] = 0.0;
            if ((I_45.size(0) == 0) || (I_45.size(1) == 0)) {
              a.set_size(I_45.size(0), I_45.size(1));
              for (int i{0}; i < c_loop_ub_tmp; i++) {
                a[i] = I_45[i];
              }
            } else {
              padImage_outSize(I_45, pad, a);
              b_a.set_size(a.size(0), a.size(1));
              nx = a.size(0) * a.size(1);
              for (int i{0}; i < nx; i++) {
                b_a[i] = a[i];
              }

              ::coder::internal::conv2AXPYValidCMP(b_a, b_b);
              a.set_size(b_b.size(0), b_b.size(1));
              nx = b_b.size(0) * b_b.size(1);
              for (int i{0}; i < nx; i++) {
                a[i] = static_cast<float>(b_b[i]);
              }
            }

            nx = I_45_45.size(0) * I_45_45.size(1);
            for (int i{0}; i < nx; i++) {
              I_45_45[i] = I_45_45[i] * 0.707106769F;
            }

            d_loop_ub_tmp = a.size(0) * a.size(1);
            for (int i{0}; i < d_loop_ub_tmp; i++) {
              a[i] = a[i] * -0.707106769F;
            }

            if ((I_45_45.size(0) != a.size(0)) && ((I_45_45.size(0) != 1) &&
                 (a.size(0) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_45_45.size(0), a.size(0), e_emlrtECI);
            }

            if ((I_45_45.size(1) != a.size(1)) && ((I_45_45.size(1) != 1) &&
                 (a.size(1) != 1))) {
              emlrtDimSizeImpxCheckR2021b(I_45_45.size(1), a.size(1), f_emlrtECI);
            }

            if ((I_45_45.size(0) == a.size(0)) && (I_45_45.size(1) == a.size(1)))
            {
              for (int i{0}; i < nx; i++) {
                I_45_45[i] = I_45_45[i] + a[i];
              }
            } else {
              plus(I_45_45, a);
            }

            r.set_size(I_45.size(0), I_45.size(1));
            if (c_loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < c_loop_ub_tmp; d_loop_ub_tmp
                 ++) {
              r[d_loop_ub_tmp] = std::abs(I_45[d_loop_ub_tmp]);
            }

            nx = I_n45.size(0) * I_n45.size(1);
            a.set_size(I_n45.size(0), I_n45.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              a[d_loop_ub_tmp] = std::abs(I_n45[d_loop_ub_tmp]);
            }

            if ((r.size(0) != a.size(0)) && ((r.size(0) != 1) && (a.size(0) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(0), a.size(0), g_emlrtECI);
            }

            if ((r.size(1) != a.size(1)) && ((r.size(1) != 1) && (a.size(1) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(1), a.size(1), h_emlrtECI);
            }

            nx = Ixy.size(0) * Ixy.size(1);
            cxy.set_size(Ixy.size(0), Ixy.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              cxy[d_loop_ub_tmp] = std::abs(Ixy[d_loop_ub_tmp]);
            }

            c_loop_ub_tmp = cxy.size(0) * cxy.size(1);
            for (int i{0}; i < c_loop_ub_tmp; i++) {
              cxy[i] = 4.0F * cxy[i];
            }

            if ((r.size(0) == a.size(0)) && (r.size(1) == a.size(1))) {
              nx = r.size(0) * r.size(1);
              for (int i{0}; i < nx; i++) {
                r[i] = 3.0F * (r[i] + a[i]);
              }
            } else {
              binary_expand_op(r, a);
            }

            if ((cxy.size(0) != r.size(0)) && ((cxy.size(0) != 1) && (r.size(0)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(cxy.size(0), r.size(0), i_emlrtECI);
            }

            if ((cxy.size(1) != r.size(1)) && ((cxy.size(1) != 1) && (r.size(1)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(cxy.size(1), r.size(1), j_emlrtECI);
            }

            if ((cxy.size(0) == r.size(0)) && (cxy.size(1) == r.size(1))) {
              for (int i{0}; i < c_loop_ub_tmp; i++) {
                cxy[i] = cxy[i] - r[i];
              }
            } else {
              minus(cxy, r);
            }

            nx = cxy.size(0) * cxy.size(1) - 1;
            for (d_loop_ub_tmp = 0; d_loop_ub_tmp <= nx; d_loop_ub_tmp++) {
              if (cxy[d_loop_ub_tmp] < 0.0F) {
                if (d_loop_ub_tmp > nx) {
                  rtDynamicBoundsError(d_loop_ub_tmp, 0, nx, j_emlrtBCI);
                }

                cxy[d_loop_ub_tmp] = 0.0F;
              }
            }

            r.set_size(Ix.size(0), Ix.size(1));
            if (loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < loop_ub_tmp; d_loop_ub_tmp++)
            {
              r[d_loop_ub_tmp] = std::abs(Ix[d_loop_ub_tmp]);
            }

            a.set_size(Iy.size(0), Iy.size(1));
            if (b_loop_ub_tmp > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < b_loop_ub_tmp; d_loop_ub_tmp
                 ++) {
              a[d_loop_ub_tmp] = std::abs(Iy[d_loop_ub_tmp]);
            }

            if ((r.size(0) != a.size(0)) && ((r.size(0) != 1) && (a.size(0) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(0), a.size(0), k_emlrtECI);
            }

            if ((r.size(1) != a.size(1)) && ((r.size(1) != 1) && (a.size(1) != 1)))
            {
              emlrtDimSizeImpxCheckR2021b(r.size(1), a.size(1), l_emlrtECI);
            }

            nx = I_45_45.size(0) * I_45_45.size(1);
            c45.set_size(I_45_45.size(0), I_45_45.size(1));
            if (nx > 2147483646) {
              check_forloop_overflow_error();
            }

            for (d_loop_ub_tmp = 0; d_loop_ub_tmp < nx; d_loop_ub_tmp++) {
              c45[d_loop_ub_tmp] = std::abs(I_45_45[d_loop_ub_tmp]);
            }

            loop_ub_tmp = c45.size(0) * c45.size(1);
            for (int i{0}; i < loop_ub_tmp; i++) {
              c45[i] = 4.0F * c45[i];
            }

            if ((r.size(0) == a.size(0)) && (r.size(1) == a.size(1))) {
              nx = r.size(0) * r.size(1);
              for (int i{0}; i < nx; i++) {
                r[i] = 3.0F * (r[i] + a[i]);
              }
            } else {
              binary_expand_op(r, a);
            }

            if ((c45.size(0) != r.size(0)) && ((c45.size(0) != 1) && (r.size(0)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(c45.size(0), r.size(0), m_emlrtECI);
            }

            if ((c45.size(1) != r.size(1)) && ((c45.size(1) != 1) && (r.size(1)
                  != 1))) {
              emlrtDimSizeImpxCheckR2021b(c45.size(1), r.size(1), n_emlrtECI);
            }

            if ((c45.size(0) == r.size(0)) && (c45.size(1) == r.size(1))) {
              for (int i{0}; i < loop_ub_tmp; i++) {
                c45[i] = c45[i] - r[i];
              }
            } else {
              minus(c45, r);
            }

            nx = c45.size(0) * c45.size(1) - 1;
            for (d_loop_ub_tmp = 0; d_loop_ub_tmp <= nx; d_loop_ub_tmp++) {
              if (c45[d_loop_ub_tmp] < 0.0F) {
                if (d_loop_ub_tmp > nx) {
                  rtDynamicBoundsError(d_loop_ub_tmp, 0, nx, k_emlrtBCI);
                }

                c45[d_loop_ub_tmp] = 0.0F;
              }
            }
          }

          //
          // Arguments    : const ::coder::array<float, 2U> &metric
          //                ::coder::array<double, 2U> &loc
          // Return Type  : void
          //
          static void subPixelLocation(const ::coder::array<float, 2U> &metric, ::
            coder::array<double, 2U> &loc)
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              9,                       // lineNo
              9,                       // colNo
              "",                      // aName
              "subPixelLocation",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              31,                      // lineNo
              16,                      // colNo
              "",                      // aName
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo sf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              31,                      // lineNo
              37,                      // colNo
              "",                      // aName
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo tf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              30,                      // lineNo
              16,                      // colNo
              "",                      // aName
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo uf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              30,                      // lineNo
              37,                      // colNo
              "",                      // aName
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 31,// lineNo
              16,                      // colNo
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 31,// lineNo
              37,                      // colNo
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo i_emlrtDCI{ 30,// lineNo
              16,                      // colNo
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo j_emlrtDCI{ 30,// lineNo
              37,                      // colNo
              "subPixelLocationImpl",  // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              9,                       // lineNo
              5,                       // colNo
              "subPixelLocation",      // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/subPixelLocation.m"// pName
            };

            array<float, 2U> b_metric;
            array<bool, 1U> b_loc_data;
            int iv[2];
            int tmp_size[2];
            int i;
            bool loc_data[2];
            i = loc.size(0);
            if (i - 1 >= 0) {
              tmp_size[0] = 1;
              tmp_size[1] = 2;
              iv[0] = 1;
              iv[1] = 2;
            }

            for (int id{0}; id < i; id++) {
              float x;
              float y;
              int i1;
              i1 = loc.size(0);
              if (id + 1 > i1) {
                rtDynamicBoundsError(id + 1, 1, i1, qf_emlrtBCI);
              }

              loc_data[0] = (loc[id] < 3.0);
              loc_data[1] = (loc[id + loc.size(0)] < 3.0);
              b_loc_data.set(&loc_data[0], 2);
              if (any(b_loc_data) || (loc[id] > (static_cast<double>(metric.size
                     (1)) - 2.0) - 1.0) || (loc[id + loc.size(0)] > (
                    static_cast<double>(metric.size(0)) - 2.0) - 1.0)) {
                x = static_cast<float>(loc[id]);
                y = static_cast<float>(loc[id + loc.size(0)]);
              } else {
                double d;
                float beta[6];
                int b_loop_ub;
                int i2;
                int i3;
                int i4;
                int loop_ub;
                if (loc[id + loc.size(0)] - 2.0 > loc[id + loc.size(0)] + 2.0) {
                  i1 = 0;
                  i2 = 0;
                } else {
                  d = loc[id + loc.size(0)] - 2.0;
                  if (d != static_cast<int>(std::floor(d))) {
                    rtIntegerError(d, i_emlrtDCI);
                  }

                  if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                       metric.size(0))) {
                    rtDynamicBoundsError(static_cast<int>(d), 1, metric.size(0),
                                         tf_emlrtBCI);
                  }

                  i1 = static_cast<int>(d) - 1;
                  d = loc[id + loc.size(0)] + 2.0;
                  if (d != static_cast<int>(std::floor(d))) {
                    rtIntegerError(d, j_emlrtDCI);
                  }

                  if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                       metric.size(0))) {
                    rtDynamicBoundsError(static_cast<int>(d), 1, metric.size(0),
                                         uf_emlrtBCI);
                  }

                  i2 = static_cast<int>(d);
                }

                if (loc[id] - 2.0 > loc[id] + 2.0) {
                  i3 = 0;
                  i4 = 0;
                } else {
                  d = loc[id] - 2.0;
                  if (d != static_cast<int>(std::floor(d))) {
                    rtIntegerError(d, g_emlrtDCI);
                  }

                  if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                       metric.size(1))) {
                    rtDynamicBoundsError(static_cast<int>(d), 1, metric.size(1),
                                         rf_emlrtBCI);
                  }

                  i3 = static_cast<int>(d) - 1;
                  d = loc[id] + 2.0;
                  if (d != static_cast<int>(std::floor(d))) {
                    rtIntegerError(d, h_emlrtDCI);
                  }

                  if ((static_cast<int>(d) < 1) || (static_cast<int>(d) >
                       metric.size(1))) {
                    rtDynamicBoundsError(static_cast<int>(d), 1, metric.size(1),
                                         sf_emlrtBCI);
                  }

                  i4 = static_cast<int>(d);
                }

                loop_ub = i2 - i1;
                b_loop_ub = i4 - i3;
                i2 = loop_ub * b_loop_ub;
                if (i2 != 25) {
                  if (i2 == 1) {
                    k_rtErrorWithMessageID(i_emlrtRTEI.fName, i_emlrtRTEI.lineNo);
                  } else {
                    l_rtErrorWithMessageID(j_emlrtRTEI.fName, j_emlrtRTEI.lineNo);
                  }
                }

                b_metric.set_size(loop_ub, b_loop_ub);
                for (i2 = 0; i2 < b_loop_ub; i2++) {
                  for (i4 = 0; i4 < loop_ub; i4++) {
                    b_metric[i4 + b_metric.size(0) * i2] = metric[(i1 + i4) +
                      metric.size(0) * (i3 + i2)];
                  }
                }

                for (i1 = 0; i1 < 6; i1++) {
                  y = 0.0F;
                  for (i2 = 0; i2 < 25; i2++) {
                    y += static_cast<float>(X[i1 + 6 * i2]) * b_metric[i2];
                  }

                  beta[i1] = y;
                }

                y = 4.0F * beta[0] * beta[1] - beta[4] * beta[4];
                x = -(2.0F * beta[1] * beta[2] - beta[3] * beta[4]) / y;
                y = -(2.0F * beta[0] * beta[3] - beta[2] * beta[4]) / y;
                if (std::isinf(x) || std::isnan(x) || (std::abs(x) > 2.0F) ||
                    (std::isinf(y) || std::isnan(y)) || (std::abs(y) > 2.0F)) {
                  x = 0.0F;
                  y = 0.0F;
                }

                x += static_cast<float>(loc[id]);
                y += static_cast<float>(loc[id + loc.size(0)]);
              }

              rtSubAssignSizeCheck(&iv[0], 2, &tmp_size[0], 2, lb_emlrtECI);
              loc[id] = x;
              loc[id + loc.size(0)] = y;
            }
          }

          //
          // Arguments    : const Checkerboard *b_this
          //                ::coder::array<double, 2U> &points
          //                double boardSize[2]
          // Return Type  : void
          //
          static void toPoints(const Checkerboard *b_this, ::coder::array<double,
                               2U> &points, double boardSize[2])
          {
            static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              235,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtBoundsCheckInfo rf_emlrtBCI{ -1,// iFirst
              -1,                      // iLast
              237,                     // lineNo
              28,                      // colNo
              "",                      // aName
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              0                        // checkKind
            };

            static rtDoubleCheckInfo g_emlrtDCI{ 234,// lineNo
              16,                      // colNo
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            static rtDoubleCheckInfo h_emlrtDCI{ 234,// lineNo
              1,                       // colNo
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m",// pName
              1                        // checkKind
            };

            static rtEqualityCheckInfo lb_emlrtECI{ -1,// nDims
              236,                     // lineNo
              1,                       // colNo
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m"// pName
            };

            static rtEqualityCheckInfo mb_emlrtECI{ -1,// nDims
              238,                     // lineNo
              1,                       // colNo
              "toPoints",              // fName
              "/usr/local/MATLAB/R2023a/toolbox/vision/vision/+vision/+internal/+calibration/+checkerboard/detectCheckerboard.m"// pName
            };

            array<double, 2U> x;
            array<bool, 1U> d_this;
            double numPoints;
            int b_loop_ub;
            int c_this;
            int i;
            int i1;
            int loop_ub;
            c_this = b_this->BoardIdx.size(0) * b_this->BoardIdx.size(1);
            d_this.set_size(c_this);
            for (i = 0; i < c_this; i++) {
              d_this[i] = (b_this->BoardIdx[i] == 0.0);
            }

            any(d_this);
            numPoints = static_cast<double>(b_this->BoardCoords.size(0)) *
              static_cast<double>(b_this->BoardCoords.size(1));
            if (numPoints != static_cast<int>(numPoints)) {
              rtIntegerError(numPoints, g_emlrtDCI);
            }

            i = static_cast<int>(numPoints);
            points.set_size(static_cast<int>(numPoints), 2);
            if (numPoints != static_cast<int>(numPoints)) {
              rtIntegerError(numPoints, h_emlrtDCI);
            }

            loop_ub = static_cast<int>(numPoints) << 1;
            for (i1 = 0; i1 < loop_ub; i1++) {
              points[i1] = 0.0;
            }

            i1 = b_this->BoardCoords.size(2);
            if (i1 < 1) {
              rtDynamicBoundsError(1, 1, i1, qf_emlrtBCI);
            }

            x.set_size(b_this->BoardCoords.size(1), b_this->BoardCoords.size(0));
            loop_ub = b_this->BoardCoords.size(0);
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_loop_ub = b_this->BoardCoords.size(1);
              for (c_this = 0; c_this < b_loop_ub; c_this++) {
                x[c_this + x.size(0) * i1] = b_this->BoardCoords[i1 +
                  b_this->BoardCoords.size(0) * c_this];
              }
            }

            c_this = x.size(0) * x.size(1);
            rtSubAssignSizeCheck(&i, 1, &c_this, 1, lb_emlrtECI);
            for (i = 0; i < c_this; i++) {
              points[i] = x[i];
            }

            i = b_this->BoardCoords.size(2);
            if (i < 2) {
              rtDynamicBoundsError(2, 1, i, rf_emlrtBCI);
            }

            x.set_size(b_this->BoardCoords.size(1), b_this->BoardCoords.size(0));
            loop_ub = b_this->BoardCoords.size(0);
            for (i = 0; i < loop_ub; i++) {
              b_loop_ub = b_this->BoardCoords.size(1);
              for (i1 = 0; i1 < b_loop_ub; i1++) {
                x[i1 + x.size(0) * i] = b_this->BoardCoords[(i +
                  b_this->BoardCoords.size(0) * i1) + b_this->BoardCoords.size(0)
                  * b_this->BoardCoords.size(1)];
              }
            }

            rtSubAssignSizeCheck(points.size(), 1, &c_this, 1, mb_emlrtECI);
            for (i = 0; i < c_this; i++) {
              points[i + points.size(0)] = x[i];
            }

            boardSize[0] = static_cast<unsigned int>(b_this->BoardCoords.size(1))
              + 1U;
            boardSize[1] = static_cast<unsigned int>(b_this->BoardCoords.size(0))
              + 1U;
          }

          //
          // Arguments    : coder::array<bool, 2U> &in1
          //                const coder::array<bool, 2U> &in2
          // Return Type  : void
          //
        }
      }
    }
  }
}

static void d_and(coder::array<bool, 2U> &in1, const coder::array<bool, 2U> &in2)
{
  coder::array<bool, 2U> b_in2;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  if (in1.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in1.size(1);
  }

  b_in2.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0 = (in1.size(0) != 1);
  stride_1_1 = (in1.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in2[i1 + b_in2.size(0) * i] = (in2[i1 * stride_0_0 + in2.size(0) *
        aux_0_1] && in1[i1 * stride_1_0 + in1.size(0) * aux_1_1]);
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(b_in2.size(0), b_in2.size(1));
  loop_ub = b_in2.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = b_in2.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in2[i1 + b_in2.size(0) * i];
    }
  }
}

//
// Arguments    : coder::vision::internal::calibration::checkerboard::Checkerboard *in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 1U> &in3
//                const coder::array<float, 2U> &in4
//                const coder::array<float, 2U> &in5
// Return Type  : void
//
static void d_binary_expand_op(coder::vision::internal::calibration::
  checkerboard::Checkerboard *in1, const coder::array<float, 2U> &in2, const
  coder::array<float, 1U> &in3, const coder::array<float, 2U> &in4, const coder::
  array<float, 2U> &in5)
{
  coder::array<float, 2U> b_in4;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  if (in5.size(1) == 1) {
    loop_ub = in4.size(1);
  } else {
    loop_ub = in5.size(1);
  }

  b_in4.set_size(1, loop_ub);
  stride_0_1 = (in4.size(1) != 1);
  stride_1_1 = (in5.size(1) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in4[i] = in4[i * stride_0_1] + in5[i * stride_1_1];
  }

  in1->BoardIdx[0] = in1->findNeighbor(in2, in3, b_in4);
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void d_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "If the working dimension of MAX or MIN is variable in length, it must not have zero length at runtime.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *r
//                const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void d_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Domain error. To compute complex results from real x, use \'")
    << r) << "(complex(x))\'.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : int numerator
//                int denominator
// Return Type  : int
//
static int div_s32(int numerator, int denominator)
{
  int quotient;
  if (denominator == 0) {
    rtDivisionByZeroErrorN();
  } else {
    unsigned int tempAbsQuotient;
    unsigned int u;
    if (numerator < 0) {
      tempAbsQuotient = ~static_cast<unsigned int>(numerator) + 1U;
    } else {
      tempAbsQuotient = static_cast<unsigned int>(numerator);
    }

    if (denominator < 0) {
      u = ~static_cast<unsigned int>(denominator) + 1U;
    } else {
      u = static_cast<unsigned int>(denominator);
    }

    tempAbsQuotient /= u;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -static_cast<int>(tempAbsQuotient);
    } else {
      quotient = static_cast<int>(tempAbsQuotient);
    }
  }

  return quotient;
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void e_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Compile-time size assumption violated. At run-time, a vector indexes a vector of different orientations, but the compile-time as"
    "sumption is that the matrix is indexed by a vector.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *r
//                const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void e_rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "The loop variable of class ") << r) <<
    " might overflow on the last iteration of the for loop. This could lead to an infinite loop.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const int aDim1
//                const int aDim2
//                const rtEqualityCheckInfo &aInfo
// Return Type  : void
//
static void emlrtDimSizeImpxCheckR2021b(const int aDim1, const int aDim2, const
  rtEqualityCheckInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  ((((((outStream << "Size mismatch error on dimension ") << aInfo.nDims) <<
      ": expected ") << aDim1) << " or a singleton, but actual size is ") <<
    aDim2) << ".";
  outStream << "\n";
  ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo) <<
    ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void f_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Compile-time size assumption violated. At run-time, a vector indexes a scalar, but the compile-time assumption is that the vecto"
    "r is indexed by a vector of the same size.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void g_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "The subscript vectors must all be of the same size.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void h_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "The working dimension was selected automatically, is variable-size, and has length 1 at run time. This is not supported. Manuall"
    "y select the working dimension by supplying the DIM argument.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void i_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Matrix dimensions must agree.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void j_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Arrays have incompatible sizes for this operation.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void k_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Inner dimensions must agree. Generated code for a general matrix multiplication at this call site. If this should have been a sc"
    "alar times a variable-size matrix, the scalar input must be fixed-size.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void l_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Incorrect dimensions for matrix multiplication. Check that the number of columns in the first matrix matches the number of rows "
    "in the second matrix. To operate on each element of the matrix individually, use TIMES (.*) for elementwise multiplication.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void m_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "The first two inputs must have the same number of elements.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void minus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                  &in2)
{
  coder::array<float, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  b_in1.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in1[i1 + b_in1.size(0) * i] = in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] - in2[i1 * stride_1_0 + in2.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(b_in1.size(0), b_in1.size(1));
  loop_ub = b_in1.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = b_in1.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in1[i1 + b_in1.size(0) * i];
    }
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void n_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Non-singleton dimensions of the two input arrays must match each other.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void o_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Dimensions of arrays being concatenated are not consistent.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void p_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Second argument must be a positive scalar integer.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
// Return Type  : void
//
static void plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                 &in2)
{
  coder::array<float, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  b_in1.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in1[i1 + b_in1.size(0) * i] = in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] + in2[i1 * stride_1_0 + in2.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(b_in1.size(0), b_in1.size(1));
  loop_ub = b_in1.size(1);
  for (int i{0}; i < loop_ub; i++) {
    b_loop_ub = b_in1.size(0);
    for (int i1{0}; i1 < b_loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in1[i1 + b_in1.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<float, 1U> &in1
//                const coder::array<float, 1U> &in2
// Return Type  : void
//
static void plus(coder::array<float, 1U> &in1, const coder::array<float, 1U>
                 &in2)
{
  coder::array<float, 1U> b_in2;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  b_in2.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in1.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = in2[i * stride_0_0] + in1[i * stride_1_0];
  }

  in1.set_size(b_in2.size(0));
  loop_ub = b_in2.size(0);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 2U> &in3
// Return Type  : void
//
static void plus(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                 &in2, const coder::array<float, 2U> &in3)
{
  int aux_0_1;
  int aux_1_1;
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  in1.set_size(3, in1.size(1));
  if (in3.size(1) == 1) {
    loop_ub = in2.size(1);
  } else {
    loop_ub = in3.size(1);
  }

  in1.set_size(in1.size(0), loop_ub);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_1 = (in3.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < loop_ub; i++) {
    in1[3 * i] = in2[3 * aux_0_1] + in3[3 * aux_1_1];
    in1[3 * i + 1] = in2[3 * aux_0_1 + 1] + in3[3 * aux_1_1 + 1];
    in1[3 * i + 2] = in2[3 * aux_0_1 + 2] + in3[3 * aux_1_1 + 2];
    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void q_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "To RESHAPE the number of elements must not change, and if the input is empty, the maximum dimension length cannot be increased u"
    "nless the output size is fixed.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void r_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "To RESHAPE the number of elements must not change.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<float, 1U> &in1
//                const coder::array<float, 1U> &in2
// Return Type  : void
//
static void rdivide(coder::array<float, 1U> &in1, const coder::array<float, 1U>
                    &in2)
{
  coder::array<float, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] / in2[i * stride_1_0];
  }

  in1.set_size(b_in1.size(0));
  loop_ub = b_in1.size(0);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : const rtRunTimeErrorInfo &aInfo
// Return Type  : void
//
static void rtDivisionByZeroError(const rtRunTimeErrorInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Division by zero detected.\nEarly termination due to division by zero.";
  outStream << "\n";
  ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo) <<
    ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void rtDivisionByZeroErrorN()
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Division by zero detected.\nEarly termination due to division by zero.";
  outStream << "\n";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : int aIndexValue
//                int aLoBound
//                int aHiBound
//                const rtBoundsCheckInfo &aInfo
// Return Type  : void
//
static void rtDynamicBoundsError(int aIndexValue, int aLoBound, int aHiBound,
  const rtBoundsCheckInfo &aInfo)
{
  std::string b_errMsg;
  std::string errMsg;
  std::stringstream b_outStream;
  std::stringstream outStream;
  if (aLoBound == 0) {
    aIndexValue++;
    aLoBound = 1;
    aHiBound++;
  }

  if (rtIsNullOrEmptyString(aInfo.aName)) {
    ((((((b_outStream << "Index exceeds array dimensions. Index value ") <<
         aIndexValue) << " exceeds valid range [") << aLoBound) << "-") <<
      aHiBound) << "].";
    b_outStream << "\n";
    ((((b_outStream << "Error in ") << aInfo.fName) << " (line ") <<
      aInfo.lineNo) << ")";
    if (omp_in_parallel()) {
      b_errMsg = b_outStream.str();
      std::fprintf(stderr, "%s", b_errMsg.c_str());
      std::abort();
    } else {
      throw std::runtime_error(b_outStream.str());
    }
  } else {
    ((((((((outStream << "Index exceeds array dimensions. Index value ") <<
           aIndexValue) << " exceeds valid range [") << aLoBound) << "-") <<
       aHiBound) << "] for array \'") << aInfo.aName) << "\'.";
    outStream << "\n";
    ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo)
      << ")";
    if (omp_in_parallel()) {
      errMsg = outStream.str();
      std::fprintf(stderr, "%s", errMsg.c_str());
      std::abort();
    } else {
      throw std::runtime_error(outStream.str());
    }
  }
}

//
// Arguments    : const char *r
//                const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void rtErrorWithMessageID(const char *r, const char *aFcnName, int
  aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Expected ") << r) << " to be nonempty.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Maximum variable size allowed by the program is exceeded.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const int aNDims
//                const int *aDims
// Return Type  : std::string
//
static std::string rtGenSizeString(const int aNDims, const int *aDims)
{
  std::stringstream outStream;
  for (int i{0}; i < aNDims; i++) {
    outStream << "[";
    outStream << aDims[i];
    outStream << "]";
  }

  return outStream.str();
}

//
// Arguments    : const double aInteger
//                const rtDoubleCheckInfo &aInfo
// Return Type  : void
//
static void rtIntegerError(const double aInteger, const rtDoubleCheckInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Expected a value representable in the C type \'int\'. Found ")
    << aInteger) << " instead.";
  outStream << "\n";
  ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo) <<
    ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aString
// Return Type  : bool
//
static bool rtIsNullOrEmptyString(const char *aString)
{
  return (aString == nullptr) || (*aString == '\x00');
}

//
// Arguments    : const double aPositive
//                const rtDoubleCheckInfo &aInfo
// Return Type  : void
//
static void rtNonNegativeError(const double aPositive, const rtDoubleCheckInfo &
  aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  ((outStream << "Value ") << aPositive) <<
    " is not greater than or equal to zero.\nExiting to prevent memory corruption.";
  outStream << "\n";
  ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo) <<
    ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const int aDim1
//                const int aDim2
//                const rtEqualityCheckInfo &aInfo
// Return Type  : void
//
static void rtSizeEq1DError(const int aDim1, const int aDim2, const
  rtEqualityCheckInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  ((((outStream << "Sizes mismatch: ") << aDim1) << " ~= ") << aDim2) << ".";
  outStream << "\n";
  ((((outStream << "Error in ") << aInfo.fName) << " (line ") << aInfo.lineNo) <<
    ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const int *aDims1
//                const int *aDims2
//                const rtEqualityCheckInfo &aInfo
// Return Type  : void
//
static void rtSizeEqNDCheck(const int *aDims1, const int *aDims2, const
  rtEqualityCheckInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  for (int i{0}; i < aInfo.nDims; i++) {
    if (aDims1[i] != aDims2[i]) {
      std::string dims1Str;
      std::string dims2Str;
      dims1Str = rtGenSizeString(aInfo.nDims, aDims1);
      dims2Str = rtGenSizeString(aInfo.nDims, aDims2);
      ((((outStream << "Sizes mismatch: ") << dims1Str) << " ~= ") << dims2Str) <<
        ".";
      outStream << "\n";
      ((((outStream << "Error in ") << aInfo.fName) << " (line ") <<
        aInfo.lineNo) << ")";
      if (omp_in_parallel()) {
        errMsg = outStream.str();
        std::fprintf(stderr, "%s", errMsg.c_str());
        std::abort();
      } else {
        throw std::runtime_error(outStream.str());
      }
    }
  }
}

//
// Arguments    : const int *aDims1
//                const int aNDims1
//                const int *aDims2
//                const int aNDims2
//                const rtEqualityCheckInfo &aInfo
// Return Type  : void
//
static void rtSubAssignSizeCheck(const int *aDims1, const int aNDims1, const int
  *aDims2, const int aNDims2, const rtEqualityCheckInfo &aInfo)
{
  std::string errMsg;
  std::stringstream outStream;
  int i;
  int j;
  i = 0;
  j = 0;
  while ((i < aNDims1) && (j < aNDims2)) {
    while ((i < aNDims1) && (aDims1[i] == 1)) {
      i++;
    }

    while ((j < aNDims2) && (aDims2[j] == 1)) {
      j++;
    }

    if (((i < aNDims1) || (j < aNDims2)) && ((i == aNDims1) || ((j == aNDims2) ||
          ((aDims1[i] != -1) && ((aDims2[j] != -1) && (aDims1[i] != aDims2[j]))))))
    {
      std::string dims1Str;
      std::string dims2Str;
      dims1Str = rtGenSizeString(aNDims1, aDims1);
      dims2Str = rtGenSizeString(aNDims1, aDims2);
      ((((outStream << "Subscripted assignment dimension mismatch: ") <<
         dims1Str) << " ~= ") << dims2Str) << ".";
      outStream << "\n";
      ((((outStream << "Error in ") << aInfo.fName) << " (line ") <<
        aInfo.lineNo) << ")";
      if (omp_in_parallel()) {
        errMsg = outStream.str();
        std::fprintf(stderr, "%s", errMsg.c_str());
        std::abort();
      } else {
        throw std::runtime_error(outStream.str());
      }
    }

    i++;
    j++;
  }
}

//
// Arguments    : float u0
//                float u1
// Return Type  : float
//
static float rt_atan2f_snf(float u0, float u1)
{
  float y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = rtNaNF;
  } else if (std::isinf(u0) && std::isinf(u1)) {
    int i;
    int i1;
    if (u0 > 0.0F) {
      i = 1;
    } else {
      i = -1;
    }

    if (u1 > 0.0F) {
      i1 = 1;
    } else {
      i1 = -1;
    }

    y = std::atan2(static_cast<float>(i), static_cast<float>(i1));
  } else if (u1 == 0.0F) {
    if (u0 > 0.0F) {
      y = RT_PIF / 2.0F;
    } else if (u0 < 0.0F) {
      y = -(RT_PIF / 2.0F);
    } else {
      y = 0.0F;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_hypotd_snf(double u0, double u1)
{
  double a;
  double b;
  double y;
  a = std::abs(u0);
  b = std::abs(u1);
  if (a < b) {
    a /= b;
    y = b * std::sqrt(a * a + 1.0);
  } else if (a > b) {
    b /= a;
    y = a * std::sqrt(b * b + 1.0);
  } else if (std::isnan(b)) {
    y = rtNaN;
  } else {
    y = a * 1.4142135623730951;
  }

  return y;
}

//
// Arguments    : float u0
//                float u1
// Return Type  : float
//
static float rt_hypotf_snf(float u0, float u1)
{
  float a;
  float b;
  float y;
  a = std::abs(u0);
  b = std::abs(u1);
  if (a < b) {
    a /= b;
    y = b * std::sqrt(a * a + 1.0F);
  } else if (a > b) {
    b /= a;
    y = a * std::sqrt(b * b + 1.0F);
  } else if (std::isnan(b)) {
    y = rtNaNF;
  } else {
    y = a * 1.41421354F;
  }

  return y;
}

//
// Arguments    : double u0
//                double u1
// Return Type  : double
//
static double rt_remd_snf(double u0, double u1)
{
  double y;
  if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
    y = rtNaN;
  } else if (std::isinf(u1)) {
    y = u0;
  } else if ((u1 != 0.0) && (u1 != std::trunc(u1))) {
    double q;
    q = std::abs(u0 / u1);
    if (!(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q)) {
      y = 0.0 * u0;
    } else {
      y = std::fmod(u0, u1);
    }
  } else {
    y = std::fmod(u0, u1);
  }

  return y;
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void s_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "NaN values cannot be converted to logicals.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void subPixelLocationImpl_init()
{
  static const double dv[150]{ 0.028571428571428574, 0.028571428571428574, -0.04,
    -0.04, 0.04, -0.0742857142857143, 0.028571428571428574,
    -0.014285714285714285, -0.04, -0.02, 0.02, 0.01142857142857142,
    0.028571428571428574, -0.028571428571428571, -0.04, 0.0, 0.0,
    0.039999999999999994, 0.028571428571428574, -0.014285714285714285, -0.04,
    0.02, -0.02, 0.01142857142857142, 0.028571428571428574, 0.028571428571428574,
    -0.04, 0.04, -0.04, -0.0742857142857143, -0.014285714285714287,
    0.028571428571428571, -0.02, -0.04, 0.02, 0.011428571428571429,
    -0.014285714285714285, -0.014285714285714284, -0.02, -0.02, 0.01,
    0.097142857142857142, -0.01428571428571429, -0.028571428571428574, -0.02,
    0.0, 0.0, 0.12571428571428572, -0.014285714285714285, -0.014285714285714284,
    -0.02, 0.02, -0.01, 0.097142857142857142, -0.014285714285714287,
    0.028571428571428571, -0.02, 0.04, -0.02, 0.011428571428571429,
    -0.028571428571428574, 0.028571428571428571, 0.0, -0.04, 0.0,
    0.040000000000000008, -0.028571428571428574, -0.014285714285714287, 0.0,
    -0.02, 0.0, 0.12571428571428572, -0.028571428571428574,
    -0.028571428571428574, 0.0, 0.0, 0.0, 0.1542857142857143,
    -0.028571428571428574, -0.014285714285714287, 0.0, 0.02, 0.0,
    0.12571428571428572, -0.028571428571428574, 0.028571428571428571, 0.0, 0.04,
    0.0, 0.040000000000000008, -0.014285714285714287, 0.028571428571428571, 0.02,
    -0.04, -0.02, 0.011428571428571429, -0.014285714285714285,
    -0.014285714285714284, 0.02, -0.02, -0.01, 0.097142857142857142,
    -0.01428571428571429, -0.028571428571428574, 0.02, 0.0, 0.0,
    0.12571428571428572, -0.014285714285714285, -0.014285714285714284, 0.02,
    0.02, 0.01, 0.097142857142857142, -0.014285714285714287,
    0.028571428571428571, 0.02, 0.04, 0.02, 0.011428571428571429,
    0.028571428571428574, 0.028571428571428574, 0.04, -0.04, -0.04,
    -0.0742857142857143, 0.028571428571428574, -0.014285714285714285, 0.04,
    -0.02, -0.02, 0.01142857142857142, 0.028571428571428574,
    -0.028571428571428571, 0.04, 0.0, 0.0, 0.039999999999999994,
    0.028571428571428574, -0.014285714285714285, 0.04, 0.02, 0.02,
    0.01142857142857142, 0.028571428571428574, 0.028571428571428574, 0.04, 0.04,
    0.04, -0.0742857142857143 };

  std::copy(&dv[0], &dv[150], &X[0]);
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void t_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "ALL or ANY with one variable-size matrix input of [] is not supported.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : coder::array<float, 2U> &in1
//                const coder::array<float, 2U> &in2
//                const coder::array<float, 2U> &in3
// Return Type  : void
//
static void times(coder::array<float, 2U> &in1, const coder::array<float, 2U>
                  &in2, const coder::array<float, 2U> &in3)
{
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in3.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  in1.set_size(loop_ub, in1.size(1));
  if (in3.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in3.size(1);
  }

  in1.set_size(in1.size(0), b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0 = (in3.size(0) != 1);
  stride_1_1 = (in3.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = in2[i1 * stride_0_0 + in2.size(0) * aux_0_1] *
        in3[i1 * stride_1_0 + in3.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void u_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "CAT arguments dimensions are not consistent.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void v_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Compile-time size assumption violated. At run-time, a row vector logical indexes a matrix, but the compile-time assumption is lo"
    "gical indexing for the matrix by a matrix of the same size.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void w_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream <<
    "Compile-time size assumption violated. At run-time, a matrix logical indexes a row vector, but the compile-time assumption is lo"
    "gical indexing for the matrix by a matrix of the same size.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Arguments    : const char *aFcnName
//                int aLineNum
// Return Type  : void
//
static void y_rtErrorWithMessageID(const char *aFcnName, int aLineNum)
{
  std::string errMsg;
  std::stringstream outStream;
  outStream << "Vector expression with zero stride is not supported.";
  outStream << "\n";
  ((((outStream << "Error in ") << aFcnName) << " (line ") << aLineNum) << ")";
  if (omp_in_parallel()) {
    errMsg = outStream.str();
    std::fprintf(stderr, "%s", errMsg.c_str());
    std::abort();
  } else {
    throw std::runtime_error(outStream.str());
  }
}

//
// Detect the checkerboard corners
//
// Arguments    : const coder::array<unsigned char, 2U> &image
//                coder::array<double, 2U> &corners
//                double boardSize[2]
// Return Type  : void
//
void matlabCheckerBoardDetect(const coder::array<unsigned char, 2U> &image,
  coder::array<double, 2U> &corners, double boardSize[2])
{
  static rtBoundsCheckInfo qf_emlrtBCI{ -1,// iFirst
    -1,                                // iLast
    742,                               // lineNo
    5,                                 // colNo
    "",                                // aName
    "detectCheckerboardInOneImage",    // fName
    "/usr/local/MATLAB/R2023a/toolbox/vision/vision/detectCheckerboardPoints.m",// pName
    0                                  // checkKind
  };

  static rtRunTimeErrorInfo s_emlrtRTEI{ 13,// lineNo
    37,                                // colNo
    "validatenonempty",                // fName
    "/usr/local/MATLAB/R2023a/toolbox/eml/eml/+coder/+internal/+valattr/validatenonempty.m"// pName
  };

  coder::vision::internal::calibration::checkerboard::Checkerboard lobj_0[6];
  coder::vision::internal::calibration::checkerboard::Checkerboard *board0;
  coder::vision::internal::calibration::checkerboard::Checkerboard *currentBoard;
  coder::vision::internal::calibration::checkerboard::Checkerboard *iobj_0;
  coder::vision::internal::calibration::checkerboard::Checkerboard
    *previousBoard;
  coder::vision::internal::calibration::checkerboard::Checkerboard *tmpBoard;
  coder::array<double, 1U> sortedIdx;
  coder::array<float, 2U> I_45_45;
  coder::array<float, 2U> Ix;
  coder::array<float, 2U> Ix2;
  coder::array<float, 2U> IxIy;
  coder::array<float, 2U> Ixy;
  coder::array<float, 2U> Iy;
  coder::array<float, 2U> Iy2;
  coder::array<float, 2U> b_I;
  coder::array<float, 2U> c45;
  coder::array<float, 2U> cxy;
  coder::array<float, 2U> points0;
  coder::array<float, 1U> b_points0;
  coder::array<float, 1U> c_points0;
  coder::array<unsigned int, 2U> b_seedIdx;
  coder::array<unsigned int, 2U> seedIdx;
  coder::array<int, 1U> iidx;
  coder::array<int, 1U> r1;
  coder::array<bool, 1U> r;
  float d_points0[2];
  float v1[2];
  float v2[2];
  int iv[2];
  int cxy_tmp;
  int i;
  int i1;
  int loop_ub;
  int n;
  unsigned int u;
  bool guard1{ false };

  bool guard2{ false };

  bool hasExpanded;
  if (!isInitialized_matlabCheckerBoardDetect) {
    matlabCheckerBoardDetect_initialize();
  }

  if ((image.size(0) == 0) || (image.size(1) == 0)) {
    rtErrorWithMessageID("I", s_emlrtRTEI.fName, s_emlrtRTEI.lineNo);
  }

  b_I.set_size(image.size(0), image.size(1));
  loop_ub = image.size(0) * image.size(1);
  for (i = 0; i < loop_ub; i++) {
    b_I[i] = static_cast<float>(image[i]) / 255.0F;
  }

  coder::vision::internal::calibration::checkerboard::secondDerivCornerMetric
    (b_I, cxy, c45, Ix, Iy, Ixy, I_45_45);
  coder::vision::internal::calibration::checkerboard::computeJacobianEntries(Ix,
    Iy, Ix2, Iy2, IxIy);
  coder::vision::internal::calibration::checkerboard::find_peaks(cxy, points0);
  b_points0.set_size(points0.size(0));
  loop_ub = points0.size(0);
  c_points0.set_size(points0.size(0));
  for (i = 0; i < loop_ub; i++) {
    b_points0[i] = points0[i + points0.size(0)];
    c_points0[i] = points0[i];
  }

  iv[0] = (*(int (*)[2])cxy.size())[0];
  iv[1] = (*(int (*)[2])cxy.size())[1];
  coder::internal::sub2ind(iv, b_points0, c_points0, iidx);
  sortedIdx.set_size(iidx.size(0));
  loop_ub = iidx.size(0);
  for (i = 0; i < loop_ub; i++) {
    sortedIdx[i] = iidx[i];
  }

  iv[0] = (*(int (*)[2])cxy.size())[0];
  iv[1] = (*(int (*)[2])cxy.size())[1];
  coder::internal::indexShapeCheck(iv, sortedIdx.size(0));
  cxy_tmp = cxy.size(0) * cxy.size(1);
  loop_ub = sortedIdx.size(0);
  for (i = 0; i < loop_ub; i++) {
    i1 = static_cast<int>(sortedIdx[i]);
    if ((i1 < 1) || (i1 > cxy_tmp)) {
      rtDynamicBoundsError(i1, 1, cxy_tmp, d_emlrtBCI);
    }
  }

  iobj_0 = &lobj_0[0];
  if (sortedIdx.size(0) == 0) {
    iobj_0[0].isValid = false;
    iobj_0[0].Energy = rtInfF;
    iobj_0[0].IsDistortionHigh = false;
    board0 = &iobj_0[0];
    iobj_0[0].BoardIdx.set_size(1, 1);
    iobj_0[0].BoardIdx[0] = 0.0;
    iobj_0[0].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[0].BoardIdx[i] = 0.0;
    }

    iobj_0[0].BoardCoords.set_size(1, 1, 1);
    iobj_0[0].BoardCoords[0] = 0.0;
    iobj_0[0].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[0].BoardCoords[i] = 0.0;
    }

    iobj_0[0].Points.set_size(1, 1);
    iobj_0[0].Points[0] = 0.0F;
    iobj_0[0].Points.set_size(0, 2);
  } else {
    if (points0.size(0) < 1) {
      seedIdx.set_size(1, 0);
    } else {
      seedIdx.set_size(1, points0.size(0));
      loop_ub = points0.size(0) - 1;
      for (i = 0; i <= loop_ub; i++) {
        seedIdx[i] = static_cast<unsigned int>(i) + 1U;
      }
    }

    iv[0] = (*(int (*)[2])seedIdx.size())[0];
    iv[1] = (*(int (*)[2])seedIdx.size())[1];
    coder::internal::indexShapeCheck(sortedIdx.size(0), iv);
    loop_ub = seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      i1 = static_cast<int>(seedIdx[i]);
      if (i1 > sortedIdx.size(0)) {
        rtDynamicBoundsError(i1, 1, sortedIdx.size(0), e_emlrtBCI);
      }
    }

    b_points0.set_size(seedIdx.size(1));
    loop_ub = seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_points0[i] = cxy[static_cast<int>(static_cast<unsigned int>(sortedIdx[
        static_cast<int>(seedIdx[i]) - 1])) - 1];
    }

    coder::internal::sort(b_points0, iidx);
    sortedIdx.set_size(iidx.size(0));
    loop_ub = iidx.size(0);
    for (i = 0; i < loop_ub; i++) {
      sortedIdx[i] = iidx[i];
    }

    iv[0] = (*(int (*)[2])seedIdx.size())[0];
    iv[1] = (*(int (*)[2])seedIdx.size())[1];
    coder::internal::b_indexShapeCheck(iv, sortedIdx.size(0));
    b_seedIdx.set_size(1, sortedIdx.size(0));
    loop_ub = sortedIdx.size(0);
    for (i = 0; i < loop_ub; i++) {
      i1 = static_cast<int>(sortedIdx[i]);
      if ((i1 < 1) || (i1 > seedIdx.size(1))) {
        rtDynamicBoundsError(i1, 1, seedIdx.size(1), f_emlrtBCI);
      }

      b_seedIdx[i] = seedIdx[i1 - 1];
    }

    seedIdx.set_size(1, b_seedIdx.size(1));
    loop_ub = b_seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      seedIdx[i] = b_seedIdx[i];
    }

    if (sortedIdx.size(0) > 2000) {
      loop_ub = static_cast<int>(std::fmin(2000.0, std::round(static_cast<double>
        (seedIdx.size(1)) / 2.0)));
      if (loop_ub < 1) {
        loop_ub = 0;
      } else {
        if (seedIdx.size(1) < 1) {
          rtDynamicBoundsError(1, 1, seedIdx.size(1), c_emlrtBCI);
        }

        if (loop_ub > seedIdx.size(1)) {
          rtDynamicBoundsError(loop_ub, 1, seedIdx.size(1), b_emlrtBCI);
        }
      }

      for (i = 0; i < loop_ub; i++) {
        seedIdx[i] = seedIdx[i];
      }

      seedIdx.set_size(1, loop_ub);
    }

    iobj_0[1].isValid = false;
    iobj_0[1].Energy = rtInfF;
    iobj_0[1].IsDistortionHigh = false;
    previousBoard = &iobj_0[1];
    iobj_0[1].BoardIdx.set_size(1, 1);
    iobj_0[1].BoardIdx[0] = 0.0;
    iobj_0[1].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[1].BoardIdx[i] = 0.0;
    }

    iobj_0[1].BoardCoords.set_size(1, 1, 1);
    iobj_0[1].BoardCoords[0] = 0.0;
    iobj_0[1].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[1].BoardCoords[i] = 0.0;
    }

    iobj_0[1].Points.set_size(1, 1);
    iobj_0[1].Points[0] = 0.0F;
    iobj_0[1].Points.set_size(0, 2);
    iobj_0[1].IsDistortionHigh = false;
    iobj_0[2].isValid = false;
    iobj_0[2].Energy = rtInfF;
    iobj_0[2].IsDistortionHigh = false;
    currentBoard = &iobj_0[2];
    iobj_0[2].BoardIdx.set_size(1, 1);
    iobj_0[2].BoardIdx[0] = 0.0;
    iobj_0[2].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[2].BoardIdx[i] = 0.0;
    }

    iobj_0[2].BoardCoords.set_size(1, 1, 1);
    iobj_0[2].BoardCoords[0] = 0.0;
    iobj_0[2].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[2].BoardCoords[i] = 0.0;
    }

    iobj_0[2].Points.set_size(1, 1);
    iobj_0[2].Points[0] = 0.0F;
    iobj_0[2].Points.set_size(0, 2);
    iobj_0[2].IsDistortionHigh = false;
    i = seedIdx.size(1);
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      if (loop_ub + 1 > seedIdx.size(1)) {
        rtDynamicBoundsError(loop_ub + 1, 1, seedIdx.size(1), h_emlrtBCI);
      }

      u = seedIdx[loop_ub];
      if (static_cast<int>(u) > points0.size(0)) {
        rtDynamicBoundsError(static_cast<int>(u), 1, points0.size(0), emlrtBCI);
      }

      cxy_tmp = static_cast<int>(seedIdx[loop_ub]);
      d_points0[0] = points0[cxy_tmp - 1];
      d_points0[1] = points0[(cxy_tmp + points0.size(0)) - 1];
      coder::vision::internal::calibration::checkerboard::cornerOrientations(Ix2,
        Iy2, IxIy, d_points0, v1, v2);
      if ((!(std::abs(std::abs(rt_atan2f_snf(v1[1], v1[0])) - 3.14159274F) >
             0.58904862254808621)) || (!(std::abs(std::abs(rt_atan2f_snf(v2[1],
               v2[0])) - 3.14159274F) > 0.58904862254808621))) {
        if (loop_ub + 1 > seedIdx.size(1)) {
          rtDynamicBoundsError(loop_ub + 1, 1, seedIdx.size(1), i_emlrtBCI);
        }

        currentBoard->initialize(static_cast<double>(u), points0, v1, v2);
        if (currentBoard->isValid) {
          hasExpanded = true;
          while (hasExpanded) {
            hasExpanded = currentBoard->expandBoardOnce();
          }
        }

        if (currentBoard->Energy < previousBoard->Energy) {
          tmpBoard = previousBoard;
          previousBoard = currentBoard;
          currentBoard = tmpBoard;
        }
      }
    }

    board0 = previousBoard;
    if (previousBoard->isValid) {
      previousBoard->IsDirectionBad[0] = false;
      previousBoard->IsDirectionBad[1] = false;
      previousBoard->IsDirectionBad[2] = false;
      previousBoard->IsDirectionBad[3] = false;
      hasExpanded = true;
      while (hasExpanded) {
        hasExpanded = previousBoard->b_expandBoardOnce();
      }
    }
  }

  corners.set_size(0, 0);
  boardSize[0] = 0.0;
  boardSize[1] = 0.0;
  coder::vision::internal::calibration::checkerboard::find_peaks(c45, points0);
  b_points0.set_size(points0.size(0));
  loop_ub = points0.size(0);
  c_points0.set_size(points0.size(0));
  for (i = 0; i < loop_ub; i++) {
    b_points0[i] = points0[i + points0.size(0)];
    c_points0[i] = points0[i];
  }

  iv[0] = (*(int (*)[2])c45.size())[0];
  iv[1] = (*(int (*)[2])c45.size())[1];
  coder::internal::sub2ind(iv, b_points0, c_points0, iidx);
  sortedIdx.set_size(iidx.size(0));
  loop_ub = iidx.size(0);
  for (i = 0; i < loop_ub; i++) {
    sortedIdx[i] = iidx[i];
  }

  iv[0] = (*(int (*)[2])c45.size())[0];
  iv[1] = (*(int (*)[2])c45.size())[1];
  coder::internal::indexShapeCheck(iv, sortedIdx.size(0));
  cxy_tmp = c45.size(0) * c45.size(1);
  loop_ub = sortedIdx.size(0);
  for (i = 0; i < loop_ub; i++) {
    i1 = static_cast<int>(sortedIdx[i]);
    if ((i1 < 1) || (i1 > cxy_tmp)) {
      rtDynamicBoundsError(i1, 1, cxy_tmp, g_emlrtBCI);
    }
  }

  iobj_0 = &lobj_0[3];
  if (sortedIdx.size(0) == 0) {
    iobj_0[0].isValid = false;
    iobj_0[0].Energy = rtInfF;
    iobj_0[0].IsDistortionHigh = false;
    tmpBoard = &iobj_0[0];
    iobj_0[0].BoardIdx.set_size(1, 1);
    iobj_0[0].BoardIdx[0] = 0.0;
    iobj_0[0].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[0].BoardIdx[i] = 0.0;
    }

    iobj_0[0].BoardCoords.set_size(1, 1, 1);
    iobj_0[0].BoardCoords[0] = 0.0;
    iobj_0[0].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[0].BoardCoords[i] = 0.0;
    }

    iobj_0[0].Points.set_size(1, 1);
    iobj_0[0].Points[0] = 0.0F;
    iobj_0[0].Points.set_size(0, 2);
  } else {
    if (points0.size(0) < 1) {
      seedIdx.set_size(1, 0);
    } else {
      seedIdx.set_size(1, points0.size(0));
      loop_ub = points0.size(0) - 1;
      for (i = 0; i <= loop_ub; i++) {
        seedIdx[i] = static_cast<unsigned int>(i) + 1U;
      }
    }

    iv[0] = (*(int (*)[2])seedIdx.size())[0];
    iv[1] = (*(int (*)[2])seedIdx.size())[1];
    coder::internal::indexShapeCheck(sortedIdx.size(0), iv);
    loop_ub = seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      i1 = static_cast<int>(seedIdx[i]);
      if (i1 > sortedIdx.size(0)) {
        rtDynamicBoundsError(i1, 1, sortedIdx.size(0), e_emlrtBCI);
      }
    }

    b_points0.set_size(seedIdx.size(1));
    loop_ub = seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      b_points0[i] = c45[static_cast<int>(static_cast<unsigned int>(sortedIdx[
        static_cast<int>(seedIdx[i]) - 1])) - 1];
    }

    coder::internal::sort(b_points0, iidx);
    sortedIdx.set_size(iidx.size(0));
    loop_ub = iidx.size(0);
    for (i = 0; i < loop_ub; i++) {
      sortedIdx[i] = iidx[i];
    }

    iv[0] = (*(int (*)[2])seedIdx.size())[0];
    iv[1] = (*(int (*)[2])seedIdx.size())[1];
    coder::internal::b_indexShapeCheck(iv, sortedIdx.size(0));
    b_seedIdx.set_size(1, sortedIdx.size(0));
    loop_ub = sortedIdx.size(0);
    for (i = 0; i < loop_ub; i++) {
      i1 = static_cast<int>(sortedIdx[i]);
      if ((i1 < 1) || (i1 > seedIdx.size(1))) {
        rtDynamicBoundsError(i1, 1, seedIdx.size(1), f_emlrtBCI);
      }

      b_seedIdx[i] = seedIdx[i1 - 1];
    }

    seedIdx.set_size(1, b_seedIdx.size(1));
    loop_ub = b_seedIdx.size(1);
    for (i = 0; i < loop_ub; i++) {
      seedIdx[i] = b_seedIdx[i];
    }

    if (sortedIdx.size(0) > 2000) {
      loop_ub = static_cast<int>(std::fmin(2000.0, std::round(static_cast<double>
        (seedIdx.size(1)) / 2.0)));
      if (loop_ub < 1) {
        loop_ub = 0;
      } else {
        if (seedIdx.size(1) < 1) {
          rtDynamicBoundsError(1, 1, seedIdx.size(1), c_emlrtBCI);
        }

        if (loop_ub > seedIdx.size(1)) {
          rtDynamicBoundsError(loop_ub, 1, seedIdx.size(1), b_emlrtBCI);
        }
      }

      for (i = 0; i < loop_ub; i++) {
        seedIdx[i] = seedIdx[i];
      }

      seedIdx.set_size(1, loop_ub);
    }

    iobj_0[1].isValid = false;
    iobj_0[1].Energy = rtInfF;
    iobj_0[1].IsDistortionHigh = false;
    previousBoard = &iobj_0[1];
    iobj_0[1].BoardIdx.set_size(1, 1);
    iobj_0[1].BoardIdx[0] = 0.0;
    iobj_0[1].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[1].BoardIdx[i] = 0.0;
    }

    iobj_0[1].BoardCoords.set_size(1, 1, 1);
    iobj_0[1].BoardCoords[0] = 0.0;
    iobj_0[1].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[1].BoardCoords[i] = 0.0;
    }

    iobj_0[1].Points.set_size(1, 1);
    iobj_0[1].Points[0] = 0.0F;
    iobj_0[1].Points.set_size(0, 2);
    iobj_0[1].IsDistortionHigh = false;
    iobj_0[2].isValid = false;
    iobj_0[2].Energy = rtInfF;
    iobj_0[2].IsDistortionHigh = false;
    currentBoard = &iobj_0[2];
    iobj_0[2].BoardIdx.set_size(1, 1);
    iobj_0[2].BoardIdx[0] = 0.0;
    iobj_0[2].BoardIdx.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      iobj_0[2].BoardIdx[i] = 0.0;
    }

    iobj_0[2].BoardCoords.set_size(1, 1, 1);
    iobj_0[2].BoardCoords[0] = 0.0;
    iobj_0[2].BoardCoords.set_size(3, 3, 2);
    for (i = 0; i < 18; i++) {
      iobj_0[2].BoardCoords[i] = 0.0;
    }

    iobj_0[2].Points.set_size(1, 1);
    iobj_0[2].Points[0] = 0.0F;
    iobj_0[2].Points.set_size(0, 2);
    iobj_0[2].IsDistortionHigh = false;
    i = seedIdx.size(1);
    for (loop_ub = 0; loop_ub < i; loop_ub++) {
      if (loop_ub + 1 > seedIdx.size(1)) {
        rtDynamicBoundsError(loop_ub + 1, 1, seedIdx.size(1), h_emlrtBCI);
      }

      u = seedIdx[loop_ub];
      if (static_cast<int>(u) > points0.size(0)) {
        rtDynamicBoundsError(static_cast<int>(u), 1, points0.size(0), emlrtBCI);
      }

      cxy_tmp = static_cast<int>(seedIdx[loop_ub]);
      d_points0[0] = points0[cxy_tmp - 1];
      d_points0[1] = points0[(cxy_tmp + points0.size(0)) - 1];
      coder::vision::internal::calibration::checkerboard::cornerOrientations(Ix2,
        Iy2, IxIy, d_points0, v1, v2);
      if ((!(std::abs(std::abs(std::abs(rt_atan2f_snf(v1[1], v1[0])) -
              3.14159274F) - 0.785398185F) > 0.58904862254808621)) || (!(std::
            abs(std::abs(std::abs(rt_atan2f_snf(v2[1], v2[0])) - 3.14159274F) -
                0.785398185F) > 0.58904862254808621))) {
        if (loop_ub + 1 > seedIdx.size(1)) {
          rtDynamicBoundsError(loop_ub + 1, 1, seedIdx.size(1), i_emlrtBCI);
        }

        currentBoard->initialize(static_cast<double>(u), points0, v1, v2);
        if (currentBoard->isValid) {
          hasExpanded = true;
          while (hasExpanded) {
            hasExpanded = currentBoard->expandBoardOnce();
          }
        }

        if (currentBoard->Energy < previousBoard->Energy) {
          tmpBoard = previousBoard;
          previousBoard = currentBoard;
          currentBoard = tmpBoard;
        }
      }
    }

    tmpBoard = previousBoard;
    if (previousBoard->isValid) {
      previousBoard->IsDirectionBad[0] = false;
      previousBoard->IsDirectionBad[1] = false;
      previousBoard->IsDirectionBad[2] = false;
      previousBoard->IsDirectionBad[3] = false;
      hasExpanded = true;
      while (hasExpanded) {
        hasExpanded = previousBoard->b_expandBoardOnce();
      }
    }
  }

  guard1 = false;
  guard2 = false;
  if (board0->isValid) {
    if (board0->Energy <= tmpBoard->Energy) {
      guard2 = true;
    } else {
      unsigned int varargin_1[2];
      unsigned int varargin_2[2];
      bool exitg1;
      varargin_1[0] = static_cast<unsigned int>(board0->BoardIdx.size(0));
      varargin_1[1] = static_cast<unsigned int>(board0->BoardIdx.size(1));
      varargin_2[0] = static_cast<unsigned int>(tmpBoard->BoardIdx.size(0));
      varargin_2[1] = static_cast<unsigned int>(tmpBoard->BoardIdx.size(1));
      hasExpanded = true;
      loop_ub = 0;
      exitg1 = false;
      while ((!exitg1) && (loop_ub < 2)) {
        if (static_cast<int>(varargin_1[loop_ub]) != static_cast<int>
            (varargin_2[loop_ub])) {
          hasExpanded = false;
          exitg1 = true;
        } else {
          loop_ub++;
        }
      }

      if (hasExpanded) {
        sortedIdx.set_size(board0->BoardIdx.size(0) * board0->BoardIdx.size(1));
        loop_ub = board0->BoardIdx.size(0) * board0->BoardIdx.size(1);
        for (i = 0; i < loop_ub; i++) {
          sortedIdx[i] = board0->BoardIdx[i];
        }

        n = 0;
        i = sortedIdx.size(0);
        for (loop_ub = 0; loop_ub < i; loop_ub++) {
          if (sortedIdx[loop_ub] != 0.0) {
            n++;
          }
        }

        sortedIdx.set_size(tmpBoard->BoardIdx.size(0) * tmpBoard->BoardIdx.size
                           (1));
        loop_ub = tmpBoard->BoardIdx.size(0) * tmpBoard->BoardIdx.size(1);
        for (i = 0; i < loop_ub; i++) {
          sortedIdx[i] = tmpBoard->BoardIdx[i];
        }

        cxy_tmp = 0;
        i = sortedIdx.size(0);
        for (loop_ub = 0; loop_ub < i; loop_ub++) {
          if (sortedIdx[loop_ub] != 0.0) {
            cxy_tmp++;
          }
        }

        if (n > cxy_tmp) {
          guard2 = true;
        } else {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }
    }
  } else {
    guard1 = true;
  }

  if (guard2) {
    board0 = coder::vision::internal::calibration::checkerboard::orient(board0,
      b_I);
    coder::vision::internal::calibration::checkerboard::toPoints(board0, corners,
      boardSize);
    coder::vision::internal::calibration::checkerboard::subPixelLocation(Ixy,
      corners);
  }

  if (guard1 && tmpBoard->isValid) {
    tmpBoard = coder::vision::internal::calibration::checkerboard::orient
      (tmpBoard, b_I);
    coder::vision::internal::calibration::checkerboard::toPoints(tmpBoard,
      corners, boardSize);
    coder::vision::internal::calibration::checkerboard::subPixelLocation(I_45_45,
      corners);
  }

  if ((corners.size(0) == 0) || (corners.size(1) == 0)) {
    coder::vision::internal::calibration::checkerboard::detectCheckerboard(b_I,
      corners, boardSize);
  }

  hasExpanded = ((corners.size(0) != 0) && (corners.size(1) != 0));
  if (hasExpanded) {
    r.set_size(corners.size(0));
    loop_ub = corners.size(0);
    for (i = 0; i < loop_ub; i++) {
      r[i] = (corners[i] == 0.0);
    }

    n = r.size(0) - 1;
    cxy_tmp = 0;
    for (loop_ub = 0; loop_ub <= n; loop_ub++) {
      if (r[loop_ub]) {
        cxy_tmp++;
      }
    }

    r1.set_size(cxy_tmp);
    cxy_tmp = 0;
    for (loop_ub = 0; loop_ub <= n; loop_ub++) {
      if (r[loop_ub]) {
        r1[cxy_tmp] = loop_ub;
        cxy_tmp++;
      }
    }

    loop_ub = corners.size(1);
    cxy_tmp = r1.size(0);
    for (i = 0; i < loop_ub; i++) {
      for (i1 = 0; i1 < cxy_tmp; i1++) {
        if (r1[i1] > n) {
          rtDynamicBoundsError(r1[i1], 0, n, qf_emlrtBCI);
        }

        corners[r1[i1] + corners.size(0) * i] = rtNaN;
      }
    }

    r.set_size(corners.size(0));
    loop_ub = corners.size(0);
    for (i = 0; i < loop_ub; i++) {
      r[i] = std::isnan(corners[i]);
    }

    coder::any(r);
  }
}

//
// Arguments    : void
// Return Type  : void
//
void matlabCheckerBoardDetect_initialize()
{
  omp_init_nest_lock(&matlabCheckerBoardDetect_nestLockGlobal);
  subPixelLocationImpl_init();
  isInitialized_matlabCheckerBoardDetect = true;
}

//
// Arguments    : void
// Return Type  : void
//
void matlabCheckerBoardDetect_terminate()
{
  omp_destroy_nest_lock(&matlabCheckerBoardDetect_nestLockGlobal);
  isInitialized_matlabCheckerBoardDetect = false;
}

//
// File trailer for matlabCheckerBoardDetect.cpp
//
// [EOF]
//
